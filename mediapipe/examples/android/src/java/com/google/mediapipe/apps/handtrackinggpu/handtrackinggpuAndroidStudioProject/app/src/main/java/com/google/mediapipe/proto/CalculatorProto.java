// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mediapipe/framework/calculator.proto

package com.google.mediapipe.proto;

public final class CalculatorProto {
  private CalculatorProto() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  public interface ExecutorConfigOrBuilder extends
      // @@protoc_insertion_point(interface_extends:mediapipe.ExecutorConfig)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The name of the executor (used by a CalculatorGraphConfig::Node or
     * PacketGeneratorConfig to specify which executor it will execute on).
     * This field must be unique within a CalculatorGraphConfig. If this field
     * is omitted or is an empty string, the ExecutorConfig describes the
     * default executor.
     * NOTE: The names "default" and "gpu" are reserved and must not be used.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    java.lang.String getName();
    /**
     * <pre>
     * The name of the executor (used by a CalculatorGraphConfig::Node or
     * PacketGeneratorConfig to specify which executor it will execute on).
     * This field must be unique within a CalculatorGraphConfig. If this field
     * is omitted or is an empty string, the ExecutorConfig describes the
     * default executor.
     * NOTE: The names "default" and "gpu" are reserved and must not be used.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * The registered type of the executor. For example: "ThreadPoolExecutor".
     * The framework will create an executor of this type (with the options in
     * the options field) for the CalculatorGraph.
     * The ExecutorConfig for the default executor may omit this field and let
     * the framework choose an appropriate executor type. Note: If the options
     * field is used in this case, it should contain the
     * ThreadPoolExecutorOptions.
     * If the ExecutorConfig for an additional (non-default) executor omits this
     * field, the executor must be created outside the CalculatorGraph and
     * passed to the CalculatorGraph for use.
     * </pre>
     *
     * <code>optional string type = 2;</code>
     */
    java.lang.String getType();
    /**
     * <pre>
     * The registered type of the executor. For example: "ThreadPoolExecutor".
     * The framework will create an executor of this type (with the options in
     * the options field) for the CalculatorGraph.
     * The ExecutorConfig for the default executor may omit this field and let
     * the framework choose an appropriate executor type. Note: If the options
     * field is used in this case, it should contain the
     * ThreadPoolExecutorOptions.
     * If the ExecutorConfig for an additional (non-default) executor omits this
     * field, the executor must be created outside the CalculatorGraph and
     * passed to the CalculatorGraph for use.
     * </pre>
     *
     * <code>optional string type = 2;</code>
     */
    com.google.protobuf.ByteString
        getTypeBytes();

    /**
     * <pre>
     * The options passed to the Executor. The extension in the options field
     * must match the type field. For example, if the type field is
     * "ThreadPoolExecutor", then the options field should contain the
     * ThreadPoolExecutorOptions.
     * </pre>
     *
     * <code>optional .mediapipe.MediaPipeOptions options = 3;</code>
     */
    boolean hasOptions();
    /**
     * <pre>
     * The options passed to the Executor. The extension in the options field
     * must match the type field. For example, if the type field is
     * "ThreadPoolExecutor", then the options field should contain the
     * ThreadPoolExecutorOptions.
     * </pre>
     *
     * <code>optional .mediapipe.MediaPipeOptions options = 3;</code>
     */
    mediapipe.MediapipeOptions.MediaPipeOptions getOptions();
    /**
     * <pre>
     * The options passed to the Executor. The extension in the options field
     * must match the type field. For example, if the type field is
     * "ThreadPoolExecutor", then the options field should contain the
     * ThreadPoolExecutorOptions.
     * </pre>
     *
     * <code>optional .mediapipe.MediaPipeOptions options = 3;</code>
     */
    mediapipe.MediapipeOptions.MediaPipeOptionsOrBuilder getOptionsOrBuilder();
  }
  /**
   * <pre>
   * Describes a MediaPipe Executor.
   * </pre>
   *
   * Protobuf type {@code mediapipe.ExecutorConfig}
   */
  public  static final class ExecutorConfig extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:mediapipe.ExecutorConfig)
      ExecutorConfigOrBuilder {
    // Use ExecutorConfig.newBuilder() to construct.
    private ExecutorConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ExecutorConfig() {
      name_ = "";
      type_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return com.google.protobuf.UnknownFieldSet.getDefaultInstance();
    }
    private ExecutorConfig(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      int mutable_bitField0_ = 0;
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!input.skipField(tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              java.lang.String s = input.readStringRequireUtf8();

              name_ = s;
              break;
            }
            case 18: {
              java.lang.String s = input.readStringRequireUtf8();

              type_ = s;
              break;
            }
            case 26: {
              mediapipe.MediapipeOptions.MediaPipeOptions.Builder subBuilder = null;
              if (options_ != null) {
                subBuilder = options_.toBuilder();
              }
              options_ = input.readMessage(mediapipe.MediapipeOptions.MediaPipeOptions.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(options_);
                options_ = subBuilder.buildPartial();
              }

              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.google.mediapipe.proto.CalculatorProto.internal_static_mediapipe_ExecutorConfig_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.google.mediapipe.proto.CalculatorProto.internal_static_mediapipe_ExecutorConfig_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.google.mediapipe.proto.CalculatorProto.ExecutorConfig.class, com.google.mediapipe.proto.CalculatorProto.ExecutorConfig.Builder.class);
    }

    public static final int NAME_FIELD_NUMBER = 1;
    private volatile java.lang.Object name_;
    /**
     * <pre>
     * The name of the executor (used by a CalculatorGraphConfig::Node or
     * PacketGeneratorConfig to specify which executor it will execute on).
     * This field must be unique within a CalculatorGraphConfig. If this field
     * is omitted or is an empty string, the ExecutorConfig describes the
     * default executor.
     * NOTE: The names "default" and "gpu" are reserved and must not be used.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        name_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The name of the executor (used by a CalculatorGraphConfig::Node or
     * PacketGeneratorConfig to specify which executor it will execute on).
     * This field must be unique within a CalculatorGraphConfig. If this field
     * is omitted or is an empty string, the ExecutorConfig describes the
     * default executor.
     * NOTE: The names "default" and "gpu" are reserved and must not be used.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int TYPE_FIELD_NUMBER = 2;
    private volatile java.lang.Object type_;
    /**
     * <pre>
     * The registered type of the executor. For example: "ThreadPoolExecutor".
     * The framework will create an executor of this type (with the options in
     * the options field) for the CalculatorGraph.
     * The ExecutorConfig for the default executor may omit this field and let
     * the framework choose an appropriate executor type. Note: If the options
     * field is used in this case, it should contain the
     * ThreadPoolExecutorOptions.
     * If the ExecutorConfig for an additional (non-default) executor omits this
     * field, the executor must be created outside the CalculatorGraph and
     * passed to the CalculatorGraph for use.
     * </pre>
     *
     * <code>optional string type = 2;</code>
     */
    public java.lang.String getType() {
      java.lang.Object ref = type_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        type_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The registered type of the executor. For example: "ThreadPoolExecutor".
     * The framework will create an executor of this type (with the options in
     * the options field) for the CalculatorGraph.
     * The ExecutorConfig for the default executor may omit this field and let
     * the framework choose an appropriate executor type. Note: If the options
     * field is used in this case, it should contain the
     * ThreadPoolExecutorOptions.
     * If the ExecutorConfig for an additional (non-default) executor omits this
     * field, the executor must be created outside the CalculatorGraph and
     * passed to the CalculatorGraph for use.
     * </pre>
     *
     * <code>optional string type = 2;</code>
     */
    public com.google.protobuf.ByteString
        getTypeBytes() {
      java.lang.Object ref = type_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        type_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int OPTIONS_FIELD_NUMBER = 3;
    private mediapipe.MediapipeOptions.MediaPipeOptions options_;
    /**
     * <pre>
     * The options passed to the Executor. The extension in the options field
     * must match the type field. For example, if the type field is
     * "ThreadPoolExecutor", then the options field should contain the
     * ThreadPoolExecutorOptions.
     * </pre>
     *
     * <code>optional .mediapipe.MediaPipeOptions options = 3;</code>
     */
    public boolean hasOptions() {
      return options_ != null;
    }
    /**
     * <pre>
     * The options passed to the Executor. The extension in the options field
     * must match the type field. For example, if the type field is
     * "ThreadPoolExecutor", then the options field should contain the
     * ThreadPoolExecutorOptions.
     * </pre>
     *
     * <code>optional .mediapipe.MediaPipeOptions options = 3;</code>
     */
    public mediapipe.MediapipeOptions.MediaPipeOptions getOptions() {
      return options_ == null ? mediapipe.MediapipeOptions.MediaPipeOptions.getDefaultInstance() : options_;
    }
    /**
     * <pre>
     * The options passed to the Executor. The extension in the options field
     * must match the type field. For example, if the type field is
     * "ThreadPoolExecutor", then the options field should contain the
     * ThreadPoolExecutorOptions.
     * </pre>
     *
     * <code>optional .mediapipe.MediaPipeOptions options = 3;</code>
     */
    public mediapipe.MediapipeOptions.MediaPipeOptionsOrBuilder getOptionsOrBuilder() {
      return getOptions();
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (hasOptions()) {
        if (!getOptions().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!getNameBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, name_);
      }
      if (!getTypeBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, type_);
      }
      if (options_ != null) {
        output.writeMessage(3, getOptions());
      }
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!getNameBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, name_);
      }
      if (!getTypeBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, type_);
      }
      if (options_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getOptions());
      }
      memoizedSize = size;
      return size;
    }

    private static final long serialVersionUID = 0L;
    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.google.mediapipe.proto.CalculatorProto.ExecutorConfig)) {
        return super.equals(obj);
      }
      com.google.mediapipe.proto.CalculatorProto.ExecutorConfig other = (com.google.mediapipe.proto.CalculatorProto.ExecutorConfig) obj;

      boolean result = true;
      result = result && getName()
          .equals(other.getName());
      result = result && getType()
          .equals(other.getType());
      result = result && (hasOptions() == other.hasOptions());
      if (hasOptions()) {
        result = result && getOptions()
            .equals(other.getOptions());
      }
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptorForType().hashCode();
      hash = (37 * hash) + NAME_FIELD_NUMBER;
      hash = (53 * hash) + getName().hashCode();
      hash = (37 * hash) + TYPE_FIELD_NUMBER;
      hash = (53 * hash) + getType().hashCode();
      if (hasOptions()) {
        hash = (37 * hash) + OPTIONS_FIELD_NUMBER;
        hash = (53 * hash) + getOptions().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.google.mediapipe.proto.CalculatorProto.ExecutorConfig parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.mediapipe.proto.CalculatorProto.ExecutorConfig parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.mediapipe.proto.CalculatorProto.ExecutorConfig parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.mediapipe.proto.CalculatorProto.ExecutorConfig parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.mediapipe.proto.CalculatorProto.ExecutorConfig parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static com.google.mediapipe.proto.CalculatorProto.ExecutorConfig parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.google.mediapipe.proto.CalculatorProto.ExecutorConfig parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static com.google.mediapipe.proto.CalculatorProto.ExecutorConfig parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.google.mediapipe.proto.CalculatorProto.ExecutorConfig parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static com.google.mediapipe.proto.CalculatorProto.ExecutorConfig parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.google.mediapipe.proto.CalculatorProto.ExecutorConfig prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Describes a MediaPipe Executor.
     * </pre>
     *
     * Protobuf type {@code mediapipe.ExecutorConfig}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:mediapipe.ExecutorConfig)
        com.google.mediapipe.proto.CalculatorProto.ExecutorConfigOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.google.mediapipe.proto.CalculatorProto.internal_static_mediapipe_ExecutorConfig_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.google.mediapipe.proto.CalculatorProto.internal_static_mediapipe_ExecutorConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.google.mediapipe.proto.CalculatorProto.ExecutorConfig.class, com.google.mediapipe.proto.CalculatorProto.ExecutorConfig.Builder.class);
      }

      // Construct using com.google.mediapipe.proto.CalculatorProto.ExecutorConfig.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        name_ = "";

        type_ = "";

        if (optionsBuilder_ == null) {
          options_ = null;
        } else {
          options_ = null;
          optionsBuilder_ = null;
        }
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.google.mediapipe.proto.CalculatorProto.internal_static_mediapipe_ExecutorConfig_descriptor;
      }

      public com.google.mediapipe.proto.CalculatorProto.ExecutorConfig getDefaultInstanceForType() {
        return com.google.mediapipe.proto.CalculatorProto.ExecutorConfig.getDefaultInstance();
      }

      public com.google.mediapipe.proto.CalculatorProto.ExecutorConfig build() {
        com.google.mediapipe.proto.CalculatorProto.ExecutorConfig result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public com.google.mediapipe.proto.CalculatorProto.ExecutorConfig buildPartial() {
        com.google.mediapipe.proto.CalculatorProto.ExecutorConfig result = new com.google.mediapipe.proto.CalculatorProto.ExecutorConfig(this);
        result.name_ = name_;
        result.type_ = type_;
        if (optionsBuilder_ == null) {
          result.options_ = options_;
        } else {
          result.options_ = optionsBuilder_.build();
        }
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.google.mediapipe.proto.CalculatorProto.ExecutorConfig) {
          return mergeFrom((com.google.mediapipe.proto.CalculatorProto.ExecutorConfig)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.google.mediapipe.proto.CalculatorProto.ExecutorConfig other) {
        if (other == com.google.mediapipe.proto.CalculatorProto.ExecutorConfig.getDefaultInstance()) return this;
        if (!other.getName().isEmpty()) {
          name_ = other.name_;
          onChanged();
        }
        if (!other.getType().isEmpty()) {
          type_ = other.type_;
          onChanged();
        }
        if (other.hasOptions()) {
          mergeOptions(other.getOptions());
        }
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        if (hasOptions()) {
          if (!getOptions().isInitialized()) {
            return false;
          }
        }
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        com.google.mediapipe.proto.CalculatorProto.ExecutorConfig parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (com.google.mediapipe.proto.CalculatorProto.ExecutorConfig) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * The name of the executor (used by a CalculatorGraphConfig::Node or
       * PacketGeneratorConfig to specify which executor it will execute on).
       * This field must be unique within a CalculatorGraphConfig. If this field
       * is omitted or is an empty string, the ExecutorConfig describes the
       * default executor.
       * NOTE: The names "default" and "gpu" are reserved and must not be used.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          name_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The name of the executor (used by a CalculatorGraphConfig::Node or
       * PacketGeneratorConfig to specify which executor it will execute on).
       * This field must be unique within a CalculatorGraphConfig. If this field
       * is omitted or is an empty string, the ExecutorConfig describes the
       * default executor.
       * NOTE: The names "default" and "gpu" are reserved and must not be used.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The name of the executor (used by a CalculatorGraphConfig::Node or
       * PacketGeneratorConfig to specify which executor it will execute on).
       * This field must be unique within a CalculatorGraphConfig. If this field
       * is omitted or is an empty string, the ExecutorConfig describes the
       * default executor.
       * NOTE: The names "default" and "gpu" are reserved and must not be used.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        name_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The name of the executor (used by a CalculatorGraphConfig::Node or
       * PacketGeneratorConfig to specify which executor it will execute on).
       * This field must be unique within a CalculatorGraphConfig. If this field
       * is omitted or is an empty string, the ExecutorConfig describes the
       * default executor.
       * NOTE: The names "default" and "gpu" are reserved and must not be used.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public Builder clearName() {
        
        name_ = getDefaultInstance().getName();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The name of the executor (used by a CalculatorGraphConfig::Node or
       * PacketGeneratorConfig to specify which executor it will execute on).
       * This field must be unique within a CalculatorGraphConfig. If this field
       * is omitted or is an empty string, the ExecutorConfig describes the
       * default executor.
       * NOTE: The names "default" and "gpu" are reserved and must not be used.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        name_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object type_ = "";
      /**
       * <pre>
       * The registered type of the executor. For example: "ThreadPoolExecutor".
       * The framework will create an executor of this type (with the options in
       * the options field) for the CalculatorGraph.
       * The ExecutorConfig for the default executor may omit this field and let
       * the framework choose an appropriate executor type. Note: If the options
       * field is used in this case, it should contain the
       * ThreadPoolExecutorOptions.
       * If the ExecutorConfig for an additional (non-default) executor omits this
       * field, the executor must be created outside the CalculatorGraph and
       * passed to the CalculatorGraph for use.
       * </pre>
       *
       * <code>optional string type = 2;</code>
       */
      public java.lang.String getType() {
        java.lang.Object ref = type_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          type_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The registered type of the executor. For example: "ThreadPoolExecutor".
       * The framework will create an executor of this type (with the options in
       * the options field) for the CalculatorGraph.
       * The ExecutorConfig for the default executor may omit this field and let
       * the framework choose an appropriate executor type. Note: If the options
       * field is used in this case, it should contain the
       * ThreadPoolExecutorOptions.
       * If the ExecutorConfig for an additional (non-default) executor omits this
       * field, the executor must be created outside the CalculatorGraph and
       * passed to the CalculatorGraph for use.
       * </pre>
       *
       * <code>optional string type = 2;</code>
       */
      public com.google.protobuf.ByteString
          getTypeBytes() {
        java.lang.Object ref = type_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          type_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The registered type of the executor. For example: "ThreadPoolExecutor".
       * The framework will create an executor of this type (with the options in
       * the options field) for the CalculatorGraph.
       * The ExecutorConfig for the default executor may omit this field and let
       * the framework choose an appropriate executor type. Note: If the options
       * field is used in this case, it should contain the
       * ThreadPoolExecutorOptions.
       * If the ExecutorConfig for an additional (non-default) executor omits this
       * field, the executor must be created outside the CalculatorGraph and
       * passed to the CalculatorGraph for use.
       * </pre>
       *
       * <code>optional string type = 2;</code>
       */
      public Builder setType(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        type_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The registered type of the executor. For example: "ThreadPoolExecutor".
       * The framework will create an executor of this type (with the options in
       * the options field) for the CalculatorGraph.
       * The ExecutorConfig for the default executor may omit this field and let
       * the framework choose an appropriate executor type. Note: If the options
       * field is used in this case, it should contain the
       * ThreadPoolExecutorOptions.
       * If the ExecutorConfig for an additional (non-default) executor omits this
       * field, the executor must be created outside the CalculatorGraph and
       * passed to the CalculatorGraph for use.
       * </pre>
       *
       * <code>optional string type = 2;</code>
       */
      public Builder clearType() {
        
        type_ = getDefaultInstance().getType();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The registered type of the executor. For example: "ThreadPoolExecutor".
       * The framework will create an executor of this type (with the options in
       * the options field) for the CalculatorGraph.
       * The ExecutorConfig for the default executor may omit this field and let
       * the framework choose an appropriate executor type. Note: If the options
       * field is used in this case, it should contain the
       * ThreadPoolExecutorOptions.
       * If the ExecutorConfig for an additional (non-default) executor omits this
       * field, the executor must be created outside the CalculatorGraph and
       * passed to the CalculatorGraph for use.
       * </pre>
       *
       * <code>optional string type = 2;</code>
       */
      public Builder setTypeBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        type_ = value;
        onChanged();
        return this;
      }

      private mediapipe.MediapipeOptions.MediaPipeOptions options_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          mediapipe.MediapipeOptions.MediaPipeOptions, mediapipe.MediapipeOptions.MediaPipeOptions.Builder, mediapipe.MediapipeOptions.MediaPipeOptionsOrBuilder> optionsBuilder_;
      /**
       * <pre>
       * The options passed to the Executor. The extension in the options field
       * must match the type field. For example, if the type field is
       * "ThreadPoolExecutor", then the options field should contain the
       * ThreadPoolExecutorOptions.
       * </pre>
       *
       * <code>optional .mediapipe.MediaPipeOptions options = 3;</code>
       */
      public boolean hasOptions() {
        return optionsBuilder_ != null || options_ != null;
      }
      /**
       * <pre>
       * The options passed to the Executor. The extension in the options field
       * must match the type field. For example, if the type field is
       * "ThreadPoolExecutor", then the options field should contain the
       * ThreadPoolExecutorOptions.
       * </pre>
       *
       * <code>optional .mediapipe.MediaPipeOptions options = 3;</code>
       */
      public mediapipe.MediapipeOptions.MediaPipeOptions getOptions() {
        if (optionsBuilder_ == null) {
          return options_ == null ? mediapipe.MediapipeOptions.MediaPipeOptions.getDefaultInstance() : options_;
        } else {
          return optionsBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The options passed to the Executor. The extension in the options field
       * must match the type field. For example, if the type field is
       * "ThreadPoolExecutor", then the options field should contain the
       * ThreadPoolExecutorOptions.
       * </pre>
       *
       * <code>optional .mediapipe.MediaPipeOptions options = 3;</code>
       */
      public Builder setOptions(mediapipe.MediapipeOptions.MediaPipeOptions value) {
        if (optionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          options_ = value;
          onChanged();
        } else {
          optionsBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * The options passed to the Executor. The extension in the options field
       * must match the type field. For example, if the type field is
       * "ThreadPoolExecutor", then the options field should contain the
       * ThreadPoolExecutorOptions.
       * </pre>
       *
       * <code>optional .mediapipe.MediaPipeOptions options = 3;</code>
       */
      public Builder setOptions(
          mediapipe.MediapipeOptions.MediaPipeOptions.Builder builderForValue) {
        if (optionsBuilder_ == null) {
          options_ = builderForValue.build();
          onChanged();
        } else {
          optionsBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * The options passed to the Executor. The extension in the options field
       * must match the type field. For example, if the type field is
       * "ThreadPoolExecutor", then the options field should contain the
       * ThreadPoolExecutorOptions.
       * </pre>
       *
       * <code>optional .mediapipe.MediaPipeOptions options = 3;</code>
       */
      public Builder mergeOptions(mediapipe.MediapipeOptions.MediaPipeOptions value) {
        if (optionsBuilder_ == null) {
          if (options_ != null) {
            options_ =
              mediapipe.MediapipeOptions.MediaPipeOptions.newBuilder(options_).mergeFrom(value).buildPartial();
          } else {
            options_ = value;
          }
          onChanged();
        } else {
          optionsBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * The options passed to the Executor. The extension in the options field
       * must match the type field. For example, if the type field is
       * "ThreadPoolExecutor", then the options field should contain the
       * ThreadPoolExecutorOptions.
       * </pre>
       *
       * <code>optional .mediapipe.MediaPipeOptions options = 3;</code>
       */
      public Builder clearOptions() {
        if (optionsBuilder_ == null) {
          options_ = null;
          onChanged();
        } else {
          options_ = null;
          optionsBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * The options passed to the Executor. The extension in the options field
       * must match the type field. For example, if the type field is
       * "ThreadPoolExecutor", then the options field should contain the
       * ThreadPoolExecutorOptions.
       * </pre>
       *
       * <code>optional .mediapipe.MediaPipeOptions options = 3;</code>
       */
      public mediapipe.MediapipeOptions.MediaPipeOptions.Builder getOptionsBuilder() {
        
        onChanged();
        return getOptionsFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The options passed to the Executor. The extension in the options field
       * must match the type field. For example, if the type field is
       * "ThreadPoolExecutor", then the options field should contain the
       * ThreadPoolExecutorOptions.
       * </pre>
       *
       * <code>optional .mediapipe.MediaPipeOptions options = 3;</code>
       */
      public mediapipe.MediapipeOptions.MediaPipeOptionsOrBuilder getOptionsOrBuilder() {
        if (optionsBuilder_ != null) {
          return optionsBuilder_.getMessageOrBuilder();
        } else {
          return options_ == null ?
              mediapipe.MediapipeOptions.MediaPipeOptions.getDefaultInstance() : options_;
        }
      }
      /**
       * <pre>
       * The options passed to the Executor. The extension in the options field
       * must match the type field. For example, if the type field is
       * "ThreadPoolExecutor", then the options field should contain the
       * ThreadPoolExecutorOptions.
       * </pre>
       *
       * <code>optional .mediapipe.MediaPipeOptions options = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          mediapipe.MediapipeOptions.MediaPipeOptions, mediapipe.MediapipeOptions.MediaPipeOptions.Builder, mediapipe.MediapipeOptions.MediaPipeOptionsOrBuilder> 
          getOptionsFieldBuilder() {
        if (optionsBuilder_ == null) {
          optionsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              mediapipe.MediapipeOptions.MediaPipeOptions, mediapipe.MediapipeOptions.MediaPipeOptions.Builder, mediapipe.MediapipeOptions.MediaPipeOptionsOrBuilder>(
                  getOptions(),
                  getParentForChildren(),
                  isClean());
          options_ = null;
        }
        return optionsBuilder_;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return this;
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return this;
      }


      // @@protoc_insertion_point(builder_scope:mediapipe.ExecutorConfig)
    }

    // @@protoc_insertion_point(class_scope:mediapipe.ExecutorConfig)
    private static final com.google.mediapipe.proto.CalculatorProto.ExecutorConfig DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.google.mediapipe.proto.CalculatorProto.ExecutorConfig();
    }

    public static com.google.mediapipe.proto.CalculatorProto.ExecutorConfig getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ExecutorConfig>
        PARSER = new com.google.protobuf.AbstractParser<ExecutorConfig>() {
      public ExecutorConfig parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
          return new ExecutorConfig(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ExecutorConfig> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ExecutorConfig> getParserForType() {
      return PARSER;
    }

    public com.google.mediapipe.proto.CalculatorProto.ExecutorConfig getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface InputCollectionOrBuilder extends
      // @@protoc_insertion_point(interface_extends:mediapipe.InputCollection)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The name of the input collection.  Name must match [a-z_][a-z0-9_]*
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    java.lang.String getName();
    /**
     * <pre>
     * The name of the input collection.  Name must match [a-z_][a-z0-9_]*
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * The names of each side packet.  The number of side_packet_name
     * must match the number of packets generated by the input file.
     * </pre>
     *
     * <code>repeated string side_packet_name = 2;</code>
     */
    java.util.List<java.lang.String>
        getSidePacketNameList();
    /**
     * <pre>
     * The names of each side packet.  The number of side_packet_name
     * must match the number of packets generated by the input file.
     * </pre>
     *
     * <code>repeated string side_packet_name = 2;</code>
     */
    int getSidePacketNameCount();
    /**
     * <pre>
     * The names of each side packet.  The number of side_packet_name
     * must match the number of packets generated by the input file.
     * </pre>
     *
     * <code>repeated string side_packet_name = 2;</code>
     */
    java.lang.String getSidePacketName(int index);
    /**
     * <pre>
     * The names of each side packet.  The number of side_packet_name
     * must match the number of packets generated by the input file.
     * </pre>
     *
     * <code>repeated string side_packet_name = 2;</code>
     */
    com.google.protobuf.ByteString
        getSidePacketNameBytes(int index);

    /**
     * <pre>
     * DEPRECATED: old way of referring to side_packet_name.
     * </pre>
     *
     * <code>repeated string external_input_name = 1002;</code>
     */
    java.util.List<java.lang.String>
        getExternalInputNameList();
    /**
     * <pre>
     * DEPRECATED: old way of referring to side_packet_name.
     * </pre>
     *
     * <code>repeated string external_input_name = 1002;</code>
     */
    int getExternalInputNameCount();
    /**
     * <pre>
     * DEPRECATED: old way of referring to side_packet_name.
     * </pre>
     *
     * <code>repeated string external_input_name = 1002;</code>
     */
    java.lang.String getExternalInputName(int index);
    /**
     * <pre>
     * DEPRECATED: old way of referring to side_packet_name.
     * </pre>
     *
     * <code>repeated string external_input_name = 1002;</code>
     */
    com.google.protobuf.ByteString
        getExternalInputNameBytes(int index);

    /**
     * <pre>
     * Sets the source of the input collection data.
     * The default value is UNKNOWN.
     * </pre>
     *
     * <code>optional .mediapipe.InputCollection.InputType input_type = 3;</code>
     */
    int getInputTypeValue();
    /**
     * <pre>
     * Sets the source of the input collection data.
     * The default value is UNKNOWN.
     * </pre>
     *
     * <code>optional .mediapipe.InputCollection.InputType input_type = 3;</code>
     */
    com.google.mediapipe.proto.CalculatorProto.InputCollection.InputType getInputType();

    /**
     * <pre>
     * A file name pointing to the data.  The format of the data is
     * specified by the "input_type" field.  Multiple shards may be
     * specified using &#64;N or glob expressions.
     * </pre>
     *
     * <code>optional string file_name = 4;</code>
     */
    java.lang.String getFileName();
    /**
     * <pre>
     * A file name pointing to the data.  The format of the data is
     * specified by the "input_type" field.  Multiple shards may be
     * specified using &#64;N or glob expressions.
     * </pre>
     *
     * <code>optional string file_name = 4;</code>
     */
    com.google.protobuf.ByteString
        getFileNameBytes();
  }
  /**
   * <pre>
   * A collection of input data to a CalculatorGraph.
   * </pre>
   *
   * Protobuf type {@code mediapipe.InputCollection}
   */
  public  static final class InputCollection extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:mediapipe.InputCollection)
      InputCollectionOrBuilder {
    // Use InputCollection.newBuilder() to construct.
    private InputCollection(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private InputCollection() {
      name_ = "";
      sidePacketName_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      externalInputName_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      inputType_ = 0;
      fileName_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return com.google.protobuf.UnknownFieldSet.getDefaultInstance();
    }
    private InputCollection(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      int mutable_bitField0_ = 0;
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!input.skipField(tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              java.lang.String s = input.readStringRequireUtf8();

              name_ = s;
              break;
            }
            case 18: {
              java.lang.String s = input.readStringRequireUtf8();
              if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                sidePacketName_ = new com.google.protobuf.LazyStringArrayList();
                mutable_bitField0_ |= 0x00000002;
              }
              sidePacketName_.add(s);
              break;
            }
            case 24: {
              int rawValue = input.readEnum();

              inputType_ = rawValue;
              break;
            }
            case 34: {
              java.lang.String s = input.readStringRequireUtf8();

              fileName_ = s;
              break;
            }
            case 8018: {
              java.lang.String s = input.readStringRequireUtf8();
              if (!((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
                externalInputName_ = new com.google.protobuf.LazyStringArrayList();
                mutable_bitField0_ |= 0x00000004;
              }
              externalInputName_.add(s);
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
          sidePacketName_ = sidePacketName_.getUnmodifiableView();
        }
        if (((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
          externalInputName_ = externalInputName_.getUnmodifiableView();
        }
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.google.mediapipe.proto.CalculatorProto.internal_static_mediapipe_InputCollection_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.google.mediapipe.proto.CalculatorProto.internal_static_mediapipe_InputCollection_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.google.mediapipe.proto.CalculatorProto.InputCollection.class, com.google.mediapipe.proto.CalculatorProto.InputCollection.Builder.class);
    }

    /**
     * <pre>
     * The input can be specified in several ways.
     * </pre>
     *
     * Protobuf enum {@code mediapipe.InputCollection.InputType}
     */
    public enum InputType
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <pre>
       * An invalid default value.  This value is guaranteed to be the
       * lowest enum value (i.e. don't add negative enum values).
       * </pre>
       *
       * <code>UNKNOWN = 0;</code>
       */
      UNKNOWN(0),
      /**
       * <pre>
       * A recordio where each record is a serialized PacketManagerConfig.
       * Each PacketManagerConfig must have the same number of packet
       * factories in it as the number of side packet names.  Furthermore,
       * the output side packet name field in each PacketFactoryConfig
       * must not be set.  This is the most general input, and allows
       * multiple side packet values to be set in arbitrarily complicated
       * ways before each run.
       * </pre>
       *
       * <code>RECORDIO = 1;</code>
       */
      RECORDIO(1),
      /**
       * <pre>
       * A recordio where each record is a serialized packet payload.
       * For example a recordio of serialized OmniaFeature protos dumped
       * from Omnia.
       * </pre>
       *
       * <code>FOREIGN_RECORDIO = 2;</code>
       */
      FOREIGN_RECORDIO(2),
      /**
       * <pre>
       * A text file where each line is a comma separated list. The number
       * of elements for each csv string must be the same as the number
       * of side_packet_name (and the order must match).  Each line must
       * be less than 1MiB in size.  Lines comprising of only whitespace
       * or only whitespace and a pound comment will be skipped.
       * </pre>
       *
       * <code>FOREIGN_CSV_TEXT = 3;</code>
       */
      FOREIGN_CSV_TEXT(3),
      /**
       * <pre>
       * This and all higher values are invalid.  Update this value to
       * always be larger than any other enum values you add.
       * </pre>
       *
       * <code>INVALID_UPPER_BOUND = 4;</code>
       */
      INVALID_UPPER_BOUND(4),
      UNRECOGNIZED(-1),
      ;

      /**
       * <pre>
       * An invalid default value.  This value is guaranteed to be the
       * lowest enum value (i.e. don't add negative enum values).
       * </pre>
       *
       * <code>UNKNOWN = 0;</code>
       */
      public static final int UNKNOWN_VALUE = 0;
      /**
       * <pre>
       * A recordio where each record is a serialized PacketManagerConfig.
       * Each PacketManagerConfig must have the same number of packet
       * factories in it as the number of side packet names.  Furthermore,
       * the output side packet name field in each PacketFactoryConfig
       * must not be set.  This is the most general input, and allows
       * multiple side packet values to be set in arbitrarily complicated
       * ways before each run.
       * </pre>
       *
       * <code>RECORDIO = 1;</code>
       */
      public static final int RECORDIO_VALUE = 1;
      /**
       * <pre>
       * A recordio where each record is a serialized packet payload.
       * For example a recordio of serialized OmniaFeature protos dumped
       * from Omnia.
       * </pre>
       *
       * <code>FOREIGN_RECORDIO = 2;</code>
       */
      public static final int FOREIGN_RECORDIO_VALUE = 2;
      /**
       * <pre>
       * A text file where each line is a comma separated list. The number
       * of elements for each csv string must be the same as the number
       * of side_packet_name (and the order must match).  Each line must
       * be less than 1MiB in size.  Lines comprising of only whitespace
       * or only whitespace and a pound comment will be skipped.
       * </pre>
       *
       * <code>FOREIGN_CSV_TEXT = 3;</code>
       */
      public static final int FOREIGN_CSV_TEXT_VALUE = 3;
      /**
       * <pre>
       * This and all higher values are invalid.  Update this value to
       * always be larger than any other enum values you add.
       * </pre>
       *
       * <code>INVALID_UPPER_BOUND = 4;</code>
       */
      public static final int INVALID_UPPER_BOUND_VALUE = 4;


      public final int getNumber() {
        if (this == UNRECOGNIZED) {
          throw new java.lang.IllegalArgumentException(
              "Can't get the number of an unknown enum value.");
        }
        return value;
      }

      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static InputType valueOf(int value) {
        return forNumber(value);
      }

      public static InputType forNumber(int value) {
        switch (value) {
          case 0: return UNKNOWN;
          case 1: return RECORDIO;
          case 2: return FOREIGN_RECORDIO;
          case 3: return FOREIGN_CSV_TEXT;
          case 4: return INVALID_UPPER_BOUND;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<InputType>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          InputType> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<InputType>() {
              public InputType findValueByNumber(int number) {
                return InputType.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return com.google.mediapipe.proto.CalculatorProto.InputCollection.getDescriptor().getEnumTypes().get(0);
      }

      private static final InputType[] VALUES = values();

      public static InputType valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        if (desc.getIndex() == -1) {
          return UNRECOGNIZED;
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private InputType(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mediapipe.InputCollection.InputType)
    }

    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;
    private volatile java.lang.Object name_;
    /**
     * <pre>
     * The name of the input collection.  Name must match [a-z_][a-z0-9_]*
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        name_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The name of the input collection.  Name must match [a-z_][a-z0-9_]*
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int SIDE_PACKET_NAME_FIELD_NUMBER = 2;
    private com.google.protobuf.LazyStringList sidePacketName_;
    /**
     * <pre>
     * The names of each side packet.  The number of side_packet_name
     * must match the number of packets generated by the input file.
     * </pre>
     *
     * <code>repeated string side_packet_name = 2;</code>
     */
    public com.google.protobuf.ProtocolStringList
        getSidePacketNameList() {
      return sidePacketName_;
    }
    /**
     * <pre>
     * The names of each side packet.  The number of side_packet_name
     * must match the number of packets generated by the input file.
     * </pre>
     *
     * <code>repeated string side_packet_name = 2;</code>
     */
    public int getSidePacketNameCount() {
      return sidePacketName_.size();
    }
    /**
     * <pre>
     * The names of each side packet.  The number of side_packet_name
     * must match the number of packets generated by the input file.
     * </pre>
     *
     * <code>repeated string side_packet_name = 2;</code>
     */
    public java.lang.String getSidePacketName(int index) {
      return sidePacketName_.get(index);
    }
    /**
     * <pre>
     * The names of each side packet.  The number of side_packet_name
     * must match the number of packets generated by the input file.
     * </pre>
     *
     * <code>repeated string side_packet_name = 2;</code>
     */
    public com.google.protobuf.ByteString
        getSidePacketNameBytes(int index) {
      return sidePacketName_.getByteString(index);
    }

    public static final int EXTERNAL_INPUT_NAME_FIELD_NUMBER = 1002;
    private com.google.protobuf.LazyStringList externalInputName_;
    /**
     * <pre>
     * DEPRECATED: old way of referring to side_packet_name.
     * </pre>
     *
     * <code>repeated string external_input_name = 1002;</code>
     */
    public com.google.protobuf.ProtocolStringList
        getExternalInputNameList() {
      return externalInputName_;
    }
    /**
     * <pre>
     * DEPRECATED: old way of referring to side_packet_name.
     * </pre>
     *
     * <code>repeated string external_input_name = 1002;</code>
     */
    public int getExternalInputNameCount() {
      return externalInputName_.size();
    }
    /**
     * <pre>
     * DEPRECATED: old way of referring to side_packet_name.
     * </pre>
     *
     * <code>repeated string external_input_name = 1002;</code>
     */
    public java.lang.String getExternalInputName(int index) {
      return externalInputName_.get(index);
    }
    /**
     * <pre>
     * DEPRECATED: old way of referring to side_packet_name.
     * </pre>
     *
     * <code>repeated string external_input_name = 1002;</code>
     */
    public com.google.protobuf.ByteString
        getExternalInputNameBytes(int index) {
      return externalInputName_.getByteString(index);
    }

    public static final int INPUT_TYPE_FIELD_NUMBER = 3;
    private int inputType_;
    /**
     * <pre>
     * Sets the source of the input collection data.
     * The default value is UNKNOWN.
     * </pre>
     *
     * <code>optional .mediapipe.InputCollection.InputType input_type = 3;</code>
     */
    public int getInputTypeValue() {
      return inputType_;
    }
    /**
     * <pre>
     * Sets the source of the input collection data.
     * The default value is UNKNOWN.
     * </pre>
     *
     * <code>optional .mediapipe.InputCollection.InputType input_type = 3;</code>
     */
    public com.google.mediapipe.proto.CalculatorProto.InputCollection.InputType getInputType() {
      com.google.mediapipe.proto.CalculatorProto.InputCollection.InputType result = com.google.mediapipe.proto.CalculatorProto.InputCollection.InputType.valueOf(inputType_);
      return result == null ? com.google.mediapipe.proto.CalculatorProto.InputCollection.InputType.UNRECOGNIZED : result;
    }

    public static final int FILE_NAME_FIELD_NUMBER = 4;
    private volatile java.lang.Object fileName_;
    /**
     * <pre>
     * A file name pointing to the data.  The format of the data is
     * specified by the "input_type" field.  Multiple shards may be
     * specified using &#64;N or glob expressions.
     * </pre>
     *
     * <code>optional string file_name = 4;</code>
     */
    public java.lang.String getFileName() {
      java.lang.Object ref = fileName_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        fileName_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * A file name pointing to the data.  The format of the data is
     * specified by the "input_type" field.  Multiple shards may be
     * specified using &#64;N or glob expressions.
     * </pre>
     *
     * <code>optional string file_name = 4;</code>
     */
    public com.google.protobuf.ByteString
        getFileNameBytes() {
      java.lang.Object ref = fileName_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        fileName_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!getNameBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, name_);
      }
      for (int i = 0; i < sidePacketName_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, sidePacketName_.getRaw(i));
      }
      if (inputType_ != com.google.mediapipe.proto.CalculatorProto.InputCollection.InputType.UNKNOWN.getNumber()) {
        output.writeEnum(3, inputType_);
      }
      if (!getFileNameBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 4, fileName_);
      }
      for (int i = 0; i < externalInputName_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1002, externalInputName_.getRaw(i));
      }
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!getNameBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, name_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < sidePacketName_.size(); i++) {
          dataSize += computeStringSizeNoTag(sidePacketName_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getSidePacketNameList().size();
      }
      if (inputType_ != com.google.mediapipe.proto.CalculatorProto.InputCollection.InputType.UNKNOWN.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(3, inputType_);
      }
      if (!getFileNameBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, fileName_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < externalInputName_.size(); i++) {
          dataSize += computeStringSizeNoTag(externalInputName_.getRaw(i));
        }
        size += dataSize;
        size += 2 * getExternalInputNameList().size();
      }
      memoizedSize = size;
      return size;
    }

    private static final long serialVersionUID = 0L;
    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.google.mediapipe.proto.CalculatorProto.InputCollection)) {
        return super.equals(obj);
      }
      com.google.mediapipe.proto.CalculatorProto.InputCollection other = (com.google.mediapipe.proto.CalculatorProto.InputCollection) obj;

      boolean result = true;
      result = result && getName()
          .equals(other.getName());
      result = result && getSidePacketNameList()
          .equals(other.getSidePacketNameList());
      result = result && getExternalInputNameList()
          .equals(other.getExternalInputNameList());
      result = result && inputType_ == other.inputType_;
      result = result && getFileName()
          .equals(other.getFileName());
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptorForType().hashCode();
      hash = (37 * hash) + NAME_FIELD_NUMBER;
      hash = (53 * hash) + getName().hashCode();
      if (getSidePacketNameCount() > 0) {
        hash = (37 * hash) + SIDE_PACKET_NAME_FIELD_NUMBER;
        hash = (53 * hash) + getSidePacketNameList().hashCode();
      }
      if (getExternalInputNameCount() > 0) {
        hash = (37 * hash) + EXTERNAL_INPUT_NAME_FIELD_NUMBER;
        hash = (53 * hash) + getExternalInputNameList().hashCode();
      }
      hash = (37 * hash) + INPUT_TYPE_FIELD_NUMBER;
      hash = (53 * hash) + inputType_;
      hash = (37 * hash) + FILE_NAME_FIELD_NUMBER;
      hash = (53 * hash) + getFileName().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.google.mediapipe.proto.CalculatorProto.InputCollection parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.mediapipe.proto.CalculatorProto.InputCollection parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.mediapipe.proto.CalculatorProto.InputCollection parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.mediapipe.proto.CalculatorProto.InputCollection parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.mediapipe.proto.CalculatorProto.InputCollection parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static com.google.mediapipe.proto.CalculatorProto.InputCollection parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.google.mediapipe.proto.CalculatorProto.InputCollection parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static com.google.mediapipe.proto.CalculatorProto.InputCollection parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.google.mediapipe.proto.CalculatorProto.InputCollection parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static com.google.mediapipe.proto.CalculatorProto.InputCollection parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.google.mediapipe.proto.CalculatorProto.InputCollection prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * A collection of input data to a CalculatorGraph.
     * </pre>
     *
     * Protobuf type {@code mediapipe.InputCollection}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:mediapipe.InputCollection)
        com.google.mediapipe.proto.CalculatorProto.InputCollectionOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.google.mediapipe.proto.CalculatorProto.internal_static_mediapipe_InputCollection_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.google.mediapipe.proto.CalculatorProto.internal_static_mediapipe_InputCollection_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.google.mediapipe.proto.CalculatorProto.InputCollection.class, com.google.mediapipe.proto.CalculatorProto.InputCollection.Builder.class);
      }

      // Construct using com.google.mediapipe.proto.CalculatorProto.InputCollection.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        name_ = "";

        sidePacketName_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000002);
        externalInputName_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000004);
        inputType_ = 0;

        fileName_ = "";

        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.google.mediapipe.proto.CalculatorProto.internal_static_mediapipe_InputCollection_descriptor;
      }

      public com.google.mediapipe.proto.CalculatorProto.InputCollection getDefaultInstanceForType() {
        return com.google.mediapipe.proto.CalculatorProto.InputCollection.getDefaultInstance();
      }

      public com.google.mediapipe.proto.CalculatorProto.InputCollection build() {
        com.google.mediapipe.proto.CalculatorProto.InputCollection result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public com.google.mediapipe.proto.CalculatorProto.InputCollection buildPartial() {
        com.google.mediapipe.proto.CalculatorProto.InputCollection result = new com.google.mediapipe.proto.CalculatorProto.InputCollection(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        result.name_ = name_;
        if (((bitField0_ & 0x00000002) == 0x00000002)) {
          sidePacketName_ = sidePacketName_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000002);
        }
        result.sidePacketName_ = sidePacketName_;
        if (((bitField0_ & 0x00000004) == 0x00000004)) {
          externalInputName_ = externalInputName_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000004);
        }
        result.externalInputName_ = externalInputName_;
        result.inputType_ = inputType_;
        result.fileName_ = fileName_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.google.mediapipe.proto.CalculatorProto.InputCollection) {
          return mergeFrom((com.google.mediapipe.proto.CalculatorProto.InputCollection)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.google.mediapipe.proto.CalculatorProto.InputCollection other) {
        if (other == com.google.mediapipe.proto.CalculatorProto.InputCollection.getDefaultInstance()) return this;
        if (!other.getName().isEmpty()) {
          name_ = other.name_;
          onChanged();
        }
        if (!other.sidePacketName_.isEmpty()) {
          if (sidePacketName_.isEmpty()) {
            sidePacketName_ = other.sidePacketName_;
            bitField0_ = (bitField0_ & ~0x00000002);
          } else {
            ensureSidePacketNameIsMutable();
            sidePacketName_.addAll(other.sidePacketName_);
          }
          onChanged();
        }
        if (!other.externalInputName_.isEmpty()) {
          if (externalInputName_.isEmpty()) {
            externalInputName_ = other.externalInputName_;
            bitField0_ = (bitField0_ & ~0x00000004);
          } else {
            ensureExternalInputNameIsMutable();
            externalInputName_.addAll(other.externalInputName_);
          }
          onChanged();
        }
        if (other.inputType_ != 0) {
          setInputTypeValue(other.getInputTypeValue());
        }
        if (!other.getFileName().isEmpty()) {
          fileName_ = other.fileName_;
          onChanged();
        }
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        com.google.mediapipe.proto.CalculatorProto.InputCollection parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (com.google.mediapipe.proto.CalculatorProto.InputCollection) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * The name of the input collection.  Name must match [a-z_][a-z0-9_]*
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          name_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The name of the input collection.  Name must match [a-z_][a-z0-9_]*
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The name of the input collection.  Name must match [a-z_][a-z0-9_]*
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        name_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The name of the input collection.  Name must match [a-z_][a-z0-9_]*
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public Builder clearName() {
        
        name_ = getDefaultInstance().getName();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The name of the input collection.  Name must match [a-z_][a-z0-9_]*
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        name_ = value;
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringList sidePacketName_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      private void ensureSidePacketNameIsMutable() {
        if (!((bitField0_ & 0x00000002) == 0x00000002)) {
          sidePacketName_ = new com.google.protobuf.LazyStringArrayList(sidePacketName_);
          bitField0_ |= 0x00000002;
         }
      }
      /**
       * <pre>
       * The names of each side packet.  The number of side_packet_name
       * must match the number of packets generated by the input file.
       * </pre>
       *
       * <code>repeated string side_packet_name = 2;</code>
       */
      public com.google.protobuf.ProtocolStringList
          getSidePacketNameList() {
        return sidePacketName_.getUnmodifiableView();
      }
      /**
       * <pre>
       * The names of each side packet.  The number of side_packet_name
       * must match the number of packets generated by the input file.
       * </pre>
       *
       * <code>repeated string side_packet_name = 2;</code>
       */
      public int getSidePacketNameCount() {
        return sidePacketName_.size();
      }
      /**
       * <pre>
       * The names of each side packet.  The number of side_packet_name
       * must match the number of packets generated by the input file.
       * </pre>
       *
       * <code>repeated string side_packet_name = 2;</code>
       */
      public java.lang.String getSidePacketName(int index) {
        return sidePacketName_.get(index);
      }
      /**
       * <pre>
       * The names of each side packet.  The number of side_packet_name
       * must match the number of packets generated by the input file.
       * </pre>
       *
       * <code>repeated string side_packet_name = 2;</code>
       */
      public com.google.protobuf.ByteString
          getSidePacketNameBytes(int index) {
        return sidePacketName_.getByteString(index);
      }
      /**
       * <pre>
       * The names of each side packet.  The number of side_packet_name
       * must match the number of packets generated by the input file.
       * </pre>
       *
       * <code>repeated string side_packet_name = 2;</code>
       */
      public Builder setSidePacketName(
          int index, java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureSidePacketNameIsMutable();
        sidePacketName_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The names of each side packet.  The number of side_packet_name
       * must match the number of packets generated by the input file.
       * </pre>
       *
       * <code>repeated string side_packet_name = 2;</code>
       */
      public Builder addSidePacketName(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureSidePacketNameIsMutable();
        sidePacketName_.add(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The names of each side packet.  The number of side_packet_name
       * must match the number of packets generated by the input file.
       * </pre>
       *
       * <code>repeated string side_packet_name = 2;</code>
       */
      public Builder addAllSidePacketName(
          java.lang.Iterable<java.lang.String> values) {
        ensureSidePacketNameIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, sidePacketName_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The names of each side packet.  The number of side_packet_name
       * must match the number of packets generated by the input file.
       * </pre>
       *
       * <code>repeated string side_packet_name = 2;</code>
       */
      public Builder clearSidePacketName() {
        sidePacketName_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The names of each side packet.  The number of side_packet_name
       * must match the number of packets generated by the input file.
       * </pre>
       *
       * <code>repeated string side_packet_name = 2;</code>
       */
      public Builder addSidePacketNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        ensureSidePacketNameIsMutable();
        sidePacketName_.add(value);
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringList externalInputName_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      private void ensureExternalInputNameIsMutable() {
        if (!((bitField0_ & 0x00000004) == 0x00000004)) {
          externalInputName_ = new com.google.protobuf.LazyStringArrayList(externalInputName_);
          bitField0_ |= 0x00000004;
         }
      }
      /**
       * <pre>
       * DEPRECATED: old way of referring to side_packet_name.
       * </pre>
       *
       * <code>repeated string external_input_name = 1002;</code>
       */
      public com.google.protobuf.ProtocolStringList
          getExternalInputNameList() {
        return externalInputName_.getUnmodifiableView();
      }
      /**
       * <pre>
       * DEPRECATED: old way of referring to side_packet_name.
       * </pre>
       *
       * <code>repeated string external_input_name = 1002;</code>
       */
      public int getExternalInputNameCount() {
        return externalInputName_.size();
      }
      /**
       * <pre>
       * DEPRECATED: old way of referring to side_packet_name.
       * </pre>
       *
       * <code>repeated string external_input_name = 1002;</code>
       */
      public java.lang.String getExternalInputName(int index) {
        return externalInputName_.get(index);
      }
      /**
       * <pre>
       * DEPRECATED: old way of referring to side_packet_name.
       * </pre>
       *
       * <code>repeated string external_input_name = 1002;</code>
       */
      public com.google.protobuf.ByteString
          getExternalInputNameBytes(int index) {
        return externalInputName_.getByteString(index);
      }
      /**
       * <pre>
       * DEPRECATED: old way of referring to side_packet_name.
       * </pre>
       *
       * <code>repeated string external_input_name = 1002;</code>
       */
      public Builder setExternalInputName(
          int index, java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureExternalInputNameIsMutable();
        externalInputName_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * DEPRECATED: old way of referring to side_packet_name.
       * </pre>
       *
       * <code>repeated string external_input_name = 1002;</code>
       */
      public Builder addExternalInputName(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureExternalInputNameIsMutable();
        externalInputName_.add(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * DEPRECATED: old way of referring to side_packet_name.
       * </pre>
       *
       * <code>repeated string external_input_name = 1002;</code>
       */
      public Builder addAllExternalInputName(
          java.lang.Iterable<java.lang.String> values) {
        ensureExternalInputNameIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, externalInputName_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * DEPRECATED: old way of referring to side_packet_name.
       * </pre>
       *
       * <code>repeated string external_input_name = 1002;</code>
       */
      public Builder clearExternalInputName() {
        externalInputName_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000004);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * DEPRECATED: old way of referring to side_packet_name.
       * </pre>
       *
       * <code>repeated string external_input_name = 1002;</code>
       */
      public Builder addExternalInputNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        ensureExternalInputNameIsMutable();
        externalInputName_.add(value);
        onChanged();
        return this;
      }

      private int inputType_ = 0;
      /**
       * <pre>
       * Sets the source of the input collection data.
       * The default value is UNKNOWN.
       * </pre>
       *
       * <code>optional .mediapipe.InputCollection.InputType input_type = 3;</code>
       */
      public int getInputTypeValue() {
        return inputType_;
      }
      /**
       * <pre>
       * Sets the source of the input collection data.
       * The default value is UNKNOWN.
       * </pre>
       *
       * <code>optional .mediapipe.InputCollection.InputType input_type = 3;</code>
       */
      public Builder setInputTypeValue(int value) {
        inputType_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Sets the source of the input collection data.
       * The default value is UNKNOWN.
       * </pre>
       *
       * <code>optional .mediapipe.InputCollection.InputType input_type = 3;</code>
       */
      public com.google.mediapipe.proto.CalculatorProto.InputCollection.InputType getInputType() {
        com.google.mediapipe.proto.CalculatorProto.InputCollection.InputType result = com.google.mediapipe.proto.CalculatorProto.InputCollection.InputType.valueOf(inputType_);
        return result == null ? com.google.mediapipe.proto.CalculatorProto.InputCollection.InputType.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * Sets the source of the input collection data.
       * The default value is UNKNOWN.
       * </pre>
       *
       * <code>optional .mediapipe.InputCollection.InputType input_type = 3;</code>
       */
      public Builder setInputType(com.google.mediapipe.proto.CalculatorProto.InputCollection.InputType value) {
        if (value == null) {
          throw new NullPointerException();
        }
        
        inputType_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Sets the source of the input collection data.
       * The default value is UNKNOWN.
       * </pre>
       *
       * <code>optional .mediapipe.InputCollection.InputType input_type = 3;</code>
       */
      public Builder clearInputType() {
        
        inputType_ = 0;
        onChanged();
        return this;
      }

      private java.lang.Object fileName_ = "";
      /**
       * <pre>
       * A file name pointing to the data.  The format of the data is
       * specified by the "input_type" field.  Multiple shards may be
       * specified using &#64;N or glob expressions.
       * </pre>
       *
       * <code>optional string file_name = 4;</code>
       */
      public java.lang.String getFileName() {
        java.lang.Object ref = fileName_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          fileName_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * A file name pointing to the data.  The format of the data is
       * specified by the "input_type" field.  Multiple shards may be
       * specified using &#64;N or glob expressions.
       * </pre>
       *
       * <code>optional string file_name = 4;</code>
       */
      public com.google.protobuf.ByteString
          getFileNameBytes() {
        java.lang.Object ref = fileName_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          fileName_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * A file name pointing to the data.  The format of the data is
       * specified by the "input_type" field.  Multiple shards may be
       * specified using &#64;N or glob expressions.
       * </pre>
       *
       * <code>optional string file_name = 4;</code>
       */
      public Builder setFileName(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        fileName_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A file name pointing to the data.  The format of the data is
       * specified by the "input_type" field.  Multiple shards may be
       * specified using &#64;N or glob expressions.
       * </pre>
       *
       * <code>optional string file_name = 4;</code>
       */
      public Builder clearFileName() {
        
        fileName_ = getDefaultInstance().getFileName();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A file name pointing to the data.  The format of the data is
       * specified by the "input_type" field.  Multiple shards may be
       * specified using &#64;N or glob expressions.
       * </pre>
       *
       * <code>optional string file_name = 4;</code>
       */
      public Builder setFileNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        fileName_ = value;
        onChanged();
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return this;
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return this;
      }


      // @@protoc_insertion_point(builder_scope:mediapipe.InputCollection)
    }

    // @@protoc_insertion_point(class_scope:mediapipe.InputCollection)
    private static final com.google.mediapipe.proto.CalculatorProto.InputCollection DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.google.mediapipe.proto.CalculatorProto.InputCollection();
    }

    public static com.google.mediapipe.proto.CalculatorProto.InputCollection getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<InputCollection>
        PARSER = new com.google.protobuf.AbstractParser<InputCollection>() {
      public InputCollection parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
          return new InputCollection(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<InputCollection> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<InputCollection> getParserForType() {
      return PARSER;
    }

    public com.google.mediapipe.proto.CalculatorProto.InputCollection getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface InputCollectionSetOrBuilder extends
      // @@protoc_insertion_point(interface_extends:mediapipe.InputCollectionSet)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>repeated .mediapipe.InputCollection input_collection = 1;</code>
     */
    java.util.List<com.google.mediapipe.proto.CalculatorProto.InputCollection> 
        getInputCollectionList();
    /**
     * <code>repeated .mediapipe.InputCollection input_collection = 1;</code>
     */
    com.google.mediapipe.proto.CalculatorProto.InputCollection getInputCollection(int index);
    /**
     * <code>repeated .mediapipe.InputCollection input_collection = 1;</code>
     */
    int getInputCollectionCount();
    /**
     * <code>repeated .mediapipe.InputCollection input_collection = 1;</code>
     */
    java.util.List<? extends com.google.mediapipe.proto.CalculatorProto.InputCollectionOrBuilder> 
        getInputCollectionOrBuilderList();
    /**
     * <code>repeated .mediapipe.InputCollection input_collection = 1;</code>
     */
    com.google.mediapipe.proto.CalculatorProto.InputCollectionOrBuilder getInputCollectionOrBuilder(
        int index);
  }
  /**
   * <pre>
   * A convenient way to specify a number of InputCollections.
   * </pre>
   *
   * Protobuf type {@code mediapipe.InputCollectionSet}
   */
  public  static final class InputCollectionSet extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:mediapipe.InputCollectionSet)
      InputCollectionSetOrBuilder {
    // Use InputCollectionSet.newBuilder() to construct.
    private InputCollectionSet(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private InputCollectionSet() {
      inputCollection_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return com.google.protobuf.UnknownFieldSet.getDefaultInstance();
    }
    private InputCollectionSet(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      int mutable_bitField0_ = 0;
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!input.skipField(tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              if (!((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
                inputCollection_ = new java.util.ArrayList<com.google.mediapipe.proto.CalculatorProto.InputCollection>();
                mutable_bitField0_ |= 0x00000001;
              }
              inputCollection_.add(
                  input.readMessage(com.google.mediapipe.proto.CalculatorProto.InputCollection.parser(), extensionRegistry));
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
          inputCollection_ = java.util.Collections.unmodifiableList(inputCollection_);
        }
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.google.mediapipe.proto.CalculatorProto.internal_static_mediapipe_InputCollectionSet_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.google.mediapipe.proto.CalculatorProto.internal_static_mediapipe_InputCollectionSet_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.google.mediapipe.proto.CalculatorProto.InputCollectionSet.class, com.google.mediapipe.proto.CalculatorProto.InputCollectionSet.Builder.class);
    }

    public static final int INPUT_COLLECTION_FIELD_NUMBER = 1;
    private java.util.List<com.google.mediapipe.proto.CalculatorProto.InputCollection> inputCollection_;
    /**
     * <code>repeated .mediapipe.InputCollection input_collection = 1;</code>
     */
    public java.util.List<com.google.mediapipe.proto.CalculatorProto.InputCollection> getInputCollectionList() {
      return inputCollection_;
    }
    /**
     * <code>repeated .mediapipe.InputCollection input_collection = 1;</code>
     */
    public java.util.List<? extends com.google.mediapipe.proto.CalculatorProto.InputCollectionOrBuilder> 
        getInputCollectionOrBuilderList() {
      return inputCollection_;
    }
    /**
     * <code>repeated .mediapipe.InputCollection input_collection = 1;</code>
     */
    public int getInputCollectionCount() {
      return inputCollection_.size();
    }
    /**
     * <code>repeated .mediapipe.InputCollection input_collection = 1;</code>
     */
    public com.google.mediapipe.proto.CalculatorProto.InputCollection getInputCollection(int index) {
      return inputCollection_.get(index);
    }
    /**
     * <code>repeated .mediapipe.InputCollection input_collection = 1;</code>
     */
    public com.google.mediapipe.proto.CalculatorProto.InputCollectionOrBuilder getInputCollectionOrBuilder(
        int index) {
      return inputCollection_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < inputCollection_.size(); i++) {
        output.writeMessage(1, inputCollection_.get(i));
      }
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < inputCollection_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, inputCollection_.get(i));
      }
      memoizedSize = size;
      return size;
    }

    private static final long serialVersionUID = 0L;
    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.google.mediapipe.proto.CalculatorProto.InputCollectionSet)) {
        return super.equals(obj);
      }
      com.google.mediapipe.proto.CalculatorProto.InputCollectionSet other = (com.google.mediapipe.proto.CalculatorProto.InputCollectionSet) obj;

      boolean result = true;
      result = result && getInputCollectionList()
          .equals(other.getInputCollectionList());
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptorForType().hashCode();
      if (getInputCollectionCount() > 0) {
        hash = (37 * hash) + INPUT_COLLECTION_FIELD_NUMBER;
        hash = (53 * hash) + getInputCollectionList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.google.mediapipe.proto.CalculatorProto.InputCollectionSet parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.mediapipe.proto.CalculatorProto.InputCollectionSet parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.mediapipe.proto.CalculatorProto.InputCollectionSet parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.mediapipe.proto.CalculatorProto.InputCollectionSet parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.mediapipe.proto.CalculatorProto.InputCollectionSet parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static com.google.mediapipe.proto.CalculatorProto.InputCollectionSet parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.google.mediapipe.proto.CalculatorProto.InputCollectionSet parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static com.google.mediapipe.proto.CalculatorProto.InputCollectionSet parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.google.mediapipe.proto.CalculatorProto.InputCollectionSet parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static com.google.mediapipe.proto.CalculatorProto.InputCollectionSet parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.google.mediapipe.proto.CalculatorProto.InputCollectionSet prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * A convenient way to specify a number of InputCollections.
     * </pre>
     *
     * Protobuf type {@code mediapipe.InputCollectionSet}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:mediapipe.InputCollectionSet)
        com.google.mediapipe.proto.CalculatorProto.InputCollectionSetOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.google.mediapipe.proto.CalculatorProto.internal_static_mediapipe_InputCollectionSet_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.google.mediapipe.proto.CalculatorProto.internal_static_mediapipe_InputCollectionSet_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.google.mediapipe.proto.CalculatorProto.InputCollectionSet.class, com.google.mediapipe.proto.CalculatorProto.InputCollectionSet.Builder.class);
      }

      // Construct using com.google.mediapipe.proto.CalculatorProto.InputCollectionSet.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getInputCollectionFieldBuilder();
        }
      }
      public Builder clear() {
        super.clear();
        if (inputCollectionBuilder_ == null) {
          inputCollection_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
        } else {
          inputCollectionBuilder_.clear();
        }
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.google.mediapipe.proto.CalculatorProto.internal_static_mediapipe_InputCollectionSet_descriptor;
      }

      public com.google.mediapipe.proto.CalculatorProto.InputCollectionSet getDefaultInstanceForType() {
        return com.google.mediapipe.proto.CalculatorProto.InputCollectionSet.getDefaultInstance();
      }

      public com.google.mediapipe.proto.CalculatorProto.InputCollectionSet build() {
        com.google.mediapipe.proto.CalculatorProto.InputCollectionSet result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public com.google.mediapipe.proto.CalculatorProto.InputCollectionSet buildPartial() {
        com.google.mediapipe.proto.CalculatorProto.InputCollectionSet result = new com.google.mediapipe.proto.CalculatorProto.InputCollectionSet(this);
        int from_bitField0_ = bitField0_;
        if (inputCollectionBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001)) {
            inputCollection_ = java.util.Collections.unmodifiableList(inputCollection_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.inputCollection_ = inputCollection_;
        } else {
          result.inputCollection_ = inputCollectionBuilder_.build();
        }
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.google.mediapipe.proto.CalculatorProto.InputCollectionSet) {
          return mergeFrom((com.google.mediapipe.proto.CalculatorProto.InputCollectionSet)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.google.mediapipe.proto.CalculatorProto.InputCollectionSet other) {
        if (other == com.google.mediapipe.proto.CalculatorProto.InputCollectionSet.getDefaultInstance()) return this;
        if (inputCollectionBuilder_ == null) {
          if (!other.inputCollection_.isEmpty()) {
            if (inputCollection_.isEmpty()) {
              inputCollection_ = other.inputCollection_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureInputCollectionIsMutable();
              inputCollection_.addAll(other.inputCollection_);
            }
            onChanged();
          }
        } else {
          if (!other.inputCollection_.isEmpty()) {
            if (inputCollectionBuilder_.isEmpty()) {
              inputCollectionBuilder_.dispose();
              inputCollectionBuilder_ = null;
              inputCollection_ = other.inputCollection_;
              bitField0_ = (bitField0_ & ~0x00000001);
              inputCollectionBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getInputCollectionFieldBuilder() : null;
            } else {
              inputCollectionBuilder_.addAllMessages(other.inputCollection_);
            }
          }
        }
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        com.google.mediapipe.proto.CalculatorProto.InputCollectionSet parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (com.google.mediapipe.proto.CalculatorProto.InputCollectionSet) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.util.List<com.google.mediapipe.proto.CalculatorProto.InputCollection> inputCollection_ =
        java.util.Collections.emptyList();
      private void ensureInputCollectionIsMutable() {
        if (!((bitField0_ & 0x00000001) == 0x00000001)) {
          inputCollection_ = new java.util.ArrayList<com.google.mediapipe.proto.CalculatorProto.InputCollection>(inputCollection_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          com.google.mediapipe.proto.CalculatorProto.InputCollection, com.google.mediapipe.proto.CalculatorProto.InputCollection.Builder, com.google.mediapipe.proto.CalculatorProto.InputCollectionOrBuilder> inputCollectionBuilder_;

      /**
       * <code>repeated .mediapipe.InputCollection input_collection = 1;</code>
       */
      public java.util.List<com.google.mediapipe.proto.CalculatorProto.InputCollection> getInputCollectionList() {
        if (inputCollectionBuilder_ == null) {
          return java.util.Collections.unmodifiableList(inputCollection_);
        } else {
          return inputCollectionBuilder_.getMessageList();
        }
      }
      /**
       * <code>repeated .mediapipe.InputCollection input_collection = 1;</code>
       */
      public int getInputCollectionCount() {
        if (inputCollectionBuilder_ == null) {
          return inputCollection_.size();
        } else {
          return inputCollectionBuilder_.getCount();
        }
      }
      /**
       * <code>repeated .mediapipe.InputCollection input_collection = 1;</code>
       */
      public com.google.mediapipe.proto.CalculatorProto.InputCollection getInputCollection(int index) {
        if (inputCollectionBuilder_ == null) {
          return inputCollection_.get(index);
        } else {
          return inputCollectionBuilder_.getMessage(index);
        }
      }
      /**
       * <code>repeated .mediapipe.InputCollection input_collection = 1;</code>
       */
      public Builder setInputCollection(
          int index, com.google.mediapipe.proto.CalculatorProto.InputCollection value) {
        if (inputCollectionBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureInputCollectionIsMutable();
          inputCollection_.set(index, value);
          onChanged();
        } else {
          inputCollectionBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .mediapipe.InputCollection input_collection = 1;</code>
       */
      public Builder setInputCollection(
          int index, com.google.mediapipe.proto.CalculatorProto.InputCollection.Builder builderForValue) {
        if (inputCollectionBuilder_ == null) {
          ensureInputCollectionIsMutable();
          inputCollection_.set(index, builderForValue.build());
          onChanged();
        } else {
          inputCollectionBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .mediapipe.InputCollection input_collection = 1;</code>
       */
      public Builder addInputCollection(com.google.mediapipe.proto.CalculatorProto.InputCollection value) {
        if (inputCollectionBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureInputCollectionIsMutable();
          inputCollection_.add(value);
          onChanged();
        } else {
          inputCollectionBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <code>repeated .mediapipe.InputCollection input_collection = 1;</code>
       */
      public Builder addInputCollection(
          int index, com.google.mediapipe.proto.CalculatorProto.InputCollection value) {
        if (inputCollectionBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureInputCollectionIsMutable();
          inputCollection_.add(index, value);
          onChanged();
        } else {
          inputCollectionBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .mediapipe.InputCollection input_collection = 1;</code>
       */
      public Builder addInputCollection(
          com.google.mediapipe.proto.CalculatorProto.InputCollection.Builder builderForValue) {
        if (inputCollectionBuilder_ == null) {
          ensureInputCollectionIsMutable();
          inputCollection_.add(builderForValue.build());
          onChanged();
        } else {
          inputCollectionBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .mediapipe.InputCollection input_collection = 1;</code>
       */
      public Builder addInputCollection(
          int index, com.google.mediapipe.proto.CalculatorProto.InputCollection.Builder builderForValue) {
        if (inputCollectionBuilder_ == null) {
          ensureInputCollectionIsMutable();
          inputCollection_.add(index, builderForValue.build());
          onChanged();
        } else {
          inputCollectionBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .mediapipe.InputCollection input_collection = 1;</code>
       */
      public Builder addAllInputCollection(
          java.lang.Iterable<? extends com.google.mediapipe.proto.CalculatorProto.InputCollection> values) {
        if (inputCollectionBuilder_ == null) {
          ensureInputCollectionIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, inputCollection_);
          onChanged();
        } else {
          inputCollectionBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <code>repeated .mediapipe.InputCollection input_collection = 1;</code>
       */
      public Builder clearInputCollection() {
        if (inputCollectionBuilder_ == null) {
          inputCollection_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          inputCollectionBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>repeated .mediapipe.InputCollection input_collection = 1;</code>
       */
      public Builder removeInputCollection(int index) {
        if (inputCollectionBuilder_ == null) {
          ensureInputCollectionIsMutable();
          inputCollection_.remove(index);
          onChanged();
        } else {
          inputCollectionBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <code>repeated .mediapipe.InputCollection input_collection = 1;</code>
       */
      public com.google.mediapipe.proto.CalculatorProto.InputCollection.Builder getInputCollectionBuilder(
          int index) {
        return getInputCollectionFieldBuilder().getBuilder(index);
      }
      /**
       * <code>repeated .mediapipe.InputCollection input_collection = 1;</code>
       */
      public com.google.mediapipe.proto.CalculatorProto.InputCollectionOrBuilder getInputCollectionOrBuilder(
          int index) {
        if (inputCollectionBuilder_ == null) {
          return inputCollection_.get(index);  } else {
          return inputCollectionBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <code>repeated .mediapipe.InputCollection input_collection = 1;</code>
       */
      public java.util.List<? extends com.google.mediapipe.proto.CalculatorProto.InputCollectionOrBuilder> 
           getInputCollectionOrBuilderList() {
        if (inputCollectionBuilder_ != null) {
          return inputCollectionBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(inputCollection_);
        }
      }
      /**
       * <code>repeated .mediapipe.InputCollection input_collection = 1;</code>
       */
      public com.google.mediapipe.proto.CalculatorProto.InputCollection.Builder addInputCollectionBuilder() {
        return getInputCollectionFieldBuilder().addBuilder(
            com.google.mediapipe.proto.CalculatorProto.InputCollection.getDefaultInstance());
      }
      /**
       * <code>repeated .mediapipe.InputCollection input_collection = 1;</code>
       */
      public com.google.mediapipe.proto.CalculatorProto.InputCollection.Builder addInputCollectionBuilder(
          int index) {
        return getInputCollectionFieldBuilder().addBuilder(
            index, com.google.mediapipe.proto.CalculatorProto.InputCollection.getDefaultInstance());
      }
      /**
       * <code>repeated .mediapipe.InputCollection input_collection = 1;</code>
       */
      public java.util.List<com.google.mediapipe.proto.CalculatorProto.InputCollection.Builder> 
           getInputCollectionBuilderList() {
        return getInputCollectionFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          com.google.mediapipe.proto.CalculatorProto.InputCollection, com.google.mediapipe.proto.CalculatorProto.InputCollection.Builder, com.google.mediapipe.proto.CalculatorProto.InputCollectionOrBuilder> 
          getInputCollectionFieldBuilder() {
        if (inputCollectionBuilder_ == null) {
          inputCollectionBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              com.google.mediapipe.proto.CalculatorProto.InputCollection, com.google.mediapipe.proto.CalculatorProto.InputCollection.Builder, com.google.mediapipe.proto.CalculatorProto.InputCollectionOrBuilder>(
                  inputCollection_,
                  ((bitField0_ & 0x00000001) == 0x00000001),
                  getParentForChildren(),
                  isClean());
          inputCollection_ = null;
        }
        return inputCollectionBuilder_;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return this;
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return this;
      }


      // @@protoc_insertion_point(builder_scope:mediapipe.InputCollectionSet)
    }

    // @@protoc_insertion_point(class_scope:mediapipe.InputCollectionSet)
    private static final com.google.mediapipe.proto.CalculatorProto.InputCollectionSet DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.google.mediapipe.proto.CalculatorProto.InputCollectionSet();
    }

    public static com.google.mediapipe.proto.CalculatorProto.InputCollectionSet getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<InputCollectionSet>
        PARSER = new com.google.protobuf.AbstractParser<InputCollectionSet>() {
      public InputCollectionSet parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
          return new InputCollectionSet(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<InputCollectionSet> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<InputCollectionSet> getParserForType() {
      return PARSER;
    }

    public com.google.mediapipe.proto.CalculatorProto.InputCollectionSet getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface InputStreamInfoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:mediapipe.InputStreamInfo)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * A description of the input stream.
     * This description uses the Calculator visible specification of
     * a stream.  The format is a tag, then an index with both being
     * optional.  If the tag is missing it is assumed to be "" and if
     * the index is missing then it is assumed to be 0.  If the index
     * is provided then a colon (':') must be used.
     * Examples:
     *   "TAG"     -&gt; tag "TAG",   index 0
     *   ""        -&gt; tag "",      index 0
     *   ":0"      -&gt; tag "",      index 0
     *   ":3"      -&gt; tag "",      index 3
     *   "VIDEO:0" -&gt; tag "VIDEO", index 0
     *   "VIDEO:2" -&gt; tag "VIDEO", index 2
     * </pre>
     *
     * <code>optional string tag_index = 1;</code>
     */
    java.lang.String getTagIndex();
    /**
     * <pre>
     * A description of the input stream.
     * This description uses the Calculator visible specification of
     * a stream.  The format is a tag, then an index with both being
     * optional.  If the tag is missing it is assumed to be "" and if
     * the index is missing then it is assumed to be 0.  If the index
     * is provided then a colon (':') must be used.
     * Examples:
     *   "TAG"     -&gt; tag "TAG",   index 0
     *   ""        -&gt; tag "",      index 0
     *   ":0"      -&gt; tag "",      index 0
     *   ":3"      -&gt; tag "",      index 3
     *   "VIDEO:0" -&gt; tag "VIDEO", index 0
     *   "VIDEO:2" -&gt; tag "VIDEO", index 2
     * </pre>
     *
     * <code>optional string tag_index = 1;</code>
     */
    com.google.protobuf.ByteString
        getTagIndexBytes();

    /**
     * <pre>
     * Whether the input stream is a back edge.
     * By default, MediaPipe requires graphs to be acyclic and treats cycles in a
     * graph as errors. To allow MediaPipe to accept a cyclic graph, set the
     * back_edge fields of the input streams that are back edges to true. A
     * cyclic graph usually has an obvious forward direction, and a back edge
     * goes in the opposite direction. For a formal definition of a back edge,
     * please see https://en.wikipedia.org/wiki/Depth-first_search.
     * </pre>
     *
     * <code>optional bool back_edge = 2;</code>
     */
    boolean getBackEdge();
  }
  /**
   * <pre>
   * Additional information about an input stream.
   * </pre>
   *
   * Protobuf type {@code mediapipe.InputStreamInfo}
   */
  public  static final class InputStreamInfo extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:mediapipe.InputStreamInfo)
      InputStreamInfoOrBuilder {
    // Use InputStreamInfo.newBuilder() to construct.
    private InputStreamInfo(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private InputStreamInfo() {
      tagIndex_ = "";
      backEdge_ = false;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return com.google.protobuf.UnknownFieldSet.getDefaultInstance();
    }
    private InputStreamInfo(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      int mutable_bitField0_ = 0;
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!input.skipField(tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              java.lang.String s = input.readStringRequireUtf8();

              tagIndex_ = s;
              break;
            }
            case 16: {

              backEdge_ = input.readBool();
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.google.mediapipe.proto.CalculatorProto.internal_static_mediapipe_InputStreamInfo_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.google.mediapipe.proto.CalculatorProto.internal_static_mediapipe_InputStreamInfo_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.google.mediapipe.proto.CalculatorProto.InputStreamInfo.class, com.google.mediapipe.proto.CalculatorProto.InputStreamInfo.Builder.class);
    }

    public static final int TAG_INDEX_FIELD_NUMBER = 1;
    private volatile java.lang.Object tagIndex_;
    /**
     * <pre>
     * A description of the input stream.
     * This description uses the Calculator visible specification of
     * a stream.  The format is a tag, then an index with both being
     * optional.  If the tag is missing it is assumed to be "" and if
     * the index is missing then it is assumed to be 0.  If the index
     * is provided then a colon (':') must be used.
     * Examples:
     *   "TAG"     -&gt; tag "TAG",   index 0
     *   ""        -&gt; tag "",      index 0
     *   ":0"      -&gt; tag "",      index 0
     *   ":3"      -&gt; tag "",      index 3
     *   "VIDEO:0" -&gt; tag "VIDEO", index 0
     *   "VIDEO:2" -&gt; tag "VIDEO", index 2
     * </pre>
     *
     * <code>optional string tag_index = 1;</code>
     */
    public java.lang.String getTagIndex() {
      java.lang.Object ref = tagIndex_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        tagIndex_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * A description of the input stream.
     * This description uses the Calculator visible specification of
     * a stream.  The format is a tag, then an index with both being
     * optional.  If the tag is missing it is assumed to be "" and if
     * the index is missing then it is assumed to be 0.  If the index
     * is provided then a colon (':') must be used.
     * Examples:
     *   "TAG"     -&gt; tag "TAG",   index 0
     *   ""        -&gt; tag "",      index 0
     *   ":0"      -&gt; tag "",      index 0
     *   ":3"      -&gt; tag "",      index 3
     *   "VIDEO:0" -&gt; tag "VIDEO", index 0
     *   "VIDEO:2" -&gt; tag "VIDEO", index 2
     * </pre>
     *
     * <code>optional string tag_index = 1;</code>
     */
    public com.google.protobuf.ByteString
        getTagIndexBytes() {
      java.lang.Object ref = tagIndex_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        tagIndex_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int BACK_EDGE_FIELD_NUMBER = 2;
    private boolean backEdge_;
    /**
     * <pre>
     * Whether the input stream is a back edge.
     * By default, MediaPipe requires graphs to be acyclic and treats cycles in a
     * graph as errors. To allow MediaPipe to accept a cyclic graph, set the
     * back_edge fields of the input streams that are back edges to true. A
     * cyclic graph usually has an obvious forward direction, and a back edge
     * goes in the opposite direction. For a formal definition of a back edge,
     * please see https://en.wikipedia.org/wiki/Depth-first_search.
     * </pre>
     *
     * <code>optional bool back_edge = 2;</code>
     */
    public boolean getBackEdge() {
      return backEdge_;
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!getTagIndexBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, tagIndex_);
      }
      if (backEdge_ != false) {
        output.writeBool(2, backEdge_);
      }
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!getTagIndexBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, tagIndex_);
      }
      if (backEdge_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(2, backEdge_);
      }
      memoizedSize = size;
      return size;
    }

    private static final long serialVersionUID = 0L;
    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.google.mediapipe.proto.CalculatorProto.InputStreamInfo)) {
        return super.equals(obj);
      }
      com.google.mediapipe.proto.CalculatorProto.InputStreamInfo other = (com.google.mediapipe.proto.CalculatorProto.InputStreamInfo) obj;

      boolean result = true;
      result = result && getTagIndex()
          .equals(other.getTagIndex());
      result = result && (getBackEdge()
          == other.getBackEdge());
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptorForType().hashCode();
      hash = (37 * hash) + TAG_INDEX_FIELD_NUMBER;
      hash = (53 * hash) + getTagIndex().hashCode();
      hash = (37 * hash) + BACK_EDGE_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getBackEdge());
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.google.mediapipe.proto.CalculatorProto.InputStreamInfo parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.mediapipe.proto.CalculatorProto.InputStreamInfo parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.mediapipe.proto.CalculatorProto.InputStreamInfo parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.mediapipe.proto.CalculatorProto.InputStreamInfo parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.mediapipe.proto.CalculatorProto.InputStreamInfo parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static com.google.mediapipe.proto.CalculatorProto.InputStreamInfo parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.google.mediapipe.proto.CalculatorProto.InputStreamInfo parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static com.google.mediapipe.proto.CalculatorProto.InputStreamInfo parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.google.mediapipe.proto.CalculatorProto.InputStreamInfo parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static com.google.mediapipe.proto.CalculatorProto.InputStreamInfo parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.google.mediapipe.proto.CalculatorProto.InputStreamInfo prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Additional information about an input stream.
     * </pre>
     *
     * Protobuf type {@code mediapipe.InputStreamInfo}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:mediapipe.InputStreamInfo)
        com.google.mediapipe.proto.CalculatorProto.InputStreamInfoOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.google.mediapipe.proto.CalculatorProto.internal_static_mediapipe_InputStreamInfo_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.google.mediapipe.proto.CalculatorProto.internal_static_mediapipe_InputStreamInfo_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.google.mediapipe.proto.CalculatorProto.InputStreamInfo.class, com.google.mediapipe.proto.CalculatorProto.InputStreamInfo.Builder.class);
      }

      // Construct using com.google.mediapipe.proto.CalculatorProto.InputStreamInfo.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        tagIndex_ = "";

        backEdge_ = false;

        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.google.mediapipe.proto.CalculatorProto.internal_static_mediapipe_InputStreamInfo_descriptor;
      }

      public com.google.mediapipe.proto.CalculatorProto.InputStreamInfo getDefaultInstanceForType() {
        return com.google.mediapipe.proto.CalculatorProto.InputStreamInfo.getDefaultInstance();
      }

      public com.google.mediapipe.proto.CalculatorProto.InputStreamInfo build() {
        com.google.mediapipe.proto.CalculatorProto.InputStreamInfo result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public com.google.mediapipe.proto.CalculatorProto.InputStreamInfo buildPartial() {
        com.google.mediapipe.proto.CalculatorProto.InputStreamInfo result = new com.google.mediapipe.proto.CalculatorProto.InputStreamInfo(this);
        result.tagIndex_ = tagIndex_;
        result.backEdge_ = backEdge_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.google.mediapipe.proto.CalculatorProto.InputStreamInfo) {
          return mergeFrom((com.google.mediapipe.proto.CalculatorProto.InputStreamInfo)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.google.mediapipe.proto.CalculatorProto.InputStreamInfo other) {
        if (other == com.google.mediapipe.proto.CalculatorProto.InputStreamInfo.getDefaultInstance()) return this;
        if (!other.getTagIndex().isEmpty()) {
          tagIndex_ = other.tagIndex_;
          onChanged();
        }
        if (other.getBackEdge() != false) {
          setBackEdge(other.getBackEdge());
        }
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        com.google.mediapipe.proto.CalculatorProto.InputStreamInfo parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (com.google.mediapipe.proto.CalculatorProto.InputStreamInfo) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private java.lang.Object tagIndex_ = "";
      /**
       * <pre>
       * A description of the input stream.
       * This description uses the Calculator visible specification of
       * a stream.  The format is a tag, then an index with both being
       * optional.  If the tag is missing it is assumed to be "" and if
       * the index is missing then it is assumed to be 0.  If the index
       * is provided then a colon (':') must be used.
       * Examples:
       *   "TAG"     -&gt; tag "TAG",   index 0
       *   ""        -&gt; tag "",      index 0
       *   ":0"      -&gt; tag "",      index 0
       *   ":3"      -&gt; tag "",      index 3
       *   "VIDEO:0" -&gt; tag "VIDEO", index 0
       *   "VIDEO:2" -&gt; tag "VIDEO", index 2
       * </pre>
       *
       * <code>optional string tag_index = 1;</code>
       */
      public java.lang.String getTagIndex() {
        java.lang.Object ref = tagIndex_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          tagIndex_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * A description of the input stream.
       * This description uses the Calculator visible specification of
       * a stream.  The format is a tag, then an index with both being
       * optional.  If the tag is missing it is assumed to be "" and if
       * the index is missing then it is assumed to be 0.  If the index
       * is provided then a colon (':') must be used.
       * Examples:
       *   "TAG"     -&gt; tag "TAG",   index 0
       *   ""        -&gt; tag "",      index 0
       *   ":0"      -&gt; tag "",      index 0
       *   ":3"      -&gt; tag "",      index 3
       *   "VIDEO:0" -&gt; tag "VIDEO", index 0
       *   "VIDEO:2" -&gt; tag "VIDEO", index 2
       * </pre>
       *
       * <code>optional string tag_index = 1;</code>
       */
      public com.google.protobuf.ByteString
          getTagIndexBytes() {
        java.lang.Object ref = tagIndex_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          tagIndex_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * A description of the input stream.
       * This description uses the Calculator visible specification of
       * a stream.  The format is a tag, then an index with both being
       * optional.  If the tag is missing it is assumed to be "" and if
       * the index is missing then it is assumed to be 0.  If the index
       * is provided then a colon (':') must be used.
       * Examples:
       *   "TAG"     -&gt; tag "TAG",   index 0
       *   ""        -&gt; tag "",      index 0
       *   ":0"      -&gt; tag "",      index 0
       *   ":3"      -&gt; tag "",      index 3
       *   "VIDEO:0" -&gt; tag "VIDEO", index 0
       *   "VIDEO:2" -&gt; tag "VIDEO", index 2
       * </pre>
       *
       * <code>optional string tag_index = 1;</code>
       */
      public Builder setTagIndex(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        tagIndex_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A description of the input stream.
       * This description uses the Calculator visible specification of
       * a stream.  The format is a tag, then an index with both being
       * optional.  If the tag is missing it is assumed to be "" and if
       * the index is missing then it is assumed to be 0.  If the index
       * is provided then a colon (':') must be used.
       * Examples:
       *   "TAG"     -&gt; tag "TAG",   index 0
       *   ""        -&gt; tag "",      index 0
       *   ":0"      -&gt; tag "",      index 0
       *   ":3"      -&gt; tag "",      index 3
       *   "VIDEO:0" -&gt; tag "VIDEO", index 0
       *   "VIDEO:2" -&gt; tag "VIDEO", index 2
       * </pre>
       *
       * <code>optional string tag_index = 1;</code>
       */
      public Builder clearTagIndex() {
        
        tagIndex_ = getDefaultInstance().getTagIndex();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A description of the input stream.
       * This description uses the Calculator visible specification of
       * a stream.  The format is a tag, then an index with both being
       * optional.  If the tag is missing it is assumed to be "" and if
       * the index is missing then it is assumed to be 0.  If the index
       * is provided then a colon (':') must be used.
       * Examples:
       *   "TAG"     -&gt; tag "TAG",   index 0
       *   ""        -&gt; tag "",      index 0
       *   ":0"      -&gt; tag "",      index 0
       *   ":3"      -&gt; tag "",      index 3
       *   "VIDEO:0" -&gt; tag "VIDEO", index 0
       *   "VIDEO:2" -&gt; tag "VIDEO", index 2
       * </pre>
       *
       * <code>optional string tag_index = 1;</code>
       */
      public Builder setTagIndexBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        tagIndex_ = value;
        onChanged();
        return this;
      }

      private boolean backEdge_ ;
      /**
       * <pre>
       * Whether the input stream is a back edge.
       * By default, MediaPipe requires graphs to be acyclic and treats cycles in a
       * graph as errors. To allow MediaPipe to accept a cyclic graph, set the
       * back_edge fields of the input streams that are back edges to true. A
       * cyclic graph usually has an obvious forward direction, and a back edge
       * goes in the opposite direction. For a formal definition of a back edge,
       * please see https://en.wikipedia.org/wiki/Depth-first_search.
       * </pre>
       *
       * <code>optional bool back_edge = 2;</code>
       */
      public boolean getBackEdge() {
        return backEdge_;
      }
      /**
       * <pre>
       * Whether the input stream is a back edge.
       * By default, MediaPipe requires graphs to be acyclic and treats cycles in a
       * graph as errors. To allow MediaPipe to accept a cyclic graph, set the
       * back_edge fields of the input streams that are back edges to true. A
       * cyclic graph usually has an obvious forward direction, and a back edge
       * goes in the opposite direction. For a formal definition of a back edge,
       * please see https://en.wikipedia.org/wiki/Depth-first_search.
       * </pre>
       *
       * <code>optional bool back_edge = 2;</code>
       */
      public Builder setBackEdge(boolean value) {
        
        backEdge_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether the input stream is a back edge.
       * By default, MediaPipe requires graphs to be acyclic and treats cycles in a
       * graph as errors. To allow MediaPipe to accept a cyclic graph, set the
       * back_edge fields of the input streams that are back edges to true. A
       * cyclic graph usually has an obvious forward direction, and a back edge
       * goes in the opposite direction. For a formal definition of a back edge,
       * please see https://en.wikipedia.org/wiki/Depth-first_search.
       * </pre>
       *
       * <code>optional bool back_edge = 2;</code>
       */
      public Builder clearBackEdge() {
        
        backEdge_ = false;
        onChanged();
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return this;
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return this;
      }


      // @@protoc_insertion_point(builder_scope:mediapipe.InputStreamInfo)
    }

    // @@protoc_insertion_point(class_scope:mediapipe.InputStreamInfo)
    private static final com.google.mediapipe.proto.CalculatorProto.InputStreamInfo DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.google.mediapipe.proto.CalculatorProto.InputStreamInfo();
    }

    public static com.google.mediapipe.proto.CalculatorProto.InputStreamInfo getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<InputStreamInfo>
        PARSER = new com.google.protobuf.AbstractParser<InputStreamInfo>() {
      public InputStreamInfo parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
          return new InputStreamInfo(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<InputStreamInfo> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<InputStreamInfo> getParserForType() {
      return PARSER;
    }

    public com.google.mediapipe.proto.CalculatorProto.InputStreamInfo getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ProfilerConfigOrBuilder extends
      // @@protoc_insertion_point(interface_extends:mediapipe.ProfilerConfig)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Size of the runtimes histogram intervals (in microseconds) to generate the
     * histogram of the Process() time. The last interval extends to +inf.
     * If not specified, the interval is 1000000 usec = 1 sec.
     * </pre>
     *
     * <code>optional int64 histogram_interval_size_usec = 1;</code>
     */
    long getHistogramIntervalSizeUsec();

    /**
     * <pre>
     * Number of intervals to generate the histogram of the Process() runtime.
     * If not specified, one interval is used.
     * </pre>
     *
     * <code>optional int64 num_histogram_intervals = 2;</code>
     */
    long getNumHistogramIntervals();

    /**
     * <pre>
     * TODO: clean up after migration to MediaPipeProfiler.
     * DEPRECATED: If true, the profiler also profiles the input output latency.
     * Should be true only if the packet timestamps corresponds to the
     * microseconds wall time from epoch.
     * </pre>
     *
     * <code>optional bool enable_input_output_latency = 3 [deprecated = true];</code>
     */
    @java.lang.Deprecated boolean getEnableInputOutputLatency();

    /**
     * <pre>
     * If true, the profiler starts profiling when graph is initialized.
     * </pre>
     *
     * <code>optional bool enable_profiler = 4;</code>
     */
    boolean getEnableProfiler();

    /**
     * <pre>
     * If true, the profiler also profiles the stream latency and input-output
     * latency.
     * No-op if enable_profiler is false.
     * </pre>
     *
     * <code>optional bool enable_stream_latency = 5;</code>
     */
    boolean getEnableStreamLatency();

    /**
     * <pre>
     * If true, the profiler uses packet timestamp (as production time and source
     * production time) for packets added by calling
     * CalculatorGraph::AddPacketToInputStream().
     * If false, uses profiler's clock.
     * </pre>
     *
     * <code>optional bool use_packet_timestamp_for_added_packet = 6;</code>
     */
    boolean getUsePacketTimestampForAddedPacket();

    /**
     * <pre>
     * The maximum number of trace events buffered in memory.
     * The default value buffers up to 20000 events.
     * </pre>
     *
     * <code>optional int64 trace_log_capacity = 7;</code>
     */
    long getTraceLogCapacity();

    /**
     * <pre>
     * Trace event types that are not logged.
     * </pre>
     *
     * <code>repeated int32 trace_event_types_disabled = 8;</code>
     */
    java.util.List<java.lang.Integer> getTraceEventTypesDisabledList();
    /**
     * <pre>
     * Trace event types that are not logged.
     * </pre>
     *
     * <code>repeated int32 trace_event_types_disabled = 8;</code>
     */
    int getTraceEventTypesDisabledCount();
    /**
     * <pre>
     * Trace event types that are not logged.
     * </pre>
     *
     * <code>repeated int32 trace_event_types_disabled = 8;</code>
     */
    int getTraceEventTypesDisabled(int index);

    /**
     * <pre>
     * The output directory and base-name prefix for trace log files.
     * Log files are written to: StrCat(trace_log_path, index, ".binarypb")
     * </pre>
     *
     * <code>optional string trace_log_path = 9;</code>
     */
    java.lang.String getTraceLogPath();
    /**
     * <pre>
     * The output directory and base-name prefix for trace log files.
     * Log files are written to: StrCat(trace_log_path, index, ".binarypb")
     * </pre>
     *
     * <code>optional string trace_log_path = 9;</code>
     */
    com.google.protobuf.ByteString
        getTraceLogPathBytes();

    /**
     * <pre>
     * The number of trace log files retained.
     * The trace log files are named "trace_0.log" through "trace_k.log".
     * The default value specifies 2 output files retained.
     * </pre>
     *
     * <code>optional int32 trace_log_count = 10;</code>
     */
    int getTraceLogCount();

    /**
     * <pre>
     * The interval in microseconds between trace log output.
     * The default value specifies trace log output once every 0.5 sec.
     * </pre>
     *
     * <code>optional int64 trace_log_interval_usec = 11;</code>
     */
    long getTraceLogIntervalUsec();

    /**
     * <pre>
     * The interval in microseconds between TimeNow and the highest times
     * included in trace log output.  This margin allows time for events
     * to be appended to the TraceBuffer.
     * </pre>
     *
     * <code>optional int64 trace_log_margin_usec = 12;</code>
     */
    long getTraceLogMarginUsec();

    /**
     * <pre>
     * False specifies an event for each calculator invocation.
     * True specifies a separate event for each start and finish time.
     * </pre>
     *
     * <code>optional bool trace_log_duration_events = 13;</code>
     */
    boolean getTraceLogDurationEvents();

    /**
     * <pre>
     * The number of trace log intervals per file. The total log duration is:
     * trace_log_interval_usec * trace_log_file_count * trace_log_interval_count.
     * The default value specifies 10 intervals per file.
     * </pre>
     *
     * <code>optional int32 trace_log_interval_count = 14;</code>
     */
    int getTraceLogIntervalCount();

    /**
     * <pre>
     * An option to turn ON/OFF writing trace files to disk. Saving trace files to
     * disk is enabled by default.
     * </pre>
     *
     * <code>optional bool trace_log_disabled = 15;</code>
     */
    boolean getTraceLogDisabled();

    /**
     * <pre>
     * If true, tracer timing events are recorded and reported.
     * </pre>
     *
     * <code>optional bool trace_enabled = 16;</code>
     */
    boolean getTraceEnabled();
  }
  /**
   * <pre>
   * Configs for the profiler for a calculator. Not applicable to subgraphs.
   * </pre>
   *
   * Protobuf type {@code mediapipe.ProfilerConfig}
   */
  public  static final class ProfilerConfig extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:mediapipe.ProfilerConfig)
      ProfilerConfigOrBuilder {
    // Use ProfilerConfig.newBuilder() to construct.
    private ProfilerConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ProfilerConfig() {
      histogramIntervalSizeUsec_ = 0L;
      numHistogramIntervals_ = 0L;
      enableInputOutputLatency_ = false;
      enableProfiler_ = false;
      enableStreamLatency_ = false;
      usePacketTimestampForAddedPacket_ = false;
      traceLogCapacity_ = 0L;
      traceEventTypesDisabled_ = java.util.Collections.emptyList();
      traceLogPath_ = "";
      traceLogCount_ = 0;
      traceLogIntervalUsec_ = 0L;
      traceLogMarginUsec_ = 0L;
      traceLogDurationEvents_ = false;
      traceLogIntervalCount_ = 0;
      traceLogDisabled_ = false;
      traceEnabled_ = false;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return com.google.protobuf.UnknownFieldSet.getDefaultInstance();
    }
    private ProfilerConfig(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      int mutable_bitField0_ = 0;
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!input.skipField(tag)) {
                done = true;
              }
              break;
            }
            case 8: {

              histogramIntervalSizeUsec_ = input.readInt64();
              break;
            }
            case 16: {

              numHistogramIntervals_ = input.readInt64();
              break;
            }
            case 24: {

              enableInputOutputLatency_ = input.readBool();
              break;
            }
            case 32: {

              enableProfiler_ = input.readBool();
              break;
            }
            case 40: {

              enableStreamLatency_ = input.readBool();
              break;
            }
            case 48: {

              usePacketTimestampForAddedPacket_ = input.readBool();
              break;
            }
            case 56: {

              traceLogCapacity_ = input.readInt64();
              break;
            }
            case 64: {
              if (!((mutable_bitField0_ & 0x00000080) == 0x00000080)) {
                traceEventTypesDisabled_ = new java.util.ArrayList<java.lang.Integer>();
                mutable_bitField0_ |= 0x00000080;
              }
              traceEventTypesDisabled_.add(input.readInt32());
              break;
            }
            case 66: {
              int length = input.readRawVarint32();
              int limit = input.pushLimit(length);
              if (!((mutable_bitField0_ & 0x00000080) == 0x00000080) && input.getBytesUntilLimit() > 0) {
                traceEventTypesDisabled_ = new java.util.ArrayList<java.lang.Integer>();
                mutable_bitField0_ |= 0x00000080;
              }
              while (input.getBytesUntilLimit() > 0) {
                traceEventTypesDisabled_.add(input.readInt32());
              }
              input.popLimit(limit);
              break;
            }
            case 74: {
              java.lang.String s = input.readStringRequireUtf8();

              traceLogPath_ = s;
              break;
            }
            case 80: {

              traceLogCount_ = input.readInt32();
              break;
            }
            case 88: {

              traceLogIntervalUsec_ = input.readInt64();
              break;
            }
            case 96: {

              traceLogMarginUsec_ = input.readInt64();
              break;
            }
            case 104: {

              traceLogDurationEvents_ = input.readBool();
              break;
            }
            case 112: {

              traceLogIntervalCount_ = input.readInt32();
              break;
            }
            case 120: {

              traceLogDisabled_ = input.readBool();
              break;
            }
            case 128: {

              traceEnabled_ = input.readBool();
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000080) == 0x00000080)) {
          traceEventTypesDisabled_ = java.util.Collections.unmodifiableList(traceEventTypesDisabled_);
        }
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.google.mediapipe.proto.CalculatorProto.internal_static_mediapipe_ProfilerConfig_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.google.mediapipe.proto.CalculatorProto.internal_static_mediapipe_ProfilerConfig_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.google.mediapipe.proto.CalculatorProto.ProfilerConfig.class, com.google.mediapipe.proto.CalculatorProto.ProfilerConfig.Builder.class);
    }

    private int bitField0_;
    public static final int HISTOGRAM_INTERVAL_SIZE_USEC_FIELD_NUMBER = 1;
    private long histogramIntervalSizeUsec_;
    /**
     * <pre>
     * Size of the runtimes histogram intervals (in microseconds) to generate the
     * histogram of the Process() time. The last interval extends to +inf.
     * If not specified, the interval is 1000000 usec = 1 sec.
     * </pre>
     *
     * <code>optional int64 histogram_interval_size_usec = 1;</code>
     */
    public long getHistogramIntervalSizeUsec() {
      return histogramIntervalSizeUsec_;
    }

    public static final int NUM_HISTOGRAM_INTERVALS_FIELD_NUMBER = 2;
    private long numHistogramIntervals_;
    /**
     * <pre>
     * Number of intervals to generate the histogram of the Process() runtime.
     * If not specified, one interval is used.
     * </pre>
     *
     * <code>optional int64 num_histogram_intervals = 2;</code>
     */
    public long getNumHistogramIntervals() {
      return numHistogramIntervals_;
    }

    public static final int ENABLE_INPUT_OUTPUT_LATENCY_FIELD_NUMBER = 3;
    private boolean enableInputOutputLatency_;
    /**
     * <pre>
     * TODO: clean up after migration to MediaPipeProfiler.
     * DEPRECATED: If true, the profiler also profiles the input output latency.
     * Should be true only if the packet timestamps corresponds to the
     * microseconds wall time from epoch.
     * </pre>
     *
     * <code>optional bool enable_input_output_latency = 3 [deprecated = true];</code>
     */
    @java.lang.Deprecated public boolean getEnableInputOutputLatency() {
      return enableInputOutputLatency_;
    }

    public static final int ENABLE_PROFILER_FIELD_NUMBER = 4;
    private boolean enableProfiler_;
    /**
     * <pre>
     * If true, the profiler starts profiling when graph is initialized.
     * </pre>
     *
     * <code>optional bool enable_profiler = 4;</code>
     */
    public boolean getEnableProfiler() {
      return enableProfiler_;
    }

    public static final int ENABLE_STREAM_LATENCY_FIELD_NUMBER = 5;
    private boolean enableStreamLatency_;
    /**
     * <pre>
     * If true, the profiler also profiles the stream latency and input-output
     * latency.
     * No-op if enable_profiler is false.
     * </pre>
     *
     * <code>optional bool enable_stream_latency = 5;</code>
     */
    public boolean getEnableStreamLatency() {
      return enableStreamLatency_;
    }

    public static final int USE_PACKET_TIMESTAMP_FOR_ADDED_PACKET_FIELD_NUMBER = 6;
    private boolean usePacketTimestampForAddedPacket_;
    /**
     * <pre>
     * If true, the profiler uses packet timestamp (as production time and source
     * production time) for packets added by calling
     * CalculatorGraph::AddPacketToInputStream().
     * If false, uses profiler's clock.
     * </pre>
     *
     * <code>optional bool use_packet_timestamp_for_added_packet = 6;</code>
     */
    public boolean getUsePacketTimestampForAddedPacket() {
      return usePacketTimestampForAddedPacket_;
    }

    public static final int TRACE_LOG_CAPACITY_FIELD_NUMBER = 7;
    private long traceLogCapacity_;
    /**
     * <pre>
     * The maximum number of trace events buffered in memory.
     * The default value buffers up to 20000 events.
     * </pre>
     *
     * <code>optional int64 trace_log_capacity = 7;</code>
     */
    public long getTraceLogCapacity() {
      return traceLogCapacity_;
    }

    public static final int TRACE_EVENT_TYPES_DISABLED_FIELD_NUMBER = 8;
    private java.util.List<java.lang.Integer> traceEventTypesDisabled_;
    /**
     * <pre>
     * Trace event types that are not logged.
     * </pre>
     *
     * <code>repeated int32 trace_event_types_disabled = 8;</code>
     */
    public java.util.List<java.lang.Integer>
        getTraceEventTypesDisabledList() {
      return traceEventTypesDisabled_;
    }
    /**
     * <pre>
     * Trace event types that are not logged.
     * </pre>
     *
     * <code>repeated int32 trace_event_types_disabled = 8;</code>
     */
    public int getTraceEventTypesDisabledCount() {
      return traceEventTypesDisabled_.size();
    }
    /**
     * <pre>
     * Trace event types that are not logged.
     * </pre>
     *
     * <code>repeated int32 trace_event_types_disabled = 8;</code>
     */
    public int getTraceEventTypesDisabled(int index) {
      return traceEventTypesDisabled_.get(index);
    }
    private int traceEventTypesDisabledMemoizedSerializedSize = -1;

    public static final int TRACE_LOG_PATH_FIELD_NUMBER = 9;
    private volatile java.lang.Object traceLogPath_;
    /**
     * <pre>
     * The output directory and base-name prefix for trace log files.
     * Log files are written to: StrCat(trace_log_path, index, ".binarypb")
     * </pre>
     *
     * <code>optional string trace_log_path = 9;</code>
     */
    public java.lang.String getTraceLogPath() {
      java.lang.Object ref = traceLogPath_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        traceLogPath_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The output directory and base-name prefix for trace log files.
     * Log files are written to: StrCat(trace_log_path, index, ".binarypb")
     * </pre>
     *
     * <code>optional string trace_log_path = 9;</code>
     */
    public com.google.protobuf.ByteString
        getTraceLogPathBytes() {
      java.lang.Object ref = traceLogPath_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        traceLogPath_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int TRACE_LOG_COUNT_FIELD_NUMBER = 10;
    private int traceLogCount_;
    /**
     * <pre>
     * The number of trace log files retained.
     * The trace log files are named "trace_0.log" through "trace_k.log".
     * The default value specifies 2 output files retained.
     * </pre>
     *
     * <code>optional int32 trace_log_count = 10;</code>
     */
    public int getTraceLogCount() {
      return traceLogCount_;
    }

    public static final int TRACE_LOG_INTERVAL_USEC_FIELD_NUMBER = 11;
    private long traceLogIntervalUsec_;
    /**
     * <pre>
     * The interval in microseconds between trace log output.
     * The default value specifies trace log output once every 0.5 sec.
     * </pre>
     *
     * <code>optional int64 trace_log_interval_usec = 11;</code>
     */
    public long getTraceLogIntervalUsec() {
      return traceLogIntervalUsec_;
    }

    public static final int TRACE_LOG_MARGIN_USEC_FIELD_NUMBER = 12;
    private long traceLogMarginUsec_;
    /**
     * <pre>
     * The interval in microseconds between TimeNow and the highest times
     * included in trace log output.  This margin allows time for events
     * to be appended to the TraceBuffer.
     * </pre>
     *
     * <code>optional int64 trace_log_margin_usec = 12;</code>
     */
    public long getTraceLogMarginUsec() {
      return traceLogMarginUsec_;
    }

    public static final int TRACE_LOG_DURATION_EVENTS_FIELD_NUMBER = 13;
    private boolean traceLogDurationEvents_;
    /**
     * <pre>
     * False specifies an event for each calculator invocation.
     * True specifies a separate event for each start and finish time.
     * </pre>
     *
     * <code>optional bool trace_log_duration_events = 13;</code>
     */
    public boolean getTraceLogDurationEvents() {
      return traceLogDurationEvents_;
    }

    public static final int TRACE_LOG_INTERVAL_COUNT_FIELD_NUMBER = 14;
    private int traceLogIntervalCount_;
    /**
     * <pre>
     * The number of trace log intervals per file. The total log duration is:
     * trace_log_interval_usec * trace_log_file_count * trace_log_interval_count.
     * The default value specifies 10 intervals per file.
     * </pre>
     *
     * <code>optional int32 trace_log_interval_count = 14;</code>
     */
    public int getTraceLogIntervalCount() {
      return traceLogIntervalCount_;
    }

    public static final int TRACE_LOG_DISABLED_FIELD_NUMBER = 15;
    private boolean traceLogDisabled_;
    /**
     * <pre>
     * An option to turn ON/OFF writing trace files to disk. Saving trace files to
     * disk is enabled by default.
     * </pre>
     *
     * <code>optional bool trace_log_disabled = 15;</code>
     */
    public boolean getTraceLogDisabled() {
      return traceLogDisabled_;
    }

    public static final int TRACE_ENABLED_FIELD_NUMBER = 16;
    private boolean traceEnabled_;
    /**
     * <pre>
     * If true, tracer timing events are recorded and reported.
     * </pre>
     *
     * <code>optional bool trace_enabled = 16;</code>
     */
    public boolean getTraceEnabled() {
      return traceEnabled_;
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      getSerializedSize();
      if (histogramIntervalSizeUsec_ != 0L) {
        output.writeInt64(1, histogramIntervalSizeUsec_);
      }
      if (numHistogramIntervals_ != 0L) {
        output.writeInt64(2, numHistogramIntervals_);
      }
      if (enableInputOutputLatency_ != false) {
        output.writeBool(3, enableInputOutputLatency_);
      }
      if (enableProfiler_ != false) {
        output.writeBool(4, enableProfiler_);
      }
      if (enableStreamLatency_ != false) {
        output.writeBool(5, enableStreamLatency_);
      }
      if (usePacketTimestampForAddedPacket_ != false) {
        output.writeBool(6, usePacketTimestampForAddedPacket_);
      }
      if (traceLogCapacity_ != 0L) {
        output.writeInt64(7, traceLogCapacity_);
      }
      if (getTraceEventTypesDisabledList().size() > 0) {
        output.writeUInt32NoTag(66);
        output.writeUInt32NoTag(traceEventTypesDisabledMemoizedSerializedSize);
      }
      for (int i = 0; i < traceEventTypesDisabled_.size(); i++) {
        output.writeInt32NoTag(traceEventTypesDisabled_.get(i));
      }
      if (!getTraceLogPathBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 9, traceLogPath_);
      }
      if (traceLogCount_ != 0) {
        output.writeInt32(10, traceLogCount_);
      }
      if (traceLogIntervalUsec_ != 0L) {
        output.writeInt64(11, traceLogIntervalUsec_);
      }
      if (traceLogMarginUsec_ != 0L) {
        output.writeInt64(12, traceLogMarginUsec_);
      }
      if (traceLogDurationEvents_ != false) {
        output.writeBool(13, traceLogDurationEvents_);
      }
      if (traceLogIntervalCount_ != 0) {
        output.writeInt32(14, traceLogIntervalCount_);
      }
      if (traceLogDisabled_ != false) {
        output.writeBool(15, traceLogDisabled_);
      }
      if (traceEnabled_ != false) {
        output.writeBool(16, traceEnabled_);
      }
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (histogramIntervalSizeUsec_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(1, histogramIntervalSizeUsec_);
      }
      if (numHistogramIntervals_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(2, numHistogramIntervals_);
      }
      if (enableInputOutputLatency_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(3, enableInputOutputLatency_);
      }
      if (enableProfiler_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(4, enableProfiler_);
      }
      if (enableStreamLatency_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(5, enableStreamLatency_);
      }
      if (usePacketTimestampForAddedPacket_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(6, usePacketTimestampForAddedPacket_);
      }
      if (traceLogCapacity_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(7, traceLogCapacity_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < traceEventTypesDisabled_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeInt32SizeNoTag(traceEventTypesDisabled_.get(i));
        }
        size += dataSize;
        if (!getTraceEventTypesDisabledList().isEmpty()) {
          size += 1;
          size += com.google.protobuf.CodedOutputStream
              .computeInt32SizeNoTag(dataSize);
        }
        traceEventTypesDisabledMemoizedSerializedSize = dataSize;
      }
      if (!getTraceLogPathBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(9, traceLogPath_);
      }
      if (traceLogCount_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(10, traceLogCount_);
      }
      if (traceLogIntervalUsec_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(11, traceLogIntervalUsec_);
      }
      if (traceLogMarginUsec_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(12, traceLogMarginUsec_);
      }
      if (traceLogDurationEvents_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(13, traceLogDurationEvents_);
      }
      if (traceLogIntervalCount_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(14, traceLogIntervalCount_);
      }
      if (traceLogDisabled_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(15, traceLogDisabled_);
      }
      if (traceEnabled_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(16, traceEnabled_);
      }
      memoizedSize = size;
      return size;
    }

    private static final long serialVersionUID = 0L;
    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.google.mediapipe.proto.CalculatorProto.ProfilerConfig)) {
        return super.equals(obj);
      }
      com.google.mediapipe.proto.CalculatorProto.ProfilerConfig other = (com.google.mediapipe.proto.CalculatorProto.ProfilerConfig) obj;

      boolean result = true;
      result = result && (getHistogramIntervalSizeUsec()
          == other.getHistogramIntervalSizeUsec());
      result = result && (getNumHistogramIntervals()
          == other.getNumHistogramIntervals());
      result = result && (getEnableInputOutputLatency()
          == other.getEnableInputOutputLatency());
      result = result && (getEnableProfiler()
          == other.getEnableProfiler());
      result = result && (getEnableStreamLatency()
          == other.getEnableStreamLatency());
      result = result && (getUsePacketTimestampForAddedPacket()
          == other.getUsePacketTimestampForAddedPacket());
      result = result && (getTraceLogCapacity()
          == other.getTraceLogCapacity());
      result = result && getTraceEventTypesDisabledList()
          .equals(other.getTraceEventTypesDisabledList());
      result = result && getTraceLogPath()
          .equals(other.getTraceLogPath());
      result = result && (getTraceLogCount()
          == other.getTraceLogCount());
      result = result && (getTraceLogIntervalUsec()
          == other.getTraceLogIntervalUsec());
      result = result && (getTraceLogMarginUsec()
          == other.getTraceLogMarginUsec());
      result = result && (getTraceLogDurationEvents()
          == other.getTraceLogDurationEvents());
      result = result && (getTraceLogIntervalCount()
          == other.getTraceLogIntervalCount());
      result = result && (getTraceLogDisabled()
          == other.getTraceLogDisabled());
      result = result && (getTraceEnabled()
          == other.getTraceEnabled());
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptorForType().hashCode();
      hash = (37 * hash) + HISTOGRAM_INTERVAL_SIZE_USEC_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getHistogramIntervalSizeUsec());
      hash = (37 * hash) + NUM_HISTOGRAM_INTERVALS_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getNumHistogramIntervals());
      hash = (37 * hash) + ENABLE_INPUT_OUTPUT_LATENCY_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getEnableInputOutputLatency());
      hash = (37 * hash) + ENABLE_PROFILER_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getEnableProfiler());
      hash = (37 * hash) + ENABLE_STREAM_LATENCY_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getEnableStreamLatency());
      hash = (37 * hash) + USE_PACKET_TIMESTAMP_FOR_ADDED_PACKET_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getUsePacketTimestampForAddedPacket());
      hash = (37 * hash) + TRACE_LOG_CAPACITY_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getTraceLogCapacity());
      if (getTraceEventTypesDisabledCount() > 0) {
        hash = (37 * hash) + TRACE_EVENT_TYPES_DISABLED_FIELD_NUMBER;
        hash = (53 * hash) + getTraceEventTypesDisabledList().hashCode();
      }
      hash = (37 * hash) + TRACE_LOG_PATH_FIELD_NUMBER;
      hash = (53 * hash) + getTraceLogPath().hashCode();
      hash = (37 * hash) + TRACE_LOG_COUNT_FIELD_NUMBER;
      hash = (53 * hash) + getTraceLogCount();
      hash = (37 * hash) + TRACE_LOG_INTERVAL_USEC_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getTraceLogIntervalUsec());
      hash = (37 * hash) + TRACE_LOG_MARGIN_USEC_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getTraceLogMarginUsec());
      hash = (37 * hash) + TRACE_LOG_DURATION_EVENTS_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getTraceLogDurationEvents());
      hash = (37 * hash) + TRACE_LOG_INTERVAL_COUNT_FIELD_NUMBER;
      hash = (53 * hash) + getTraceLogIntervalCount();
      hash = (37 * hash) + TRACE_LOG_DISABLED_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getTraceLogDisabled());
      hash = (37 * hash) + TRACE_ENABLED_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getTraceEnabled());
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.google.mediapipe.proto.CalculatorProto.ProfilerConfig parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.mediapipe.proto.CalculatorProto.ProfilerConfig parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.mediapipe.proto.CalculatorProto.ProfilerConfig parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.mediapipe.proto.CalculatorProto.ProfilerConfig parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.mediapipe.proto.CalculatorProto.ProfilerConfig parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static com.google.mediapipe.proto.CalculatorProto.ProfilerConfig parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.google.mediapipe.proto.CalculatorProto.ProfilerConfig parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static com.google.mediapipe.proto.CalculatorProto.ProfilerConfig parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.google.mediapipe.proto.CalculatorProto.ProfilerConfig parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static com.google.mediapipe.proto.CalculatorProto.ProfilerConfig parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.google.mediapipe.proto.CalculatorProto.ProfilerConfig prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Configs for the profiler for a calculator. Not applicable to subgraphs.
     * </pre>
     *
     * Protobuf type {@code mediapipe.ProfilerConfig}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:mediapipe.ProfilerConfig)
        com.google.mediapipe.proto.CalculatorProto.ProfilerConfigOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.google.mediapipe.proto.CalculatorProto.internal_static_mediapipe_ProfilerConfig_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.google.mediapipe.proto.CalculatorProto.internal_static_mediapipe_ProfilerConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.google.mediapipe.proto.CalculatorProto.ProfilerConfig.class, com.google.mediapipe.proto.CalculatorProto.ProfilerConfig.Builder.class);
      }

      // Construct using com.google.mediapipe.proto.CalculatorProto.ProfilerConfig.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        histogramIntervalSizeUsec_ = 0L;

        numHistogramIntervals_ = 0L;

        enableInputOutputLatency_ = false;

        enableProfiler_ = false;

        enableStreamLatency_ = false;

        usePacketTimestampForAddedPacket_ = false;

        traceLogCapacity_ = 0L;

        traceEventTypesDisabled_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000080);
        traceLogPath_ = "";

        traceLogCount_ = 0;

        traceLogIntervalUsec_ = 0L;

        traceLogMarginUsec_ = 0L;

        traceLogDurationEvents_ = false;

        traceLogIntervalCount_ = 0;

        traceLogDisabled_ = false;

        traceEnabled_ = false;

        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.google.mediapipe.proto.CalculatorProto.internal_static_mediapipe_ProfilerConfig_descriptor;
      }

      public com.google.mediapipe.proto.CalculatorProto.ProfilerConfig getDefaultInstanceForType() {
        return com.google.mediapipe.proto.CalculatorProto.ProfilerConfig.getDefaultInstance();
      }

      public com.google.mediapipe.proto.CalculatorProto.ProfilerConfig build() {
        com.google.mediapipe.proto.CalculatorProto.ProfilerConfig result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public com.google.mediapipe.proto.CalculatorProto.ProfilerConfig buildPartial() {
        com.google.mediapipe.proto.CalculatorProto.ProfilerConfig result = new com.google.mediapipe.proto.CalculatorProto.ProfilerConfig(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        result.histogramIntervalSizeUsec_ = histogramIntervalSizeUsec_;
        result.numHistogramIntervals_ = numHistogramIntervals_;
        result.enableInputOutputLatency_ = enableInputOutputLatency_;
        result.enableProfiler_ = enableProfiler_;
        result.enableStreamLatency_ = enableStreamLatency_;
        result.usePacketTimestampForAddedPacket_ = usePacketTimestampForAddedPacket_;
        result.traceLogCapacity_ = traceLogCapacity_;
        if (((bitField0_ & 0x00000080) == 0x00000080)) {
          traceEventTypesDisabled_ = java.util.Collections.unmodifiableList(traceEventTypesDisabled_);
          bitField0_ = (bitField0_ & ~0x00000080);
        }
        result.traceEventTypesDisabled_ = traceEventTypesDisabled_;
        result.traceLogPath_ = traceLogPath_;
        result.traceLogCount_ = traceLogCount_;
        result.traceLogIntervalUsec_ = traceLogIntervalUsec_;
        result.traceLogMarginUsec_ = traceLogMarginUsec_;
        result.traceLogDurationEvents_ = traceLogDurationEvents_;
        result.traceLogIntervalCount_ = traceLogIntervalCount_;
        result.traceLogDisabled_ = traceLogDisabled_;
        result.traceEnabled_ = traceEnabled_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.google.mediapipe.proto.CalculatorProto.ProfilerConfig) {
          return mergeFrom((com.google.mediapipe.proto.CalculatorProto.ProfilerConfig)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.google.mediapipe.proto.CalculatorProto.ProfilerConfig other) {
        if (other == com.google.mediapipe.proto.CalculatorProto.ProfilerConfig.getDefaultInstance()) return this;
        if (other.getHistogramIntervalSizeUsec() != 0L) {
          setHistogramIntervalSizeUsec(other.getHistogramIntervalSizeUsec());
        }
        if (other.getNumHistogramIntervals() != 0L) {
          setNumHistogramIntervals(other.getNumHistogramIntervals());
        }
        if (other.getEnableInputOutputLatency() != false) {
          setEnableInputOutputLatency(other.getEnableInputOutputLatency());
        }
        if (other.getEnableProfiler() != false) {
          setEnableProfiler(other.getEnableProfiler());
        }
        if (other.getEnableStreamLatency() != false) {
          setEnableStreamLatency(other.getEnableStreamLatency());
        }
        if (other.getUsePacketTimestampForAddedPacket() != false) {
          setUsePacketTimestampForAddedPacket(other.getUsePacketTimestampForAddedPacket());
        }
        if (other.getTraceLogCapacity() != 0L) {
          setTraceLogCapacity(other.getTraceLogCapacity());
        }
        if (!other.traceEventTypesDisabled_.isEmpty()) {
          if (traceEventTypesDisabled_.isEmpty()) {
            traceEventTypesDisabled_ = other.traceEventTypesDisabled_;
            bitField0_ = (bitField0_ & ~0x00000080);
          } else {
            ensureTraceEventTypesDisabledIsMutable();
            traceEventTypesDisabled_.addAll(other.traceEventTypesDisabled_);
          }
          onChanged();
        }
        if (!other.getTraceLogPath().isEmpty()) {
          traceLogPath_ = other.traceLogPath_;
          onChanged();
        }
        if (other.getTraceLogCount() != 0) {
          setTraceLogCount(other.getTraceLogCount());
        }
        if (other.getTraceLogIntervalUsec() != 0L) {
          setTraceLogIntervalUsec(other.getTraceLogIntervalUsec());
        }
        if (other.getTraceLogMarginUsec() != 0L) {
          setTraceLogMarginUsec(other.getTraceLogMarginUsec());
        }
        if (other.getTraceLogDurationEvents() != false) {
          setTraceLogDurationEvents(other.getTraceLogDurationEvents());
        }
        if (other.getTraceLogIntervalCount() != 0) {
          setTraceLogIntervalCount(other.getTraceLogIntervalCount());
        }
        if (other.getTraceLogDisabled() != false) {
          setTraceLogDisabled(other.getTraceLogDisabled());
        }
        if (other.getTraceEnabled() != false) {
          setTraceEnabled(other.getTraceEnabled());
        }
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        com.google.mediapipe.proto.CalculatorProto.ProfilerConfig parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (com.google.mediapipe.proto.CalculatorProto.ProfilerConfig) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private long histogramIntervalSizeUsec_ ;
      /**
       * <pre>
       * Size of the runtimes histogram intervals (in microseconds) to generate the
       * histogram of the Process() time. The last interval extends to +inf.
       * If not specified, the interval is 1000000 usec = 1 sec.
       * </pre>
       *
       * <code>optional int64 histogram_interval_size_usec = 1;</code>
       */
      public long getHistogramIntervalSizeUsec() {
        return histogramIntervalSizeUsec_;
      }
      /**
       * <pre>
       * Size of the runtimes histogram intervals (in microseconds) to generate the
       * histogram of the Process() time. The last interval extends to +inf.
       * If not specified, the interval is 1000000 usec = 1 sec.
       * </pre>
       *
       * <code>optional int64 histogram_interval_size_usec = 1;</code>
       */
      public Builder setHistogramIntervalSizeUsec(long value) {
        
        histogramIntervalSizeUsec_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Size of the runtimes histogram intervals (in microseconds) to generate the
       * histogram of the Process() time. The last interval extends to +inf.
       * If not specified, the interval is 1000000 usec = 1 sec.
       * </pre>
       *
       * <code>optional int64 histogram_interval_size_usec = 1;</code>
       */
      public Builder clearHistogramIntervalSizeUsec() {
        
        histogramIntervalSizeUsec_ = 0L;
        onChanged();
        return this;
      }

      private long numHistogramIntervals_ ;
      /**
       * <pre>
       * Number of intervals to generate the histogram of the Process() runtime.
       * If not specified, one interval is used.
       * </pre>
       *
       * <code>optional int64 num_histogram_intervals = 2;</code>
       */
      public long getNumHistogramIntervals() {
        return numHistogramIntervals_;
      }
      /**
       * <pre>
       * Number of intervals to generate the histogram of the Process() runtime.
       * If not specified, one interval is used.
       * </pre>
       *
       * <code>optional int64 num_histogram_intervals = 2;</code>
       */
      public Builder setNumHistogramIntervals(long value) {
        
        numHistogramIntervals_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Number of intervals to generate the histogram of the Process() runtime.
       * If not specified, one interval is used.
       * </pre>
       *
       * <code>optional int64 num_histogram_intervals = 2;</code>
       */
      public Builder clearNumHistogramIntervals() {
        
        numHistogramIntervals_ = 0L;
        onChanged();
        return this;
      }

      private boolean enableInputOutputLatency_ ;
      /**
       * <pre>
       * TODO: clean up after migration to MediaPipeProfiler.
       * DEPRECATED: If true, the profiler also profiles the input output latency.
       * Should be true only if the packet timestamps corresponds to the
       * microseconds wall time from epoch.
       * </pre>
       *
       * <code>optional bool enable_input_output_latency = 3 [deprecated = true];</code>
       */
      @java.lang.Deprecated public boolean getEnableInputOutputLatency() {
        return enableInputOutputLatency_;
      }
      /**
       * <pre>
       * TODO: clean up after migration to MediaPipeProfiler.
       * DEPRECATED: If true, the profiler also profiles the input output latency.
       * Should be true only if the packet timestamps corresponds to the
       * microseconds wall time from epoch.
       * </pre>
       *
       * <code>optional bool enable_input_output_latency = 3 [deprecated = true];</code>
       */
      @java.lang.Deprecated public Builder setEnableInputOutputLatency(boolean value) {
        
        enableInputOutputLatency_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * TODO: clean up after migration to MediaPipeProfiler.
       * DEPRECATED: If true, the profiler also profiles the input output latency.
       * Should be true only if the packet timestamps corresponds to the
       * microseconds wall time from epoch.
       * </pre>
       *
       * <code>optional bool enable_input_output_latency = 3 [deprecated = true];</code>
       */
      @java.lang.Deprecated public Builder clearEnableInputOutputLatency() {
        
        enableInputOutputLatency_ = false;
        onChanged();
        return this;
      }

      private boolean enableProfiler_ ;
      /**
       * <pre>
       * If true, the profiler starts profiling when graph is initialized.
       * </pre>
       *
       * <code>optional bool enable_profiler = 4;</code>
       */
      public boolean getEnableProfiler() {
        return enableProfiler_;
      }
      /**
       * <pre>
       * If true, the profiler starts profiling when graph is initialized.
       * </pre>
       *
       * <code>optional bool enable_profiler = 4;</code>
       */
      public Builder setEnableProfiler(boolean value) {
        
        enableProfiler_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If true, the profiler starts profiling when graph is initialized.
       * </pre>
       *
       * <code>optional bool enable_profiler = 4;</code>
       */
      public Builder clearEnableProfiler() {
        
        enableProfiler_ = false;
        onChanged();
        return this;
      }

      private boolean enableStreamLatency_ ;
      /**
       * <pre>
       * If true, the profiler also profiles the stream latency and input-output
       * latency.
       * No-op if enable_profiler is false.
       * </pre>
       *
       * <code>optional bool enable_stream_latency = 5;</code>
       */
      public boolean getEnableStreamLatency() {
        return enableStreamLatency_;
      }
      /**
       * <pre>
       * If true, the profiler also profiles the stream latency and input-output
       * latency.
       * No-op if enable_profiler is false.
       * </pre>
       *
       * <code>optional bool enable_stream_latency = 5;</code>
       */
      public Builder setEnableStreamLatency(boolean value) {
        
        enableStreamLatency_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If true, the profiler also profiles the stream latency and input-output
       * latency.
       * No-op if enable_profiler is false.
       * </pre>
       *
       * <code>optional bool enable_stream_latency = 5;</code>
       */
      public Builder clearEnableStreamLatency() {
        
        enableStreamLatency_ = false;
        onChanged();
        return this;
      }

      private boolean usePacketTimestampForAddedPacket_ ;
      /**
       * <pre>
       * If true, the profiler uses packet timestamp (as production time and source
       * production time) for packets added by calling
       * CalculatorGraph::AddPacketToInputStream().
       * If false, uses profiler's clock.
       * </pre>
       *
       * <code>optional bool use_packet_timestamp_for_added_packet = 6;</code>
       */
      public boolean getUsePacketTimestampForAddedPacket() {
        return usePacketTimestampForAddedPacket_;
      }
      /**
       * <pre>
       * If true, the profiler uses packet timestamp (as production time and source
       * production time) for packets added by calling
       * CalculatorGraph::AddPacketToInputStream().
       * If false, uses profiler's clock.
       * </pre>
       *
       * <code>optional bool use_packet_timestamp_for_added_packet = 6;</code>
       */
      public Builder setUsePacketTimestampForAddedPacket(boolean value) {
        
        usePacketTimestampForAddedPacket_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If true, the profiler uses packet timestamp (as production time and source
       * production time) for packets added by calling
       * CalculatorGraph::AddPacketToInputStream().
       * If false, uses profiler's clock.
       * </pre>
       *
       * <code>optional bool use_packet_timestamp_for_added_packet = 6;</code>
       */
      public Builder clearUsePacketTimestampForAddedPacket() {
        
        usePacketTimestampForAddedPacket_ = false;
        onChanged();
        return this;
      }

      private long traceLogCapacity_ ;
      /**
       * <pre>
       * The maximum number of trace events buffered in memory.
       * The default value buffers up to 20000 events.
       * </pre>
       *
       * <code>optional int64 trace_log_capacity = 7;</code>
       */
      public long getTraceLogCapacity() {
        return traceLogCapacity_;
      }
      /**
       * <pre>
       * The maximum number of trace events buffered in memory.
       * The default value buffers up to 20000 events.
       * </pre>
       *
       * <code>optional int64 trace_log_capacity = 7;</code>
       */
      public Builder setTraceLogCapacity(long value) {
        
        traceLogCapacity_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The maximum number of trace events buffered in memory.
       * The default value buffers up to 20000 events.
       * </pre>
       *
       * <code>optional int64 trace_log_capacity = 7;</code>
       */
      public Builder clearTraceLogCapacity() {
        
        traceLogCapacity_ = 0L;
        onChanged();
        return this;
      }

      private java.util.List<java.lang.Integer> traceEventTypesDisabled_ = java.util.Collections.emptyList();
      private void ensureTraceEventTypesDisabledIsMutable() {
        if (!((bitField0_ & 0x00000080) == 0x00000080)) {
          traceEventTypesDisabled_ = new java.util.ArrayList<java.lang.Integer>(traceEventTypesDisabled_);
          bitField0_ |= 0x00000080;
         }
      }
      /**
       * <pre>
       * Trace event types that are not logged.
       * </pre>
       *
       * <code>repeated int32 trace_event_types_disabled = 8;</code>
       */
      public java.util.List<java.lang.Integer>
          getTraceEventTypesDisabledList() {
        return java.util.Collections.unmodifiableList(traceEventTypesDisabled_);
      }
      /**
       * <pre>
       * Trace event types that are not logged.
       * </pre>
       *
       * <code>repeated int32 trace_event_types_disabled = 8;</code>
       */
      public int getTraceEventTypesDisabledCount() {
        return traceEventTypesDisabled_.size();
      }
      /**
       * <pre>
       * Trace event types that are not logged.
       * </pre>
       *
       * <code>repeated int32 trace_event_types_disabled = 8;</code>
       */
      public int getTraceEventTypesDisabled(int index) {
        return traceEventTypesDisabled_.get(index);
      }
      /**
       * <pre>
       * Trace event types that are not logged.
       * </pre>
       *
       * <code>repeated int32 trace_event_types_disabled = 8;</code>
       */
      public Builder setTraceEventTypesDisabled(
          int index, int value) {
        ensureTraceEventTypesDisabledIsMutable();
        traceEventTypesDisabled_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Trace event types that are not logged.
       * </pre>
       *
       * <code>repeated int32 trace_event_types_disabled = 8;</code>
       */
      public Builder addTraceEventTypesDisabled(int value) {
        ensureTraceEventTypesDisabledIsMutable();
        traceEventTypesDisabled_.add(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Trace event types that are not logged.
       * </pre>
       *
       * <code>repeated int32 trace_event_types_disabled = 8;</code>
       */
      public Builder addAllTraceEventTypesDisabled(
          java.lang.Iterable<? extends java.lang.Integer> values) {
        ensureTraceEventTypesDisabledIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, traceEventTypesDisabled_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Trace event types that are not logged.
       * </pre>
       *
       * <code>repeated int32 trace_event_types_disabled = 8;</code>
       */
      public Builder clearTraceEventTypesDisabled() {
        traceEventTypesDisabled_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000080);
        onChanged();
        return this;
      }

      private java.lang.Object traceLogPath_ = "";
      /**
       * <pre>
       * The output directory and base-name prefix for trace log files.
       * Log files are written to: StrCat(trace_log_path, index, ".binarypb")
       * </pre>
       *
       * <code>optional string trace_log_path = 9;</code>
       */
      public java.lang.String getTraceLogPath() {
        java.lang.Object ref = traceLogPath_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          traceLogPath_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The output directory and base-name prefix for trace log files.
       * Log files are written to: StrCat(trace_log_path, index, ".binarypb")
       * </pre>
       *
       * <code>optional string trace_log_path = 9;</code>
       */
      public com.google.protobuf.ByteString
          getTraceLogPathBytes() {
        java.lang.Object ref = traceLogPath_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          traceLogPath_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The output directory and base-name prefix for trace log files.
       * Log files are written to: StrCat(trace_log_path, index, ".binarypb")
       * </pre>
       *
       * <code>optional string trace_log_path = 9;</code>
       */
      public Builder setTraceLogPath(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        traceLogPath_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The output directory and base-name prefix for trace log files.
       * Log files are written to: StrCat(trace_log_path, index, ".binarypb")
       * </pre>
       *
       * <code>optional string trace_log_path = 9;</code>
       */
      public Builder clearTraceLogPath() {
        
        traceLogPath_ = getDefaultInstance().getTraceLogPath();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The output directory and base-name prefix for trace log files.
       * Log files are written to: StrCat(trace_log_path, index, ".binarypb")
       * </pre>
       *
       * <code>optional string trace_log_path = 9;</code>
       */
      public Builder setTraceLogPathBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        traceLogPath_ = value;
        onChanged();
        return this;
      }

      private int traceLogCount_ ;
      /**
       * <pre>
       * The number of trace log files retained.
       * The trace log files are named "trace_0.log" through "trace_k.log".
       * The default value specifies 2 output files retained.
       * </pre>
       *
       * <code>optional int32 trace_log_count = 10;</code>
       */
      public int getTraceLogCount() {
        return traceLogCount_;
      }
      /**
       * <pre>
       * The number of trace log files retained.
       * The trace log files are named "trace_0.log" through "trace_k.log".
       * The default value specifies 2 output files retained.
       * </pre>
       *
       * <code>optional int32 trace_log_count = 10;</code>
       */
      public Builder setTraceLogCount(int value) {
        
        traceLogCount_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The number of trace log files retained.
       * The trace log files are named "trace_0.log" through "trace_k.log".
       * The default value specifies 2 output files retained.
       * </pre>
       *
       * <code>optional int32 trace_log_count = 10;</code>
       */
      public Builder clearTraceLogCount() {
        
        traceLogCount_ = 0;
        onChanged();
        return this;
      }

      private long traceLogIntervalUsec_ ;
      /**
       * <pre>
       * The interval in microseconds between trace log output.
       * The default value specifies trace log output once every 0.5 sec.
       * </pre>
       *
       * <code>optional int64 trace_log_interval_usec = 11;</code>
       */
      public long getTraceLogIntervalUsec() {
        return traceLogIntervalUsec_;
      }
      /**
       * <pre>
       * The interval in microseconds between trace log output.
       * The default value specifies trace log output once every 0.5 sec.
       * </pre>
       *
       * <code>optional int64 trace_log_interval_usec = 11;</code>
       */
      public Builder setTraceLogIntervalUsec(long value) {
        
        traceLogIntervalUsec_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The interval in microseconds between trace log output.
       * The default value specifies trace log output once every 0.5 sec.
       * </pre>
       *
       * <code>optional int64 trace_log_interval_usec = 11;</code>
       */
      public Builder clearTraceLogIntervalUsec() {
        
        traceLogIntervalUsec_ = 0L;
        onChanged();
        return this;
      }

      private long traceLogMarginUsec_ ;
      /**
       * <pre>
       * The interval in microseconds between TimeNow and the highest times
       * included in trace log output.  This margin allows time for events
       * to be appended to the TraceBuffer.
       * </pre>
       *
       * <code>optional int64 trace_log_margin_usec = 12;</code>
       */
      public long getTraceLogMarginUsec() {
        return traceLogMarginUsec_;
      }
      /**
       * <pre>
       * The interval in microseconds between TimeNow and the highest times
       * included in trace log output.  This margin allows time for events
       * to be appended to the TraceBuffer.
       * </pre>
       *
       * <code>optional int64 trace_log_margin_usec = 12;</code>
       */
      public Builder setTraceLogMarginUsec(long value) {
        
        traceLogMarginUsec_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The interval in microseconds between TimeNow and the highest times
       * included in trace log output.  This margin allows time for events
       * to be appended to the TraceBuffer.
       * </pre>
       *
       * <code>optional int64 trace_log_margin_usec = 12;</code>
       */
      public Builder clearTraceLogMarginUsec() {
        
        traceLogMarginUsec_ = 0L;
        onChanged();
        return this;
      }

      private boolean traceLogDurationEvents_ ;
      /**
       * <pre>
       * False specifies an event for each calculator invocation.
       * True specifies a separate event for each start and finish time.
       * </pre>
       *
       * <code>optional bool trace_log_duration_events = 13;</code>
       */
      public boolean getTraceLogDurationEvents() {
        return traceLogDurationEvents_;
      }
      /**
       * <pre>
       * False specifies an event for each calculator invocation.
       * True specifies a separate event for each start and finish time.
       * </pre>
       *
       * <code>optional bool trace_log_duration_events = 13;</code>
       */
      public Builder setTraceLogDurationEvents(boolean value) {
        
        traceLogDurationEvents_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * False specifies an event for each calculator invocation.
       * True specifies a separate event for each start and finish time.
       * </pre>
       *
       * <code>optional bool trace_log_duration_events = 13;</code>
       */
      public Builder clearTraceLogDurationEvents() {
        
        traceLogDurationEvents_ = false;
        onChanged();
        return this;
      }

      private int traceLogIntervalCount_ ;
      /**
       * <pre>
       * The number of trace log intervals per file. The total log duration is:
       * trace_log_interval_usec * trace_log_file_count * trace_log_interval_count.
       * The default value specifies 10 intervals per file.
       * </pre>
       *
       * <code>optional int32 trace_log_interval_count = 14;</code>
       */
      public int getTraceLogIntervalCount() {
        return traceLogIntervalCount_;
      }
      /**
       * <pre>
       * The number of trace log intervals per file. The total log duration is:
       * trace_log_interval_usec * trace_log_file_count * trace_log_interval_count.
       * The default value specifies 10 intervals per file.
       * </pre>
       *
       * <code>optional int32 trace_log_interval_count = 14;</code>
       */
      public Builder setTraceLogIntervalCount(int value) {
        
        traceLogIntervalCount_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The number of trace log intervals per file. The total log duration is:
       * trace_log_interval_usec * trace_log_file_count * trace_log_interval_count.
       * The default value specifies 10 intervals per file.
       * </pre>
       *
       * <code>optional int32 trace_log_interval_count = 14;</code>
       */
      public Builder clearTraceLogIntervalCount() {
        
        traceLogIntervalCount_ = 0;
        onChanged();
        return this;
      }

      private boolean traceLogDisabled_ ;
      /**
       * <pre>
       * An option to turn ON/OFF writing trace files to disk. Saving trace files to
       * disk is enabled by default.
       * </pre>
       *
       * <code>optional bool trace_log_disabled = 15;</code>
       */
      public boolean getTraceLogDisabled() {
        return traceLogDisabled_;
      }
      /**
       * <pre>
       * An option to turn ON/OFF writing trace files to disk. Saving trace files to
       * disk is enabled by default.
       * </pre>
       *
       * <code>optional bool trace_log_disabled = 15;</code>
       */
      public Builder setTraceLogDisabled(boolean value) {
        
        traceLogDisabled_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * An option to turn ON/OFF writing trace files to disk. Saving trace files to
       * disk is enabled by default.
       * </pre>
       *
       * <code>optional bool trace_log_disabled = 15;</code>
       */
      public Builder clearTraceLogDisabled() {
        
        traceLogDisabled_ = false;
        onChanged();
        return this;
      }

      private boolean traceEnabled_ ;
      /**
       * <pre>
       * If true, tracer timing events are recorded and reported.
       * </pre>
       *
       * <code>optional bool trace_enabled = 16;</code>
       */
      public boolean getTraceEnabled() {
        return traceEnabled_;
      }
      /**
       * <pre>
       * If true, tracer timing events are recorded and reported.
       * </pre>
       *
       * <code>optional bool trace_enabled = 16;</code>
       */
      public Builder setTraceEnabled(boolean value) {
        
        traceEnabled_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If true, tracer timing events are recorded and reported.
       * </pre>
       *
       * <code>optional bool trace_enabled = 16;</code>
       */
      public Builder clearTraceEnabled() {
        
        traceEnabled_ = false;
        onChanged();
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return this;
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return this;
      }


      // @@protoc_insertion_point(builder_scope:mediapipe.ProfilerConfig)
    }

    // @@protoc_insertion_point(class_scope:mediapipe.ProfilerConfig)
    private static final com.google.mediapipe.proto.CalculatorProto.ProfilerConfig DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.google.mediapipe.proto.CalculatorProto.ProfilerConfig();
    }

    public static com.google.mediapipe.proto.CalculatorProto.ProfilerConfig getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ProfilerConfig>
        PARSER = new com.google.protobuf.AbstractParser<ProfilerConfig>() {
      public ProfilerConfig parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
          return new ProfilerConfig(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ProfilerConfig> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ProfilerConfig> getParserForType() {
      return PARSER;
    }

    public com.google.mediapipe.proto.CalculatorProto.ProfilerConfig getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface CalculatorGraphConfigOrBuilder extends
      // @@protoc_insertion_point(interface_extends:mediapipe.CalculatorGraphConfig)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The nodes.
     * </pre>
     *
     * <code>repeated .mediapipe.CalculatorGraphConfig.Node node = 1;</code>
     */
    java.util.List<com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node> 
        getNodeList();
    /**
     * <pre>
     * The nodes.
     * </pre>
     *
     * <code>repeated .mediapipe.CalculatorGraphConfig.Node node = 1;</code>
     */
    com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node getNode(int index);
    /**
     * <pre>
     * The nodes.
     * </pre>
     *
     * <code>repeated .mediapipe.CalculatorGraphConfig.Node node = 1;</code>
     */
    int getNodeCount();
    /**
     * <pre>
     * The nodes.
     * </pre>
     *
     * <code>repeated .mediapipe.CalculatorGraphConfig.Node node = 1;</code>
     */
    java.util.List<? extends com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.NodeOrBuilder> 
        getNodeOrBuilderList();
    /**
     * <pre>
     * The nodes.
     * </pre>
     *
     * <code>repeated .mediapipe.CalculatorGraphConfig.Node node = 1;</code>
     */
    com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.NodeOrBuilder getNodeOrBuilder(
        int index);

    /**
     * <pre>
     * Create a side packet using a PacketFactory.  This side packet is
     * created as close to the worker that does the work as possible.  A
     * PacketFactory is basically a PacketGenerator that takes no input side
     * packets and produces a single output side packet.
     * </pre>
     *
     * <code>repeated .mediapipe.PacketFactoryConfig packet_factory = 6;</code>
     */
    java.util.List<mediapipe.PacketFactory.PacketFactoryConfig> 
        getPacketFactoryList();
    /**
     * <pre>
     * Create a side packet using a PacketFactory.  This side packet is
     * created as close to the worker that does the work as possible.  A
     * PacketFactory is basically a PacketGenerator that takes no input side
     * packets and produces a single output side packet.
     * </pre>
     *
     * <code>repeated .mediapipe.PacketFactoryConfig packet_factory = 6;</code>
     */
    mediapipe.PacketFactory.PacketFactoryConfig getPacketFactory(int index);
    /**
     * <pre>
     * Create a side packet using a PacketFactory.  This side packet is
     * created as close to the worker that does the work as possible.  A
     * PacketFactory is basically a PacketGenerator that takes no input side
     * packets and produces a single output side packet.
     * </pre>
     *
     * <code>repeated .mediapipe.PacketFactoryConfig packet_factory = 6;</code>
     */
    int getPacketFactoryCount();
    /**
     * <pre>
     * Create a side packet using a PacketFactory.  This side packet is
     * created as close to the worker that does the work as possible.  A
     * PacketFactory is basically a PacketGenerator that takes no input side
     * packets and produces a single output side packet.
     * </pre>
     *
     * <code>repeated .mediapipe.PacketFactoryConfig packet_factory = 6;</code>
     */
    java.util.List<? extends mediapipe.PacketFactory.PacketFactoryConfigOrBuilder> 
        getPacketFactoryOrBuilderList();
    /**
     * <pre>
     * Create a side packet using a PacketFactory.  This side packet is
     * created as close to the worker that does the work as possible.  A
     * PacketFactory is basically a PacketGenerator that takes no input side
     * packets and produces a single output side packet.
     * </pre>
     *
     * <code>repeated .mediapipe.PacketFactoryConfig packet_factory = 6;</code>
     */
    mediapipe.PacketFactory.PacketFactoryConfigOrBuilder getPacketFactoryOrBuilder(
        int index);

    /**
     * <pre>
     * Configs for PacketGenerators.  Generators take zero or more
     * input side packets and produce any number of output side
     * packets.  For example, MediaDecoderCalculator takes an input
     * side packet with type DeletingFile.  However, most users want
     * to specify videos by ContentIdHex (i.e. video id).  By using
     * the VideoIdToLocalFileGenerator, a user can specify a video id
     * (as a string) and obtain a DeletingFile to use with the decoder.
     * PacketGenerators can take as a input side packet the output side
     * packet of another PacketGenerator.  The graph of PacketGenerators
     * must be a directed acyclic graph.
     * </pre>
     *
     * <code>repeated .mediapipe.PacketGeneratorConfig packet_generator = 7;</code>
     */
    java.util.List<mediapipe.PacketGenerator.PacketGeneratorConfig> 
        getPacketGeneratorList();
    /**
     * <pre>
     * Configs for PacketGenerators.  Generators take zero or more
     * input side packets and produce any number of output side
     * packets.  For example, MediaDecoderCalculator takes an input
     * side packet with type DeletingFile.  However, most users want
     * to specify videos by ContentIdHex (i.e. video id).  By using
     * the VideoIdToLocalFileGenerator, a user can specify a video id
     * (as a string) and obtain a DeletingFile to use with the decoder.
     * PacketGenerators can take as a input side packet the output side
     * packet of another PacketGenerator.  The graph of PacketGenerators
     * must be a directed acyclic graph.
     * </pre>
     *
     * <code>repeated .mediapipe.PacketGeneratorConfig packet_generator = 7;</code>
     */
    mediapipe.PacketGenerator.PacketGeneratorConfig getPacketGenerator(int index);
    /**
     * <pre>
     * Configs for PacketGenerators.  Generators take zero or more
     * input side packets and produce any number of output side
     * packets.  For example, MediaDecoderCalculator takes an input
     * side packet with type DeletingFile.  However, most users want
     * to specify videos by ContentIdHex (i.e. video id).  By using
     * the VideoIdToLocalFileGenerator, a user can specify a video id
     * (as a string) and obtain a DeletingFile to use with the decoder.
     * PacketGenerators can take as a input side packet the output side
     * packet of another PacketGenerator.  The graph of PacketGenerators
     * must be a directed acyclic graph.
     * </pre>
     *
     * <code>repeated .mediapipe.PacketGeneratorConfig packet_generator = 7;</code>
     */
    int getPacketGeneratorCount();
    /**
     * <pre>
     * Configs for PacketGenerators.  Generators take zero or more
     * input side packets and produce any number of output side
     * packets.  For example, MediaDecoderCalculator takes an input
     * side packet with type DeletingFile.  However, most users want
     * to specify videos by ContentIdHex (i.e. video id).  By using
     * the VideoIdToLocalFileGenerator, a user can specify a video id
     * (as a string) and obtain a DeletingFile to use with the decoder.
     * PacketGenerators can take as a input side packet the output side
     * packet of another PacketGenerator.  The graph of PacketGenerators
     * must be a directed acyclic graph.
     * </pre>
     *
     * <code>repeated .mediapipe.PacketGeneratorConfig packet_generator = 7;</code>
     */
    java.util.List<? extends mediapipe.PacketGenerator.PacketGeneratorConfigOrBuilder> 
        getPacketGeneratorOrBuilderList();
    /**
     * <pre>
     * Configs for PacketGenerators.  Generators take zero or more
     * input side packets and produce any number of output side
     * packets.  For example, MediaDecoderCalculator takes an input
     * side packet with type DeletingFile.  However, most users want
     * to specify videos by ContentIdHex (i.e. video id).  By using
     * the VideoIdToLocalFileGenerator, a user can specify a video id
     * (as a string) and obtain a DeletingFile to use with the decoder.
     * PacketGenerators can take as a input side packet the output side
     * packet of another PacketGenerator.  The graph of PacketGenerators
     * must be a directed acyclic graph.
     * </pre>
     *
     * <code>repeated .mediapipe.PacketGeneratorConfig packet_generator = 7;</code>
     */
    mediapipe.PacketGenerator.PacketGeneratorConfigOrBuilder getPacketGeneratorOrBuilder(
        int index);

    /**
     * <pre>
     * Number of threads for running calculators in multithreaded mode.
     * If not specified, the scheduler will pick an appropriate number
     * of threads depending on the number of available processors.
     * To run on the calling thread, specify "ApplicationThreadExecutor"
     * see: http://g3doc/mediapipe/g3doc/running.md.
     * </pre>
     *
     * <code>optional int32 num_threads = 8;</code>
     */
    int getNumThreads();

    /**
     * <pre>
     * Configs for StatusHandlers that will be called after each call to
     * Run() on the graph.  StatusHandlers take zero or more input side
     * packets and the ::util::Status returned by a graph run.  For example,
     * a StatusHandler could store information about graph failures and
     * their causes for later monitoring.  Note that graph failures during
     * initialization may cause required input side packets (created by a
     * PacketFactory or PacketGenerator) to be missing.  In these cases,
     * the handler with missing input side packets will be skipped.
     * </pre>
     *
     * <code>repeated .mediapipe.StatusHandlerConfig status_handler = 9;</code>
     */
    java.util.List<mediapipe.StatusHandler.StatusHandlerConfig> 
        getStatusHandlerList();
    /**
     * <pre>
     * Configs for StatusHandlers that will be called after each call to
     * Run() on the graph.  StatusHandlers take zero or more input side
     * packets and the ::util::Status returned by a graph run.  For example,
     * a StatusHandler could store information about graph failures and
     * their causes for later monitoring.  Note that graph failures during
     * initialization may cause required input side packets (created by a
     * PacketFactory or PacketGenerator) to be missing.  In these cases,
     * the handler with missing input side packets will be skipped.
     * </pre>
     *
     * <code>repeated .mediapipe.StatusHandlerConfig status_handler = 9;</code>
     */
    mediapipe.StatusHandler.StatusHandlerConfig getStatusHandler(int index);
    /**
     * <pre>
     * Configs for StatusHandlers that will be called after each call to
     * Run() on the graph.  StatusHandlers take zero or more input side
     * packets and the ::util::Status returned by a graph run.  For example,
     * a StatusHandler could store information about graph failures and
     * their causes for later monitoring.  Note that graph failures during
     * initialization may cause required input side packets (created by a
     * PacketFactory or PacketGenerator) to be missing.  In these cases,
     * the handler with missing input side packets will be skipped.
     * </pre>
     *
     * <code>repeated .mediapipe.StatusHandlerConfig status_handler = 9;</code>
     */
    int getStatusHandlerCount();
    /**
     * <pre>
     * Configs for StatusHandlers that will be called after each call to
     * Run() on the graph.  StatusHandlers take zero or more input side
     * packets and the ::util::Status returned by a graph run.  For example,
     * a StatusHandler could store information about graph failures and
     * their causes for later monitoring.  Note that graph failures during
     * initialization may cause required input side packets (created by a
     * PacketFactory or PacketGenerator) to be missing.  In these cases,
     * the handler with missing input side packets will be skipped.
     * </pre>
     *
     * <code>repeated .mediapipe.StatusHandlerConfig status_handler = 9;</code>
     */
    java.util.List<? extends mediapipe.StatusHandler.StatusHandlerConfigOrBuilder> 
        getStatusHandlerOrBuilderList();
    /**
     * <pre>
     * Configs for StatusHandlers that will be called after each call to
     * Run() on the graph.  StatusHandlers take zero or more input side
     * packets and the ::util::Status returned by a graph run.  For example,
     * a StatusHandler could store information about graph failures and
     * their causes for later monitoring.  Note that graph failures during
     * initialization may cause required input side packets (created by a
     * PacketFactory or PacketGenerator) to be missing.  In these cases,
     * the handler with missing input side packets will be skipped.
     * </pre>
     *
     * <code>repeated .mediapipe.StatusHandlerConfig status_handler = 9;</code>
     */
    mediapipe.StatusHandler.StatusHandlerConfigOrBuilder getStatusHandlerOrBuilder(
        int index);

    /**
     * <pre>
     * Specify input streams to the entire graph.  Streams specified here may have
     * packets added to them using CalculatorGraph::AddPacketToInputStream.  This
     * works much like a source calculator, except that the source is outside of
     * the mediapipe graph.
     * </pre>
     *
     * <code>repeated string input_stream = 10;</code>
     */
    java.util.List<java.lang.String>
        getInputStreamList();
    /**
     * <pre>
     * Specify input streams to the entire graph.  Streams specified here may have
     * packets added to them using CalculatorGraph::AddPacketToInputStream.  This
     * works much like a source calculator, except that the source is outside of
     * the mediapipe graph.
     * </pre>
     *
     * <code>repeated string input_stream = 10;</code>
     */
    int getInputStreamCount();
    /**
     * <pre>
     * Specify input streams to the entire graph.  Streams specified here may have
     * packets added to them using CalculatorGraph::AddPacketToInputStream.  This
     * works much like a source calculator, except that the source is outside of
     * the mediapipe graph.
     * </pre>
     *
     * <code>repeated string input_stream = 10;</code>
     */
    java.lang.String getInputStream(int index);
    /**
     * <pre>
     * Specify input streams to the entire graph.  Streams specified here may have
     * packets added to them using CalculatorGraph::AddPacketToInputStream.  This
     * works much like a source calculator, except that the source is outside of
     * the mediapipe graph.
     * </pre>
     *
     * <code>repeated string input_stream = 10;</code>
     */
    com.google.protobuf.ByteString
        getInputStreamBytes(int index);

    /**
     * <pre>
     * Output streams for the graph when used as a subgraph.
     * </pre>
     *
     * <code>repeated string output_stream = 15;</code>
     */
    java.util.List<java.lang.String>
        getOutputStreamList();
    /**
     * <pre>
     * Output streams for the graph when used as a subgraph.
     * </pre>
     *
     * <code>repeated string output_stream = 15;</code>
     */
    int getOutputStreamCount();
    /**
     * <pre>
     * Output streams for the graph when used as a subgraph.
     * </pre>
     *
     * <code>repeated string output_stream = 15;</code>
     */
    java.lang.String getOutputStream(int index);
    /**
     * <pre>
     * Output streams for the graph when used as a subgraph.
     * </pre>
     *
     * <code>repeated string output_stream = 15;</code>
     */
    com.google.protobuf.ByteString
        getOutputStreamBytes(int index);

    /**
     * <pre>
     * Input side packets for the graph when used as a subgraph.
     * </pre>
     *
     * <code>repeated string input_side_packet = 16;</code>
     */
    java.util.List<java.lang.String>
        getInputSidePacketList();
    /**
     * <pre>
     * Input side packets for the graph when used as a subgraph.
     * </pre>
     *
     * <code>repeated string input_side_packet = 16;</code>
     */
    int getInputSidePacketCount();
    /**
     * <pre>
     * Input side packets for the graph when used as a subgraph.
     * </pre>
     *
     * <code>repeated string input_side_packet = 16;</code>
     */
    java.lang.String getInputSidePacket(int index);
    /**
     * <pre>
     * Input side packets for the graph when used as a subgraph.
     * </pre>
     *
     * <code>repeated string input_side_packet = 16;</code>
     */
    com.google.protobuf.ByteString
        getInputSidePacketBytes(int index);

    /**
     * <pre>
     * Output side packets for the graph when used as a subgraph.
     * </pre>
     *
     * <code>repeated string output_side_packet = 17;</code>
     */
    java.util.List<java.lang.String>
        getOutputSidePacketList();
    /**
     * <pre>
     * Output side packets for the graph when used as a subgraph.
     * </pre>
     *
     * <code>repeated string output_side_packet = 17;</code>
     */
    int getOutputSidePacketCount();
    /**
     * <pre>
     * Output side packets for the graph when used as a subgraph.
     * </pre>
     *
     * <code>repeated string output_side_packet = 17;</code>
     */
    java.lang.String getOutputSidePacket(int index);
    /**
     * <pre>
     * Output side packets for the graph when used as a subgraph.
     * </pre>
     *
     * <code>repeated string output_side_packet = 17;</code>
     */
    com.google.protobuf.ByteString
        getOutputSidePacketBytes(int index);

    /**
     * <pre>
     * Maximum queue size of any input stream in the graph. This can be used to
     * control the memory usage of a MediaPipe graph by preventing fast sources
     * from flooding the graph with packets. Any source that is connected to an
     * input stream that has hit its maximum capacity will not be scheduled until
     * the queue size falls under the specified limits, or if the scheduler queue
     * is empty and no other nodes are running (to prevent possible deadlocks due
     * to a incorrectly specified value). This global parameter is set to 100
     * packets by default to enable pipelining. If any node indicates that it
     * buffers packets before emitting them, then the max(node_buffer_size,
     * max_queue_size) is used. Set this parameter to -1 to disable throttling
     * (i.e. the graph will use as much memory as it requires). If not specified,
     * the limit is 100 packets.
     * </pre>
     *
     * <code>optional int32 max_queue_size = 11;</code>
     */
    int getMaxQueueSize();

    /**
     * <pre>
     * If true, the graph run fails with an error when throttling prevents all
     * calculators from running.  If false, max_queue_size for an input stream
     * is adjusted when throttling prevents all calculators from running.
     * </pre>
     *
     * <code>optional bool report_deadlock = 21;</code>
     */
    boolean getReportDeadlock();

    /**
     * <pre>
     * Config for this graph's InputStreamHandler.
     * If unspecified, the framework will automatically install the default
     * handler, which works as follows.
     * The calculator's Process() method is called for timestamp t when:
     * - at least one stream has a packet available at t; and,
     * - all other streams either have packets at t, or it is known that they will
     * not have packets at t (i.e. their next timestamp bound is greater than t).
     * The handler then provides all available packets with timestamp t, with no
     * preprocessing.
     * </pre>
     *
     * <code>optional .mediapipe.InputStreamHandlerConfig input_stream_handler = 12;</code>
     */
    boolean hasInputStreamHandler();
    /**
     * <pre>
     * Config for this graph's InputStreamHandler.
     * If unspecified, the framework will automatically install the default
     * handler, which works as follows.
     * The calculator's Process() method is called for timestamp t when:
     * - at least one stream has a packet available at t; and,
     * - all other streams either have packets at t, or it is known that they will
     * not have packets at t (i.e. their next timestamp bound is greater than t).
     * The handler then provides all available packets with timestamp t, with no
     * preprocessing.
     * </pre>
     *
     * <code>optional .mediapipe.InputStreamHandlerConfig input_stream_handler = 12;</code>
     */
    mediapipe.StreamHandler.InputStreamHandlerConfig getInputStreamHandler();
    /**
     * <pre>
     * Config for this graph's InputStreamHandler.
     * If unspecified, the framework will automatically install the default
     * handler, which works as follows.
     * The calculator's Process() method is called for timestamp t when:
     * - at least one stream has a packet available at t; and,
     * - all other streams either have packets at t, or it is known that they will
     * not have packets at t (i.e. their next timestamp bound is greater than t).
     * The handler then provides all available packets with timestamp t, with no
     * preprocessing.
     * </pre>
     *
     * <code>optional .mediapipe.InputStreamHandlerConfig input_stream_handler = 12;</code>
     */
    mediapipe.StreamHandler.InputStreamHandlerConfigOrBuilder getInputStreamHandlerOrBuilder();

    /**
     * <pre>
     * Config for this graph's OutputStreamHandler.
     * If unspecified, the default output stream handler will be automatically
     * installed by the framework which does not modify any outgoing packets.
     * </pre>
     *
     * <code>optional .mediapipe.OutputStreamHandlerConfig output_stream_handler = 13;</code>
     */
    boolean hasOutputStreamHandler();
    /**
     * <pre>
     * Config for this graph's OutputStreamHandler.
     * If unspecified, the default output stream handler will be automatically
     * installed by the framework which does not modify any outgoing packets.
     * </pre>
     *
     * <code>optional .mediapipe.OutputStreamHandlerConfig output_stream_handler = 13;</code>
     */
    mediapipe.StreamHandler.OutputStreamHandlerConfig getOutputStreamHandler();
    /**
     * <pre>
     * Config for this graph's OutputStreamHandler.
     * If unspecified, the default output stream handler will be automatically
     * installed by the framework which does not modify any outgoing packets.
     * </pre>
     *
     * <code>optional .mediapipe.OutputStreamHandlerConfig output_stream_handler = 13;</code>
     */
    mediapipe.StreamHandler.OutputStreamHandlerConfigOrBuilder getOutputStreamHandlerOrBuilder();

    /**
     * <pre>
     * Configs for Executors.
     * The names of the executors must be distinct. The default executor, whose
     * name is the empty string, is predefined. The num_threads field of the
     * CalculatorGraphConfig specifies the number of threads in the default
     * executor. If the config for the default executor is specified, the
     * CalculatorGraphConfig must not have the num_threads field.
     * </pre>
     *
     * <code>repeated .mediapipe.ExecutorConfig executor = 14;</code>
     */
    java.util.List<com.google.mediapipe.proto.CalculatorProto.ExecutorConfig> 
        getExecutorList();
    /**
     * <pre>
     * Configs for Executors.
     * The names of the executors must be distinct. The default executor, whose
     * name is the empty string, is predefined. The num_threads field of the
     * CalculatorGraphConfig specifies the number of threads in the default
     * executor. If the config for the default executor is specified, the
     * CalculatorGraphConfig must not have the num_threads field.
     * </pre>
     *
     * <code>repeated .mediapipe.ExecutorConfig executor = 14;</code>
     */
    com.google.mediapipe.proto.CalculatorProto.ExecutorConfig getExecutor(int index);
    /**
     * <pre>
     * Configs for Executors.
     * The names of the executors must be distinct. The default executor, whose
     * name is the empty string, is predefined. The num_threads field of the
     * CalculatorGraphConfig specifies the number of threads in the default
     * executor. If the config for the default executor is specified, the
     * CalculatorGraphConfig must not have the num_threads field.
     * </pre>
     *
     * <code>repeated .mediapipe.ExecutorConfig executor = 14;</code>
     */
    int getExecutorCount();
    /**
     * <pre>
     * Configs for Executors.
     * The names of the executors must be distinct. The default executor, whose
     * name is the empty string, is predefined. The num_threads field of the
     * CalculatorGraphConfig specifies the number of threads in the default
     * executor. If the config for the default executor is specified, the
     * CalculatorGraphConfig must not have the num_threads field.
     * </pre>
     *
     * <code>repeated .mediapipe.ExecutorConfig executor = 14;</code>
     */
    java.util.List<? extends com.google.mediapipe.proto.CalculatorProto.ExecutorConfigOrBuilder> 
        getExecutorOrBuilderList();
    /**
     * <pre>
     * Configs for Executors.
     * The names of the executors must be distinct. The default executor, whose
     * name is the empty string, is predefined. The num_threads field of the
     * CalculatorGraphConfig specifies the number of threads in the default
     * executor. If the config for the default executor is specified, the
     * CalculatorGraphConfig must not have the num_threads field.
     * </pre>
     *
     * <code>repeated .mediapipe.ExecutorConfig executor = 14;</code>
     */
    com.google.mediapipe.proto.CalculatorProto.ExecutorConfigOrBuilder getExecutorOrBuilder(
        int index);

    /**
     * <pre>
     * The default profiler-config for all calculators.  If set, this defines the
     * profiling settings such as num_histogram_intervals for every calculator in
     * the graph.  Each of these settings can be overridden by the
     * |profiler_config| specified for a node.
     * </pre>
     *
     * <code>optional .mediapipe.ProfilerConfig profiler_config = 18;</code>
     */
    boolean hasProfilerConfig();
    /**
     * <pre>
     * The default profiler-config for all calculators.  If set, this defines the
     * profiling settings such as num_histogram_intervals for every calculator in
     * the graph.  Each of these settings can be overridden by the
     * |profiler_config| specified for a node.
     * </pre>
     *
     * <code>optional .mediapipe.ProfilerConfig profiler_config = 18;</code>
     */
    com.google.mediapipe.proto.CalculatorProto.ProfilerConfig getProfilerConfig();
    /**
     * <pre>
     * The default profiler-config for all calculators.  If set, this defines the
     * profiling settings such as num_histogram_intervals for every calculator in
     * the graph.  Each of these settings can be overridden by the
     * |profiler_config| specified for a node.
     * </pre>
     *
     * <code>optional .mediapipe.ProfilerConfig profiler_config = 18;</code>
     */
    com.google.mediapipe.proto.CalculatorProto.ProfilerConfigOrBuilder getProfilerConfigOrBuilder();

    /**
     * <pre>
     * The namespace used for class name lookup within this graph.
     * An unqualified or partially qualified class name is looked up in
     * this namespace first and then in enclosing namespaces.
     * </pre>
     *
     * <code>optional string package = 19;</code>
     */
    java.lang.String getPackage();
    /**
     * <pre>
     * The namespace used for class name lookup within this graph.
     * An unqualified or partially qualified class name is looked up in
     * this namespace first and then in enclosing namespaces.
     * </pre>
     *
     * <code>optional string package = 19;</code>
     */
    com.google.protobuf.ByteString
        getPackageBytes();

    /**
     * <pre>
     * The type name for the graph config, used for registering and referencing
     * the graph config.
     * </pre>
     *
     * <code>optional string type = 20;</code>
     */
    java.lang.String getType();
    /**
     * <pre>
     * The type name for the graph config, used for registering and referencing
     * the graph config.
     * </pre>
     *
     * <code>optional string type = 20;</code>
     */
    com.google.protobuf.ByteString
        getTypeBytes();

    /**
     * <pre>
     * Can be used for annotating a graph.
     * </pre>
     *
     * <code>optional .mediapipe.MediaPipeOptions options = 1001;</code>
     */
    boolean hasOptions();
    /**
     * <pre>
     * Can be used for annotating a graph.
     * </pre>
     *
     * <code>optional .mediapipe.MediaPipeOptions options = 1001;</code>
     */
    mediapipe.MediapipeOptions.MediaPipeOptions getOptions();
    /**
     * <pre>
     * Can be used for annotating a graph.
     * </pre>
     *
     * <code>optional .mediapipe.MediaPipeOptions options = 1001;</code>
     */
    mediapipe.MediapipeOptions.MediaPipeOptionsOrBuilder getOptionsOrBuilder();
  }
  /**
   * <pre>
   * Describes the topology and function of a MediaPipe Graph.  The graph of
   * Nodes must be a Directed Acyclic Graph (DAG) except as annotated by
   * "back_edge" in InputStreamInfo.  Use a mediapipe::CalculatorGraph object to
   * run the graph.
   * </pre>
   *
   * Protobuf type {@code mediapipe.CalculatorGraphConfig}
   */
  public  static final class CalculatorGraphConfig extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:mediapipe.CalculatorGraphConfig)
      CalculatorGraphConfigOrBuilder {
    // Use CalculatorGraphConfig.newBuilder() to construct.
    private CalculatorGraphConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private CalculatorGraphConfig() {
      node_ = java.util.Collections.emptyList();
      packetFactory_ = java.util.Collections.emptyList();
      packetGenerator_ = java.util.Collections.emptyList();
      numThreads_ = 0;
      statusHandler_ = java.util.Collections.emptyList();
      inputStream_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      outputStream_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      inputSidePacket_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      outputSidePacket_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      maxQueueSize_ = 0;
      reportDeadlock_ = false;
      executor_ = java.util.Collections.emptyList();
      package_ = "";
      type_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return com.google.protobuf.UnknownFieldSet.getDefaultInstance();
    }
    private CalculatorGraphConfig(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      int mutable_bitField0_ = 0;
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!input.skipField(tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              if (!((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
                node_ = new java.util.ArrayList<com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node>();
                mutable_bitField0_ |= 0x00000001;
              }
              node_.add(
                  input.readMessage(com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node.parser(), extensionRegistry));
              break;
            }
            case 50: {
              if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                packetFactory_ = new java.util.ArrayList<mediapipe.PacketFactory.PacketFactoryConfig>();
                mutable_bitField0_ |= 0x00000002;
              }
              packetFactory_.add(
                  input.readMessage(mediapipe.PacketFactory.PacketFactoryConfig.PARSER, extensionRegistry));
              break;
            }
            case 58: {
              if (!((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
                packetGenerator_ = new java.util.ArrayList<mediapipe.PacketGenerator.PacketGeneratorConfig>();
                mutable_bitField0_ |= 0x00000004;
              }
              packetGenerator_.add(
                  input.readMessage(mediapipe.PacketGenerator.PacketGeneratorConfig.PARSER, extensionRegistry));
              break;
            }
            case 64: {

              numThreads_ = input.readInt32();
              break;
            }
            case 74: {
              if (!((mutable_bitField0_ & 0x00000010) == 0x00000010)) {
                statusHandler_ = new java.util.ArrayList<mediapipe.StatusHandler.StatusHandlerConfig>();
                mutable_bitField0_ |= 0x00000010;
              }
              statusHandler_.add(
                  input.readMessage(mediapipe.StatusHandler.StatusHandlerConfig.PARSER, extensionRegistry));
              break;
            }
            case 82: {
              java.lang.String s = input.readStringRequireUtf8();
              if (!((mutable_bitField0_ & 0x00000020) == 0x00000020)) {
                inputStream_ = new com.google.protobuf.LazyStringArrayList();
                mutable_bitField0_ |= 0x00000020;
              }
              inputStream_.add(s);
              break;
            }
            case 88: {

              maxQueueSize_ = input.readInt32();
              break;
            }
            case 98: {
              mediapipe.StreamHandler.InputStreamHandlerConfig.Builder subBuilder = null;
              if (inputStreamHandler_ != null) {
                subBuilder = inputStreamHandler_.toBuilder();
              }
              inputStreamHandler_ = input.readMessage(mediapipe.StreamHandler.InputStreamHandlerConfig.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(inputStreamHandler_);
                inputStreamHandler_ = subBuilder.buildPartial();
              }

              break;
            }
            case 106: {
              mediapipe.StreamHandler.OutputStreamHandlerConfig.Builder subBuilder = null;
              if (outputStreamHandler_ != null) {
                subBuilder = outputStreamHandler_.toBuilder();
              }
              outputStreamHandler_ = input.readMessage(mediapipe.StreamHandler.OutputStreamHandlerConfig.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(outputStreamHandler_);
                outputStreamHandler_ = subBuilder.buildPartial();
              }

              break;
            }
            case 114: {
              if (!((mutable_bitField0_ & 0x00002000) == 0x00002000)) {
                executor_ = new java.util.ArrayList<com.google.mediapipe.proto.CalculatorProto.ExecutorConfig>();
                mutable_bitField0_ |= 0x00002000;
              }
              executor_.add(
                  input.readMessage(com.google.mediapipe.proto.CalculatorProto.ExecutorConfig.parser(), extensionRegistry));
              break;
            }
            case 122: {
              java.lang.String s = input.readStringRequireUtf8();
              if (!((mutable_bitField0_ & 0x00000040) == 0x00000040)) {
                outputStream_ = new com.google.protobuf.LazyStringArrayList();
                mutable_bitField0_ |= 0x00000040;
              }
              outputStream_.add(s);
              break;
            }
            case 130: {
              java.lang.String s = input.readStringRequireUtf8();
              if (!((mutable_bitField0_ & 0x00000080) == 0x00000080)) {
                inputSidePacket_ = new com.google.protobuf.LazyStringArrayList();
                mutable_bitField0_ |= 0x00000080;
              }
              inputSidePacket_.add(s);
              break;
            }
            case 138: {
              java.lang.String s = input.readStringRequireUtf8();
              if (!((mutable_bitField0_ & 0x00000100) == 0x00000100)) {
                outputSidePacket_ = new com.google.protobuf.LazyStringArrayList();
                mutable_bitField0_ |= 0x00000100;
              }
              outputSidePacket_.add(s);
              break;
            }
            case 146: {
              com.google.mediapipe.proto.CalculatorProto.ProfilerConfig.Builder subBuilder = null;
              if (profilerConfig_ != null) {
                subBuilder = profilerConfig_.toBuilder();
              }
              profilerConfig_ = input.readMessage(com.google.mediapipe.proto.CalculatorProto.ProfilerConfig.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(profilerConfig_);
                profilerConfig_ = subBuilder.buildPartial();
              }

              break;
            }
            case 154: {
              java.lang.String s = input.readStringRequireUtf8();

              package_ = s;
              break;
            }
            case 162: {
              java.lang.String s = input.readStringRequireUtf8();

              type_ = s;
              break;
            }
            case 168: {

              reportDeadlock_ = input.readBool();
              break;
            }
            case 8010: {
              mediapipe.MediapipeOptions.MediaPipeOptions.Builder subBuilder = null;
              if (options_ != null) {
                subBuilder = options_.toBuilder();
              }
              options_ = input.readMessage(mediapipe.MediapipeOptions.MediaPipeOptions.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(options_);
                options_ = subBuilder.buildPartial();
              }

              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
          node_ = java.util.Collections.unmodifiableList(node_);
        }
        if (((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
          packetFactory_ = java.util.Collections.unmodifiableList(packetFactory_);
        }
        if (((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
          packetGenerator_ = java.util.Collections.unmodifiableList(packetGenerator_);
        }
        if (((mutable_bitField0_ & 0x00000010) == 0x00000010)) {
          statusHandler_ = java.util.Collections.unmodifiableList(statusHandler_);
        }
        if (((mutable_bitField0_ & 0x00000020) == 0x00000020)) {
          inputStream_ = inputStream_.getUnmodifiableView();
        }
        if (((mutable_bitField0_ & 0x00002000) == 0x00002000)) {
          executor_ = java.util.Collections.unmodifiableList(executor_);
        }
        if (((mutable_bitField0_ & 0x00000040) == 0x00000040)) {
          outputStream_ = outputStream_.getUnmodifiableView();
        }
        if (((mutable_bitField0_ & 0x00000080) == 0x00000080)) {
          inputSidePacket_ = inputSidePacket_.getUnmodifiableView();
        }
        if (((mutable_bitField0_ & 0x00000100) == 0x00000100)) {
          outputSidePacket_ = outputSidePacket_.getUnmodifiableView();
        }
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.google.mediapipe.proto.CalculatorProto.internal_static_mediapipe_CalculatorGraphConfig_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.google.mediapipe.proto.CalculatorProto.internal_static_mediapipe_CalculatorGraphConfig_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.class, com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Builder.class);
    }

    public interface NodeOrBuilder extends
        // @@protoc_insertion_point(interface_extends:mediapipe.CalculatorGraphConfig.Node)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <pre>
       * The name of the node.  This field is optional and doesn't generally
       * need to be specified, but does improve error messaging.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      java.lang.String getName();
      /**
       * <pre>
       * The name of the node.  This field is optional and doesn't generally
       * need to be specified, but does improve error messaging.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      com.google.protobuf.ByteString
          getNameBytes();

      /**
       * <pre>
       * The registered type of a calculator (provided via REGISTER_CALCULATOR),
       * or of a subgraph (via REGISTER_MEDIAPIPE_GRAPH).
       * </pre>
       *
       * <code>optional string calculator = 2;</code>
       */
      java.lang.String getCalculator();
      /**
       * <pre>
       * The registered type of a calculator (provided via REGISTER_CALCULATOR),
       * or of a subgraph (via REGISTER_MEDIAPIPE_GRAPH).
       * </pre>
       *
       * <code>optional string calculator = 2;</code>
       */
      com.google.protobuf.ByteString
          getCalculatorBytes();

      /**
       * <pre>
       * String(s) representing "TAG:name" of the stream(s) from which the current
       * node will get its inputs. "TAG:" part is optional, see above.
       * A calculator with no input stream is a source.
       * </pre>
       *
       * <code>repeated string input_stream = 3;</code>
       */
      java.util.List<java.lang.String>
          getInputStreamList();
      /**
       * <pre>
       * String(s) representing "TAG:name" of the stream(s) from which the current
       * node will get its inputs. "TAG:" part is optional, see above.
       * A calculator with no input stream is a source.
       * </pre>
       *
       * <code>repeated string input_stream = 3;</code>
       */
      int getInputStreamCount();
      /**
       * <pre>
       * String(s) representing "TAG:name" of the stream(s) from which the current
       * node will get its inputs. "TAG:" part is optional, see above.
       * A calculator with no input stream is a source.
       * </pre>
       *
       * <code>repeated string input_stream = 3;</code>
       */
      java.lang.String getInputStream(int index);
      /**
       * <pre>
       * String(s) representing "TAG:name" of the stream(s) from which the current
       * node will get its inputs. "TAG:" part is optional, see above.
       * A calculator with no input stream is a source.
       * </pre>
       *
       * <code>repeated string input_stream = 3;</code>
       */
      com.google.protobuf.ByteString
          getInputStreamBytes(int index);

      /**
       * <pre>
       * String(s) representing "TAG:name" of the stream(s) produced by this node.
       * "TAG:" part is optional, see above. These must be different from any
       * other output_streams specified for other nodes in the graph.
       * </pre>
       *
       * <code>repeated string output_stream = 4;</code>
       */
      java.util.List<java.lang.String>
          getOutputStreamList();
      /**
       * <pre>
       * String(s) representing "TAG:name" of the stream(s) produced by this node.
       * "TAG:" part is optional, see above. These must be different from any
       * other output_streams specified for other nodes in the graph.
       * </pre>
       *
       * <code>repeated string output_stream = 4;</code>
       */
      int getOutputStreamCount();
      /**
       * <pre>
       * String(s) representing "TAG:name" of the stream(s) produced by this node.
       * "TAG:" part is optional, see above. These must be different from any
       * other output_streams specified for other nodes in the graph.
       * </pre>
       *
       * <code>repeated string output_stream = 4;</code>
       */
      java.lang.String getOutputStream(int index);
      /**
       * <pre>
       * String(s) representing "TAG:name" of the stream(s) produced by this node.
       * "TAG:" part is optional, see above. These must be different from any
       * other output_streams specified for other nodes in the graph.
       * </pre>
       *
       * <code>repeated string output_stream = 4;</code>
       */
      com.google.protobuf.ByteString
          getOutputStreamBytes(int index);

      /**
       * <pre>
       * String(s) representing "TAG:name" of the input side packet(s).
       * "TAG:" part is optional, see above.
       * </pre>
       *
       * <code>repeated string input_side_packet = 5;</code>
       */
      java.util.List<java.lang.String>
          getInputSidePacketList();
      /**
       * <pre>
       * String(s) representing "TAG:name" of the input side packet(s).
       * "TAG:" part is optional, see above.
       * </pre>
       *
       * <code>repeated string input_side_packet = 5;</code>
       */
      int getInputSidePacketCount();
      /**
       * <pre>
       * String(s) representing "TAG:name" of the input side packet(s).
       * "TAG:" part is optional, see above.
       * </pre>
       *
       * <code>repeated string input_side_packet = 5;</code>
       */
      java.lang.String getInputSidePacket(int index);
      /**
       * <pre>
       * String(s) representing "TAG:name" of the input side packet(s).
       * "TAG:" part is optional, see above.
       * </pre>
       *
       * <code>repeated string input_side_packet = 5;</code>
       */
      com.google.protobuf.ByteString
          getInputSidePacketBytes(int index);

      /**
       * <pre>
       * String(s) representing "TAG:name" of the output side packet(s). Only
       * used by subgraphs.
       * "TAG:" part is optional, see above.
       * </pre>
       *
       * <code>repeated string output_side_packet = 6;</code>
       */
      java.util.List<java.lang.String>
          getOutputSidePacketList();
      /**
       * <pre>
       * String(s) representing "TAG:name" of the output side packet(s). Only
       * used by subgraphs.
       * "TAG:" part is optional, see above.
       * </pre>
       *
       * <code>repeated string output_side_packet = 6;</code>
       */
      int getOutputSidePacketCount();
      /**
       * <pre>
       * String(s) representing "TAG:name" of the output side packet(s). Only
       * used by subgraphs.
       * "TAG:" part is optional, see above.
       * </pre>
       *
       * <code>repeated string output_side_packet = 6;</code>
       */
      java.lang.String getOutputSidePacket(int index);
      /**
       * <pre>
       * String(s) representing "TAG:name" of the output side packet(s). Only
       * used by subgraphs.
       * "TAG:" part is optional, see above.
       * </pre>
       *
       * <code>repeated string output_side_packet = 6;</code>
       */
      com.google.protobuf.ByteString
          getOutputSidePacketBytes(int index);

      /**
       * <pre>
       * The options passed to the Calculator, in proto2 syntax.
       * </pre>
       *
       * <code>optional .mediapipe.CalculatorOptions options = 7;</code>
       */
      boolean hasOptions();
      /**
       * <pre>
       * The options passed to the Calculator, in proto2 syntax.
       * </pre>
       *
       * <code>optional .mediapipe.CalculatorOptions options = 7;</code>
       */
      com.google.mediapipe.proto.CalculatorOptionsProto.CalculatorOptions getOptions();
      /**
       * <pre>
       * The options passed to the Calculator, in proto2 syntax.
       * </pre>
       *
       * <code>optional .mediapipe.CalculatorOptions options = 7;</code>
       */
      com.google.mediapipe.proto.CalculatorOptionsProto.CalculatorOptionsOrBuilder getOptionsOrBuilder();

      /**
       * <pre>
       * The options passed to the Calculator, in proto3 syntax.
       * Each node_options message must have a different message type.
       * If the same message type is specified in |options| and |node_options|,
       * only the message in |options| is used.
       * </pre>
       *
       * <code>repeated .google.protobuf.Any node_options = 8;</code>
       */
      java.util.List<com.google.protobuf.Any> 
          getNodeOptionsList();
      /**
       * <pre>
       * The options passed to the Calculator, in proto3 syntax.
       * Each node_options message must have a different message type.
       * If the same message type is specified in |options| and |node_options|,
       * only the message in |options| is used.
       * </pre>
       *
       * <code>repeated .google.protobuf.Any node_options = 8;</code>
       */
      com.google.protobuf.Any getNodeOptions(int index);
      /**
       * <pre>
       * The options passed to the Calculator, in proto3 syntax.
       * Each node_options message must have a different message type.
       * If the same message type is specified in |options| and |node_options|,
       * only the message in |options| is used.
       * </pre>
       *
       * <code>repeated .google.protobuf.Any node_options = 8;</code>
       */
      int getNodeOptionsCount();
      /**
       * <pre>
       * The options passed to the Calculator, in proto3 syntax.
       * Each node_options message must have a different message type.
       * If the same message type is specified in |options| and |node_options|,
       * only the message in |options| is used.
       * </pre>
       *
       * <code>repeated .google.protobuf.Any node_options = 8;</code>
       */
      java.util.List<? extends com.google.protobuf.AnyOrBuilder> 
          getNodeOptionsOrBuilderList();
      /**
       * <pre>
       * The options passed to the Calculator, in proto3 syntax.
       * Each node_options message must have a different message type.
       * If the same message type is specified in |options| and |node_options|,
       * only the message in |options| is used.
       * </pre>
       *
       * <code>repeated .google.protobuf.Any node_options = 8;</code>
       */
      com.google.protobuf.AnyOrBuilder getNodeOptionsOrBuilder(
          int index);

      /**
       * <pre>
       * For a Source Calculator (i.e. a calculator with no inputs),
       * this is the "layer" on which the calculator is executed.  For a
       * non-source calculator (i.e. a calculator with one or more input
       * streams) this field has no effect.  The sources on each layer
       * are completely exhausted before Process() is called on any source
       * calculator on a higher numbered layer.
       * Example:
       *   Decoder -&gt; Median Frame (requires all frames) -&gt; Image Subtraction
       *           ---------------------------------------&gt;
       * The entire video will be buffered on the edge from the decoder
       * to the Image subtraction.  To fix this problem, layers can be used.
       *   Decoder (layer 0) -&gt; Median Frame -&gt; Image Subtraction
       *   Decoder (layer 1) -----------------&gt;
       * The frames from layer 0 will no longer be buffered, but the video
       * will be decoded again instead.  Note, that different options can
       * be used in the second decoder.
       * </pre>
       *
       * <code>optional int32 source_layer = 9;</code>
       */
      int getSourceLayer();

      /**
       * <pre>
       * Optional parameter that allows the user to indicate to the scheduler that
       * this node has a buffering behavior (i.e. waits for a bunch of packets
       * before emitting any) and specify the size of the buffer that is built up.
       * The scheduler will then try to keep the maximum size of any input queues
       * in the graph to remain below the maximum of all buffer_size_hints and
       * max_queue_size (if specified). The ideal value is typically something
       * larger than the actual number of buffered packets to maintain pipelining.
       * The default value 0 indicates that the node has no buffering behavior.
       * </pre>
       *
       * <code>optional int32 buffer_size_hint = 10;</code>
       */
      int getBufferSizeHint();

      /**
       * <pre>
       * Config for this node's InputStreamHandler.
       * If unspecified, the graph-level input stream handler will be used.
       * </pre>
       *
       * <code>optional .mediapipe.InputStreamHandlerConfig input_stream_handler = 11;</code>
       */
      boolean hasInputStreamHandler();
      /**
       * <pre>
       * Config for this node's InputStreamHandler.
       * If unspecified, the graph-level input stream handler will be used.
       * </pre>
       *
       * <code>optional .mediapipe.InputStreamHandlerConfig input_stream_handler = 11;</code>
       */
      mediapipe.StreamHandler.InputStreamHandlerConfig getInputStreamHandler();
      /**
       * <pre>
       * Config for this node's InputStreamHandler.
       * If unspecified, the graph-level input stream handler will be used.
       * </pre>
       *
       * <code>optional .mediapipe.InputStreamHandlerConfig input_stream_handler = 11;</code>
       */
      mediapipe.StreamHandler.InputStreamHandlerConfigOrBuilder getInputStreamHandlerOrBuilder();

      /**
       * <pre>
       * Config for this node's OutputStreamHandler.
       * If unspecified, the graph-level output stream handler will be used.
       * </pre>
       *
       * <code>optional .mediapipe.OutputStreamHandlerConfig output_stream_handler = 12;</code>
       */
      boolean hasOutputStreamHandler();
      /**
       * <pre>
       * Config for this node's OutputStreamHandler.
       * If unspecified, the graph-level output stream handler will be used.
       * </pre>
       *
       * <code>optional .mediapipe.OutputStreamHandlerConfig output_stream_handler = 12;</code>
       */
      mediapipe.StreamHandler.OutputStreamHandlerConfig getOutputStreamHandler();
      /**
       * <pre>
       * Config for this node's OutputStreamHandler.
       * If unspecified, the graph-level output stream handler will be used.
       * </pre>
       *
       * <code>optional .mediapipe.OutputStreamHandlerConfig output_stream_handler = 12;</code>
       */
      mediapipe.StreamHandler.OutputStreamHandlerConfigOrBuilder getOutputStreamHandlerOrBuilder();

      /**
       * <pre>
       * Additional information about an input stream. The |name| field of the
       * InputStreamInfo must match an input_stream.
       * </pre>
       *
       * <code>repeated .mediapipe.InputStreamInfo input_stream_info = 13;</code>
       */
      java.util.List<com.google.mediapipe.proto.CalculatorProto.InputStreamInfo> 
          getInputStreamInfoList();
      /**
       * <pre>
       * Additional information about an input stream. The |name| field of the
       * InputStreamInfo must match an input_stream.
       * </pre>
       *
       * <code>repeated .mediapipe.InputStreamInfo input_stream_info = 13;</code>
       */
      com.google.mediapipe.proto.CalculatorProto.InputStreamInfo getInputStreamInfo(int index);
      /**
       * <pre>
       * Additional information about an input stream. The |name| field of the
       * InputStreamInfo must match an input_stream.
       * </pre>
       *
       * <code>repeated .mediapipe.InputStreamInfo input_stream_info = 13;</code>
       */
      int getInputStreamInfoCount();
      /**
       * <pre>
       * Additional information about an input stream. The |name| field of the
       * InputStreamInfo must match an input_stream.
       * </pre>
       *
       * <code>repeated .mediapipe.InputStreamInfo input_stream_info = 13;</code>
       */
      java.util.List<? extends com.google.mediapipe.proto.CalculatorProto.InputStreamInfoOrBuilder> 
          getInputStreamInfoOrBuilderList();
      /**
       * <pre>
       * Additional information about an input stream. The |name| field of the
       * InputStreamInfo must match an input_stream.
       * </pre>
       *
       * <code>repeated .mediapipe.InputStreamInfo input_stream_info = 13;</code>
       */
      com.google.mediapipe.proto.CalculatorProto.InputStreamInfoOrBuilder getInputStreamInfoOrBuilder(
          int index);

      /**
       * <pre>
       * Set the executor which the calculator will execute on.
       * </pre>
       *
       * <code>optional string executor = 14;</code>
       */
      java.lang.String getExecutor();
      /**
       * <pre>
       * Set the executor which the calculator will execute on.
       * </pre>
       *
       * <code>optional string executor = 14;</code>
       */
      com.google.protobuf.ByteString
          getExecutorBytes();

      /**
       * <pre>
       * TODO: Remove from Node when switched to Profiler.
       * DEPRECATED: Configs for the profiler.
       * </pre>
       *
       * <code>optional .mediapipe.ProfilerConfig profiler_config = 15 [deprecated = true];</code>
       */
      @java.lang.Deprecated boolean hasProfilerConfig();
      /**
       * <pre>
       * TODO: Remove from Node when switched to Profiler.
       * DEPRECATED: Configs for the profiler.
       * </pre>
       *
       * <code>optional .mediapipe.ProfilerConfig profiler_config = 15 [deprecated = true];</code>
       */
      @java.lang.Deprecated com.google.mediapipe.proto.CalculatorProto.ProfilerConfig getProfilerConfig();
      /**
       * <pre>
       * TODO: Remove from Node when switched to Profiler.
       * DEPRECATED: Configs for the profiler.
       * </pre>
       *
       * <code>optional .mediapipe.ProfilerConfig profiler_config = 15 [deprecated = true];</code>
       */
      @java.lang.Deprecated com.google.mediapipe.proto.CalculatorProto.ProfilerConfigOrBuilder getProfilerConfigOrBuilder();

      /**
       * <pre>
       * The maximum number of invocations that can be executed in parallel.
       * If not specified, the limit is one invocation.
       * </pre>
       *
       * <code>optional int32 max_in_flight = 16;</code>
       */
      int getMaxInFlight();

      /**
       * <pre>
       * DEPRECATED: For backwards compatibility we allow users to
       * specify the old name for "input_side_packet" in proto configs.
       * These are automatically converted to input_side_packets during
       * config canonicalization.
       * </pre>
       *
       * <code>repeated string external_input = 1005;</code>
       */
      java.util.List<java.lang.String>
          getExternalInputList();
      /**
       * <pre>
       * DEPRECATED: For backwards compatibility we allow users to
       * specify the old name for "input_side_packet" in proto configs.
       * These are automatically converted to input_side_packets during
       * config canonicalization.
       * </pre>
       *
       * <code>repeated string external_input = 1005;</code>
       */
      int getExternalInputCount();
      /**
       * <pre>
       * DEPRECATED: For backwards compatibility we allow users to
       * specify the old name for "input_side_packet" in proto configs.
       * These are automatically converted to input_side_packets during
       * config canonicalization.
       * </pre>
       *
       * <code>repeated string external_input = 1005;</code>
       */
      java.lang.String getExternalInput(int index);
      /**
       * <pre>
       * DEPRECATED: For backwards compatibility we allow users to
       * specify the old name for "input_side_packet" in proto configs.
       * These are automatically converted to input_side_packets during
       * config canonicalization.
       * </pre>
       *
       * <code>repeated string external_input = 1005;</code>
       */
      com.google.protobuf.ByteString
          getExternalInputBytes(int index);
    }
    /**
     * <pre>
     * A single node in the DAG.
     * </pre>
     *
     * Protobuf type {@code mediapipe.CalculatorGraphConfig.Node}
     */
    public  static final class Node extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:mediapipe.CalculatorGraphConfig.Node)
        NodeOrBuilder {
      // Use Node.newBuilder() to construct.
      private Node(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private Node() {
        name_ = "";
        calculator_ = "";
        inputStream_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        outputStream_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        inputSidePacket_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        outputSidePacket_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        nodeOptions_ = java.util.Collections.emptyList();
        sourceLayer_ = 0;
        bufferSizeHint_ = 0;
        inputStreamInfo_ = java.util.Collections.emptyList();
        executor_ = "";
        maxInFlight_ = 0;
        externalInput_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return com.google.protobuf.UnknownFieldSet.getDefaultInstance();
      }
      private Node(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        this();
        int mutable_bitField0_ = 0;
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              default: {
                if (!input.skipField(tag)) {
                  done = true;
                }
                break;
              }
              case 10: {
                java.lang.String s = input.readStringRequireUtf8();

                name_ = s;
                break;
              }
              case 18: {
                java.lang.String s = input.readStringRequireUtf8();

                calculator_ = s;
                break;
              }
              case 26: {
                java.lang.String s = input.readStringRequireUtf8();
                if (!((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
                  inputStream_ = new com.google.protobuf.LazyStringArrayList();
                  mutable_bitField0_ |= 0x00000004;
                }
                inputStream_.add(s);
                break;
              }
              case 34: {
                java.lang.String s = input.readStringRequireUtf8();
                if (!((mutable_bitField0_ & 0x00000008) == 0x00000008)) {
                  outputStream_ = new com.google.protobuf.LazyStringArrayList();
                  mutable_bitField0_ |= 0x00000008;
                }
                outputStream_.add(s);
                break;
              }
              case 42: {
                java.lang.String s = input.readStringRequireUtf8();
                if (!((mutable_bitField0_ & 0x00000010) == 0x00000010)) {
                  inputSidePacket_ = new com.google.protobuf.LazyStringArrayList();
                  mutable_bitField0_ |= 0x00000010;
                }
                inputSidePacket_.add(s);
                break;
              }
              case 50: {
                java.lang.String s = input.readStringRequireUtf8();
                if (!((mutable_bitField0_ & 0x00000020) == 0x00000020)) {
                  outputSidePacket_ = new com.google.protobuf.LazyStringArrayList();
                  mutable_bitField0_ |= 0x00000020;
                }
                outputSidePacket_.add(s);
                break;
              }
              case 58: {
                com.google.mediapipe.proto.CalculatorOptionsProto.CalculatorOptions.Builder subBuilder = null;
                if (options_ != null) {
                  subBuilder = options_.toBuilder();
                }
                options_ = input.readMessage(com.google.mediapipe.proto.CalculatorOptionsProto.CalculatorOptions.PARSER, extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(options_);
                  options_ = subBuilder.buildPartial();
                }

                break;
              }
              case 66: {
                if (!((mutable_bitField0_ & 0x00000080) == 0x00000080)) {
                  nodeOptions_ = new java.util.ArrayList<com.google.protobuf.Any>();
                  mutable_bitField0_ |= 0x00000080;
                }
                nodeOptions_.add(
                    input.readMessage(com.google.protobuf.Any.parser(), extensionRegistry));
                break;
              }
              case 72: {

                sourceLayer_ = input.readInt32();
                break;
              }
              case 80: {

                bufferSizeHint_ = input.readInt32();
                break;
              }
              case 90: {
                mediapipe.StreamHandler.InputStreamHandlerConfig.Builder subBuilder = null;
                if (inputStreamHandler_ != null) {
                  subBuilder = inputStreamHandler_.toBuilder();
                }
                inputStreamHandler_ = input.readMessage(mediapipe.StreamHandler.InputStreamHandlerConfig.PARSER, extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(inputStreamHandler_);
                  inputStreamHandler_ = subBuilder.buildPartial();
                }

                break;
              }
              case 98: {
                mediapipe.StreamHandler.OutputStreamHandlerConfig.Builder subBuilder = null;
                if (outputStreamHandler_ != null) {
                  subBuilder = outputStreamHandler_.toBuilder();
                }
                outputStreamHandler_ = input.readMessage(mediapipe.StreamHandler.OutputStreamHandlerConfig.PARSER, extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(outputStreamHandler_);
                  outputStreamHandler_ = subBuilder.buildPartial();
                }

                break;
              }
              case 106: {
                if (!((mutable_bitField0_ & 0x00001000) == 0x00001000)) {
                  inputStreamInfo_ = new java.util.ArrayList<com.google.mediapipe.proto.CalculatorProto.InputStreamInfo>();
                  mutable_bitField0_ |= 0x00001000;
                }
                inputStreamInfo_.add(
                    input.readMessage(com.google.mediapipe.proto.CalculatorProto.InputStreamInfo.parser(), extensionRegistry));
                break;
              }
              case 114: {
                java.lang.String s = input.readStringRequireUtf8();

                executor_ = s;
                break;
              }
              case 122: {
                com.google.mediapipe.proto.CalculatorProto.ProfilerConfig.Builder subBuilder = null;
                if (profilerConfig_ != null) {
                  subBuilder = profilerConfig_.toBuilder();
                }
                profilerConfig_ = input.readMessage(com.google.mediapipe.proto.CalculatorProto.ProfilerConfig.parser(), extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(profilerConfig_);
                  profilerConfig_ = subBuilder.buildPartial();
                }

                break;
              }
              case 128: {

                maxInFlight_ = input.readInt32();
                break;
              }
              case 8042: {
                java.lang.String s = input.readStringRequireUtf8();
                if (!((mutable_bitField0_ & 0x00010000) == 0x00010000)) {
                  externalInput_ = new com.google.protobuf.LazyStringArrayList();
                  mutable_bitField0_ |= 0x00010000;
                }
                externalInput_.add(s);
                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(this);
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(
              e).setUnfinishedMessage(this);
        } finally {
          if (((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
            inputStream_ = inputStream_.getUnmodifiableView();
          }
          if (((mutable_bitField0_ & 0x00000008) == 0x00000008)) {
            outputStream_ = outputStream_.getUnmodifiableView();
          }
          if (((mutable_bitField0_ & 0x00000010) == 0x00000010)) {
            inputSidePacket_ = inputSidePacket_.getUnmodifiableView();
          }
          if (((mutable_bitField0_ & 0x00000020) == 0x00000020)) {
            outputSidePacket_ = outputSidePacket_.getUnmodifiableView();
          }
          if (((mutable_bitField0_ & 0x00000080) == 0x00000080)) {
            nodeOptions_ = java.util.Collections.unmodifiableList(nodeOptions_);
          }
          if (((mutable_bitField0_ & 0x00001000) == 0x00001000)) {
            inputStreamInfo_ = java.util.Collections.unmodifiableList(inputStreamInfo_);
          }
          if (((mutable_bitField0_ & 0x00010000) == 0x00010000)) {
            externalInput_ = externalInput_.getUnmodifiableView();
          }
          makeExtensionsImmutable();
        }
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.google.mediapipe.proto.CalculatorProto.internal_static_mediapipe_CalculatorGraphConfig_Node_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.google.mediapipe.proto.CalculatorProto.internal_static_mediapipe_CalculatorGraphConfig_Node_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node.class, com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node.Builder.class);
      }

      private int bitField0_;
      public static final int NAME_FIELD_NUMBER = 1;
      private volatile java.lang.Object name_;
      /**
       * <pre>
       * The name of the node.  This field is optional and doesn't generally
       * need to be specified, but does improve error messaging.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (ref instanceof java.lang.String) {
          return (java.lang.String) ref;
        } else {
          com.google.protobuf.ByteString bs = 
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          name_ = s;
          return s;
        }
      }
      /**
       * <pre>
       * The name of the node.  This field is optional and doesn't generally
       * need to be specified, but does improve error messaging.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof java.lang.String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      public static final int CALCULATOR_FIELD_NUMBER = 2;
      private volatile java.lang.Object calculator_;
      /**
       * <pre>
       * The registered type of a calculator (provided via REGISTER_CALCULATOR),
       * or of a subgraph (via REGISTER_MEDIAPIPE_GRAPH).
       * </pre>
       *
       * <code>optional string calculator = 2;</code>
       */
      public java.lang.String getCalculator() {
        java.lang.Object ref = calculator_;
        if (ref instanceof java.lang.String) {
          return (java.lang.String) ref;
        } else {
          com.google.protobuf.ByteString bs = 
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          calculator_ = s;
          return s;
        }
      }
      /**
       * <pre>
       * The registered type of a calculator (provided via REGISTER_CALCULATOR),
       * or of a subgraph (via REGISTER_MEDIAPIPE_GRAPH).
       * </pre>
       *
       * <code>optional string calculator = 2;</code>
       */
      public com.google.protobuf.ByteString
          getCalculatorBytes() {
        java.lang.Object ref = calculator_;
        if (ref instanceof java.lang.String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          calculator_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      public static final int INPUT_STREAM_FIELD_NUMBER = 3;
      private com.google.protobuf.LazyStringList inputStream_;
      /**
       * <pre>
       * String(s) representing "TAG:name" of the stream(s) from which the current
       * node will get its inputs. "TAG:" part is optional, see above.
       * A calculator with no input stream is a source.
       * </pre>
       *
       * <code>repeated string input_stream = 3;</code>
       */
      public com.google.protobuf.ProtocolStringList
          getInputStreamList() {
        return inputStream_;
      }
      /**
       * <pre>
       * String(s) representing "TAG:name" of the stream(s) from which the current
       * node will get its inputs. "TAG:" part is optional, see above.
       * A calculator with no input stream is a source.
       * </pre>
       *
       * <code>repeated string input_stream = 3;</code>
       */
      public int getInputStreamCount() {
        return inputStream_.size();
      }
      /**
       * <pre>
       * String(s) representing "TAG:name" of the stream(s) from which the current
       * node will get its inputs. "TAG:" part is optional, see above.
       * A calculator with no input stream is a source.
       * </pre>
       *
       * <code>repeated string input_stream = 3;</code>
       */
      public java.lang.String getInputStream(int index) {
        return inputStream_.get(index);
      }
      /**
       * <pre>
       * String(s) representing "TAG:name" of the stream(s) from which the current
       * node will get its inputs. "TAG:" part is optional, see above.
       * A calculator with no input stream is a source.
       * </pre>
       *
       * <code>repeated string input_stream = 3;</code>
       */
      public com.google.protobuf.ByteString
          getInputStreamBytes(int index) {
        return inputStream_.getByteString(index);
      }

      public static final int OUTPUT_STREAM_FIELD_NUMBER = 4;
      private com.google.protobuf.LazyStringList outputStream_;
      /**
       * <pre>
       * String(s) representing "TAG:name" of the stream(s) produced by this node.
       * "TAG:" part is optional, see above. These must be different from any
       * other output_streams specified for other nodes in the graph.
       * </pre>
       *
       * <code>repeated string output_stream = 4;</code>
       */
      public com.google.protobuf.ProtocolStringList
          getOutputStreamList() {
        return outputStream_;
      }
      /**
       * <pre>
       * String(s) representing "TAG:name" of the stream(s) produced by this node.
       * "TAG:" part is optional, see above. These must be different from any
       * other output_streams specified for other nodes in the graph.
       * </pre>
       *
       * <code>repeated string output_stream = 4;</code>
       */
      public int getOutputStreamCount() {
        return outputStream_.size();
      }
      /**
       * <pre>
       * String(s) representing "TAG:name" of the stream(s) produced by this node.
       * "TAG:" part is optional, see above. These must be different from any
       * other output_streams specified for other nodes in the graph.
       * </pre>
       *
       * <code>repeated string output_stream = 4;</code>
       */
      public java.lang.String getOutputStream(int index) {
        return outputStream_.get(index);
      }
      /**
       * <pre>
       * String(s) representing "TAG:name" of the stream(s) produced by this node.
       * "TAG:" part is optional, see above. These must be different from any
       * other output_streams specified for other nodes in the graph.
       * </pre>
       *
       * <code>repeated string output_stream = 4;</code>
       */
      public com.google.protobuf.ByteString
          getOutputStreamBytes(int index) {
        return outputStream_.getByteString(index);
      }

      public static final int INPUT_SIDE_PACKET_FIELD_NUMBER = 5;
      private com.google.protobuf.LazyStringList inputSidePacket_;
      /**
       * <pre>
       * String(s) representing "TAG:name" of the input side packet(s).
       * "TAG:" part is optional, see above.
       * </pre>
       *
       * <code>repeated string input_side_packet = 5;</code>
       */
      public com.google.protobuf.ProtocolStringList
          getInputSidePacketList() {
        return inputSidePacket_;
      }
      /**
       * <pre>
       * String(s) representing "TAG:name" of the input side packet(s).
       * "TAG:" part is optional, see above.
       * </pre>
       *
       * <code>repeated string input_side_packet = 5;</code>
       */
      public int getInputSidePacketCount() {
        return inputSidePacket_.size();
      }
      /**
       * <pre>
       * String(s) representing "TAG:name" of the input side packet(s).
       * "TAG:" part is optional, see above.
       * </pre>
       *
       * <code>repeated string input_side_packet = 5;</code>
       */
      public java.lang.String getInputSidePacket(int index) {
        return inputSidePacket_.get(index);
      }
      /**
       * <pre>
       * String(s) representing "TAG:name" of the input side packet(s).
       * "TAG:" part is optional, see above.
       * </pre>
       *
       * <code>repeated string input_side_packet = 5;</code>
       */
      public com.google.protobuf.ByteString
          getInputSidePacketBytes(int index) {
        return inputSidePacket_.getByteString(index);
      }

      public static final int OUTPUT_SIDE_PACKET_FIELD_NUMBER = 6;
      private com.google.protobuf.LazyStringList outputSidePacket_;
      /**
       * <pre>
       * String(s) representing "TAG:name" of the output side packet(s). Only
       * used by subgraphs.
       * "TAG:" part is optional, see above.
       * </pre>
       *
       * <code>repeated string output_side_packet = 6;</code>
       */
      public com.google.protobuf.ProtocolStringList
          getOutputSidePacketList() {
        return outputSidePacket_;
      }
      /**
       * <pre>
       * String(s) representing "TAG:name" of the output side packet(s). Only
       * used by subgraphs.
       * "TAG:" part is optional, see above.
       * </pre>
       *
       * <code>repeated string output_side_packet = 6;</code>
       */
      public int getOutputSidePacketCount() {
        return outputSidePacket_.size();
      }
      /**
       * <pre>
       * String(s) representing "TAG:name" of the output side packet(s). Only
       * used by subgraphs.
       * "TAG:" part is optional, see above.
       * </pre>
       *
       * <code>repeated string output_side_packet = 6;</code>
       */
      public java.lang.String getOutputSidePacket(int index) {
        return outputSidePacket_.get(index);
      }
      /**
       * <pre>
       * String(s) representing "TAG:name" of the output side packet(s). Only
       * used by subgraphs.
       * "TAG:" part is optional, see above.
       * </pre>
       *
       * <code>repeated string output_side_packet = 6;</code>
       */
      public com.google.protobuf.ByteString
          getOutputSidePacketBytes(int index) {
        return outputSidePacket_.getByteString(index);
      }

      public static final int OPTIONS_FIELD_NUMBER = 7;
      private com.google.mediapipe.proto.CalculatorOptionsProto.CalculatorOptions options_;
      /**
       * <pre>
       * The options passed to the Calculator, in proto2 syntax.
       * </pre>
       *
       * <code>optional .mediapipe.CalculatorOptions options = 7;</code>
       */
      public boolean hasOptions() {
        return options_ != null;
      }
      /**
       * <pre>
       * The options passed to the Calculator, in proto2 syntax.
       * </pre>
       *
       * <code>optional .mediapipe.CalculatorOptions options = 7;</code>
       */
      public com.google.mediapipe.proto.CalculatorOptionsProto.CalculatorOptions getOptions() {
        return options_ == null ? com.google.mediapipe.proto.CalculatorOptionsProto.CalculatorOptions.getDefaultInstance() : options_;
      }
      /**
       * <pre>
       * The options passed to the Calculator, in proto2 syntax.
       * </pre>
       *
       * <code>optional .mediapipe.CalculatorOptions options = 7;</code>
       */
      public com.google.mediapipe.proto.CalculatorOptionsProto.CalculatorOptionsOrBuilder getOptionsOrBuilder() {
        return getOptions();
      }

      public static final int NODE_OPTIONS_FIELD_NUMBER = 8;
      private java.util.List<com.google.protobuf.Any> nodeOptions_;
      /**
       * <pre>
       * The options passed to the Calculator, in proto3 syntax.
       * Each node_options message must have a different message type.
       * If the same message type is specified in |options| and |node_options|,
       * only the message in |options| is used.
       * </pre>
       *
       * <code>repeated .google.protobuf.Any node_options = 8;</code>
       */
      public java.util.List<com.google.protobuf.Any> getNodeOptionsList() {
        return nodeOptions_;
      }
      /**
       * <pre>
       * The options passed to the Calculator, in proto3 syntax.
       * Each node_options message must have a different message type.
       * If the same message type is specified in |options| and |node_options|,
       * only the message in |options| is used.
       * </pre>
       *
       * <code>repeated .google.protobuf.Any node_options = 8;</code>
       */
      public java.util.List<? extends com.google.protobuf.AnyOrBuilder> 
          getNodeOptionsOrBuilderList() {
        return nodeOptions_;
      }
      /**
       * <pre>
       * The options passed to the Calculator, in proto3 syntax.
       * Each node_options message must have a different message type.
       * If the same message type is specified in |options| and |node_options|,
       * only the message in |options| is used.
       * </pre>
       *
       * <code>repeated .google.protobuf.Any node_options = 8;</code>
       */
      public int getNodeOptionsCount() {
        return nodeOptions_.size();
      }
      /**
       * <pre>
       * The options passed to the Calculator, in proto3 syntax.
       * Each node_options message must have a different message type.
       * If the same message type is specified in |options| and |node_options|,
       * only the message in |options| is used.
       * </pre>
       *
       * <code>repeated .google.protobuf.Any node_options = 8;</code>
       */
      public com.google.protobuf.Any getNodeOptions(int index) {
        return nodeOptions_.get(index);
      }
      /**
       * <pre>
       * The options passed to the Calculator, in proto3 syntax.
       * Each node_options message must have a different message type.
       * If the same message type is specified in |options| and |node_options|,
       * only the message in |options| is used.
       * </pre>
       *
       * <code>repeated .google.protobuf.Any node_options = 8;</code>
       */
      public com.google.protobuf.AnyOrBuilder getNodeOptionsOrBuilder(
          int index) {
        return nodeOptions_.get(index);
      }

      public static final int SOURCE_LAYER_FIELD_NUMBER = 9;
      private int sourceLayer_;
      /**
       * <pre>
       * For a Source Calculator (i.e. a calculator with no inputs),
       * this is the "layer" on which the calculator is executed.  For a
       * non-source calculator (i.e. a calculator with one or more input
       * streams) this field has no effect.  The sources on each layer
       * are completely exhausted before Process() is called on any source
       * calculator on a higher numbered layer.
       * Example:
       *   Decoder -&gt; Median Frame (requires all frames) -&gt; Image Subtraction
       *           ---------------------------------------&gt;
       * The entire video will be buffered on the edge from the decoder
       * to the Image subtraction.  To fix this problem, layers can be used.
       *   Decoder (layer 0) -&gt; Median Frame -&gt; Image Subtraction
       *   Decoder (layer 1) -----------------&gt;
       * The frames from layer 0 will no longer be buffered, but the video
       * will be decoded again instead.  Note, that different options can
       * be used in the second decoder.
       * </pre>
       *
       * <code>optional int32 source_layer = 9;</code>
       */
      public int getSourceLayer() {
        return sourceLayer_;
      }

      public static final int BUFFER_SIZE_HINT_FIELD_NUMBER = 10;
      private int bufferSizeHint_;
      /**
       * <pre>
       * Optional parameter that allows the user to indicate to the scheduler that
       * this node has a buffering behavior (i.e. waits for a bunch of packets
       * before emitting any) and specify the size of the buffer that is built up.
       * The scheduler will then try to keep the maximum size of any input queues
       * in the graph to remain below the maximum of all buffer_size_hints and
       * max_queue_size (if specified). The ideal value is typically something
       * larger than the actual number of buffered packets to maintain pipelining.
       * The default value 0 indicates that the node has no buffering behavior.
       * </pre>
       *
       * <code>optional int32 buffer_size_hint = 10;</code>
       */
      public int getBufferSizeHint() {
        return bufferSizeHint_;
      }

      public static final int INPUT_STREAM_HANDLER_FIELD_NUMBER = 11;
      private mediapipe.StreamHandler.InputStreamHandlerConfig inputStreamHandler_;
      /**
       * <pre>
       * Config for this node's InputStreamHandler.
       * If unspecified, the graph-level input stream handler will be used.
       * </pre>
       *
       * <code>optional .mediapipe.InputStreamHandlerConfig input_stream_handler = 11;</code>
       */
      public boolean hasInputStreamHandler() {
        return inputStreamHandler_ != null;
      }
      /**
       * <pre>
       * Config for this node's InputStreamHandler.
       * If unspecified, the graph-level input stream handler will be used.
       * </pre>
       *
       * <code>optional .mediapipe.InputStreamHandlerConfig input_stream_handler = 11;</code>
       */
      public mediapipe.StreamHandler.InputStreamHandlerConfig getInputStreamHandler() {
        return inputStreamHandler_ == null ? mediapipe.StreamHandler.InputStreamHandlerConfig.getDefaultInstance() : inputStreamHandler_;
      }
      /**
       * <pre>
       * Config for this node's InputStreamHandler.
       * If unspecified, the graph-level input stream handler will be used.
       * </pre>
       *
       * <code>optional .mediapipe.InputStreamHandlerConfig input_stream_handler = 11;</code>
       */
      public mediapipe.StreamHandler.InputStreamHandlerConfigOrBuilder getInputStreamHandlerOrBuilder() {
        return getInputStreamHandler();
      }

      public static final int OUTPUT_STREAM_HANDLER_FIELD_NUMBER = 12;
      private mediapipe.StreamHandler.OutputStreamHandlerConfig outputStreamHandler_;
      /**
       * <pre>
       * Config for this node's OutputStreamHandler.
       * If unspecified, the graph-level output stream handler will be used.
       * </pre>
       *
       * <code>optional .mediapipe.OutputStreamHandlerConfig output_stream_handler = 12;</code>
       */
      public boolean hasOutputStreamHandler() {
        return outputStreamHandler_ != null;
      }
      /**
       * <pre>
       * Config for this node's OutputStreamHandler.
       * If unspecified, the graph-level output stream handler will be used.
       * </pre>
       *
       * <code>optional .mediapipe.OutputStreamHandlerConfig output_stream_handler = 12;</code>
       */
      public mediapipe.StreamHandler.OutputStreamHandlerConfig getOutputStreamHandler() {
        return outputStreamHandler_ == null ? mediapipe.StreamHandler.OutputStreamHandlerConfig.getDefaultInstance() : outputStreamHandler_;
      }
      /**
       * <pre>
       * Config for this node's OutputStreamHandler.
       * If unspecified, the graph-level output stream handler will be used.
       * </pre>
       *
       * <code>optional .mediapipe.OutputStreamHandlerConfig output_stream_handler = 12;</code>
       */
      public mediapipe.StreamHandler.OutputStreamHandlerConfigOrBuilder getOutputStreamHandlerOrBuilder() {
        return getOutputStreamHandler();
      }

      public static final int INPUT_STREAM_INFO_FIELD_NUMBER = 13;
      private java.util.List<com.google.mediapipe.proto.CalculatorProto.InputStreamInfo> inputStreamInfo_;
      /**
       * <pre>
       * Additional information about an input stream. The |name| field of the
       * InputStreamInfo must match an input_stream.
       * </pre>
       *
       * <code>repeated .mediapipe.InputStreamInfo input_stream_info = 13;</code>
       */
      public java.util.List<com.google.mediapipe.proto.CalculatorProto.InputStreamInfo> getInputStreamInfoList() {
        return inputStreamInfo_;
      }
      /**
       * <pre>
       * Additional information about an input stream. The |name| field of the
       * InputStreamInfo must match an input_stream.
       * </pre>
       *
       * <code>repeated .mediapipe.InputStreamInfo input_stream_info = 13;</code>
       */
      public java.util.List<? extends com.google.mediapipe.proto.CalculatorProto.InputStreamInfoOrBuilder> 
          getInputStreamInfoOrBuilderList() {
        return inputStreamInfo_;
      }
      /**
       * <pre>
       * Additional information about an input stream. The |name| field of the
       * InputStreamInfo must match an input_stream.
       * </pre>
       *
       * <code>repeated .mediapipe.InputStreamInfo input_stream_info = 13;</code>
       */
      public int getInputStreamInfoCount() {
        return inputStreamInfo_.size();
      }
      /**
       * <pre>
       * Additional information about an input stream. The |name| field of the
       * InputStreamInfo must match an input_stream.
       * </pre>
       *
       * <code>repeated .mediapipe.InputStreamInfo input_stream_info = 13;</code>
       */
      public com.google.mediapipe.proto.CalculatorProto.InputStreamInfo getInputStreamInfo(int index) {
        return inputStreamInfo_.get(index);
      }
      /**
       * <pre>
       * Additional information about an input stream. The |name| field of the
       * InputStreamInfo must match an input_stream.
       * </pre>
       *
       * <code>repeated .mediapipe.InputStreamInfo input_stream_info = 13;</code>
       */
      public com.google.mediapipe.proto.CalculatorProto.InputStreamInfoOrBuilder getInputStreamInfoOrBuilder(
          int index) {
        return inputStreamInfo_.get(index);
      }

      public static final int EXECUTOR_FIELD_NUMBER = 14;
      private volatile java.lang.Object executor_;
      /**
       * <pre>
       * Set the executor which the calculator will execute on.
       * </pre>
       *
       * <code>optional string executor = 14;</code>
       */
      public java.lang.String getExecutor() {
        java.lang.Object ref = executor_;
        if (ref instanceof java.lang.String) {
          return (java.lang.String) ref;
        } else {
          com.google.protobuf.ByteString bs = 
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          executor_ = s;
          return s;
        }
      }
      /**
       * <pre>
       * Set the executor which the calculator will execute on.
       * </pre>
       *
       * <code>optional string executor = 14;</code>
       */
      public com.google.protobuf.ByteString
          getExecutorBytes() {
        java.lang.Object ref = executor_;
        if (ref instanceof java.lang.String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          executor_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      public static final int PROFILER_CONFIG_FIELD_NUMBER = 15;
      private com.google.mediapipe.proto.CalculatorProto.ProfilerConfig profilerConfig_;
      /**
       * <pre>
       * TODO: Remove from Node when switched to Profiler.
       * DEPRECATED: Configs for the profiler.
       * </pre>
       *
       * <code>optional .mediapipe.ProfilerConfig profiler_config = 15 [deprecated = true];</code>
       */
      @java.lang.Deprecated public boolean hasProfilerConfig() {
        return profilerConfig_ != null;
      }
      /**
       * <pre>
       * TODO: Remove from Node when switched to Profiler.
       * DEPRECATED: Configs for the profiler.
       * </pre>
       *
       * <code>optional .mediapipe.ProfilerConfig profiler_config = 15 [deprecated = true];</code>
       */
      @java.lang.Deprecated public com.google.mediapipe.proto.CalculatorProto.ProfilerConfig getProfilerConfig() {
        return profilerConfig_ == null ? com.google.mediapipe.proto.CalculatorProto.ProfilerConfig.getDefaultInstance() : profilerConfig_;
      }
      /**
       * <pre>
       * TODO: Remove from Node when switched to Profiler.
       * DEPRECATED: Configs for the profiler.
       * </pre>
       *
       * <code>optional .mediapipe.ProfilerConfig profiler_config = 15 [deprecated = true];</code>
       */
      @java.lang.Deprecated public com.google.mediapipe.proto.CalculatorProto.ProfilerConfigOrBuilder getProfilerConfigOrBuilder() {
        return getProfilerConfig();
      }

      public static final int MAX_IN_FLIGHT_FIELD_NUMBER = 16;
      private int maxInFlight_;
      /**
       * <pre>
       * The maximum number of invocations that can be executed in parallel.
       * If not specified, the limit is one invocation.
       * </pre>
       *
       * <code>optional int32 max_in_flight = 16;</code>
       */
      public int getMaxInFlight() {
        return maxInFlight_;
      }

      public static final int EXTERNAL_INPUT_FIELD_NUMBER = 1005;
      private com.google.protobuf.LazyStringList externalInput_;
      /**
       * <pre>
       * DEPRECATED: For backwards compatibility we allow users to
       * specify the old name for "input_side_packet" in proto configs.
       * These are automatically converted to input_side_packets during
       * config canonicalization.
       * </pre>
       *
       * <code>repeated string external_input = 1005;</code>
       */
      public com.google.protobuf.ProtocolStringList
          getExternalInputList() {
        return externalInput_;
      }
      /**
       * <pre>
       * DEPRECATED: For backwards compatibility we allow users to
       * specify the old name for "input_side_packet" in proto configs.
       * These are automatically converted to input_side_packets during
       * config canonicalization.
       * </pre>
       *
       * <code>repeated string external_input = 1005;</code>
       */
      public int getExternalInputCount() {
        return externalInput_.size();
      }
      /**
       * <pre>
       * DEPRECATED: For backwards compatibility we allow users to
       * specify the old name for "input_side_packet" in proto configs.
       * These are automatically converted to input_side_packets during
       * config canonicalization.
       * </pre>
       *
       * <code>repeated string external_input = 1005;</code>
       */
      public java.lang.String getExternalInput(int index) {
        return externalInput_.get(index);
      }
      /**
       * <pre>
       * DEPRECATED: For backwards compatibility we allow users to
       * specify the old name for "input_side_packet" in proto configs.
       * These are automatically converted to input_side_packets during
       * config canonicalization.
       * </pre>
       *
       * <code>repeated string external_input = 1005;</code>
       */
      public com.google.protobuf.ByteString
          getExternalInputBytes(int index) {
        return externalInput_.getByteString(index);
      }

      private byte memoizedIsInitialized = -1;
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        if (hasOptions()) {
          if (!getOptions().isInitialized()) {
            memoizedIsInitialized = 0;
            return false;
          }
        }
        if (hasInputStreamHandler()) {
          if (!getInputStreamHandler().isInitialized()) {
            memoizedIsInitialized = 0;
            return false;
          }
        }
        if (hasOutputStreamHandler()) {
          if (!getOutputStreamHandler().isInitialized()) {
            memoizedIsInitialized = 0;
            return false;
          }
        }
        memoizedIsInitialized = 1;
        return true;
      }

      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (!getNameBytes().isEmpty()) {
          com.google.protobuf.GeneratedMessageV3.writeString(output, 1, name_);
        }
        if (!getCalculatorBytes().isEmpty()) {
          com.google.protobuf.GeneratedMessageV3.writeString(output, 2, calculator_);
        }
        for (int i = 0; i < inputStream_.size(); i++) {
          com.google.protobuf.GeneratedMessageV3.writeString(output, 3, inputStream_.getRaw(i));
        }
        for (int i = 0; i < outputStream_.size(); i++) {
          com.google.protobuf.GeneratedMessageV3.writeString(output, 4, outputStream_.getRaw(i));
        }
        for (int i = 0; i < inputSidePacket_.size(); i++) {
          com.google.protobuf.GeneratedMessageV3.writeString(output, 5, inputSidePacket_.getRaw(i));
        }
        for (int i = 0; i < outputSidePacket_.size(); i++) {
          com.google.protobuf.GeneratedMessageV3.writeString(output, 6, outputSidePacket_.getRaw(i));
        }
        if (options_ != null) {
          output.writeMessage(7, getOptions());
        }
        for (int i = 0; i < nodeOptions_.size(); i++) {
          output.writeMessage(8, nodeOptions_.get(i));
        }
        if (sourceLayer_ != 0) {
          output.writeInt32(9, sourceLayer_);
        }
        if (bufferSizeHint_ != 0) {
          output.writeInt32(10, bufferSizeHint_);
        }
        if (inputStreamHandler_ != null) {
          output.writeMessage(11, getInputStreamHandler());
        }
        if (outputStreamHandler_ != null) {
          output.writeMessage(12, getOutputStreamHandler());
        }
        for (int i = 0; i < inputStreamInfo_.size(); i++) {
          output.writeMessage(13, inputStreamInfo_.get(i));
        }
        if (!getExecutorBytes().isEmpty()) {
          com.google.protobuf.GeneratedMessageV3.writeString(output, 14, executor_);
        }
        if (profilerConfig_ != null) {
          output.writeMessage(15, getProfilerConfig());
        }
        if (maxInFlight_ != 0) {
          output.writeInt32(16, maxInFlight_);
        }
        for (int i = 0; i < externalInput_.size(); i++) {
          com.google.protobuf.GeneratedMessageV3.writeString(output, 1005, externalInput_.getRaw(i));
        }
      }

      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (!getNameBytes().isEmpty()) {
          size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, name_);
        }
        if (!getCalculatorBytes().isEmpty()) {
          size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, calculator_);
        }
        {
          int dataSize = 0;
          for (int i = 0; i < inputStream_.size(); i++) {
            dataSize += computeStringSizeNoTag(inputStream_.getRaw(i));
          }
          size += dataSize;
          size += 1 * getInputStreamList().size();
        }
        {
          int dataSize = 0;
          for (int i = 0; i < outputStream_.size(); i++) {
            dataSize += computeStringSizeNoTag(outputStream_.getRaw(i));
          }
          size += dataSize;
          size += 1 * getOutputStreamList().size();
        }
        {
          int dataSize = 0;
          for (int i = 0; i < inputSidePacket_.size(); i++) {
            dataSize += computeStringSizeNoTag(inputSidePacket_.getRaw(i));
          }
          size += dataSize;
          size += 1 * getInputSidePacketList().size();
        }
        {
          int dataSize = 0;
          for (int i = 0; i < outputSidePacket_.size(); i++) {
            dataSize += computeStringSizeNoTag(outputSidePacket_.getRaw(i));
          }
          size += dataSize;
          size += 1 * getOutputSidePacketList().size();
        }
        if (options_ != null) {
          size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(7, getOptions());
        }
        for (int i = 0; i < nodeOptions_.size(); i++) {
          size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(8, nodeOptions_.get(i));
        }
        if (sourceLayer_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeInt32Size(9, sourceLayer_);
        }
        if (bufferSizeHint_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeInt32Size(10, bufferSizeHint_);
        }
        if (inputStreamHandler_ != null) {
          size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(11, getInputStreamHandler());
        }
        if (outputStreamHandler_ != null) {
          size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(12, getOutputStreamHandler());
        }
        for (int i = 0; i < inputStreamInfo_.size(); i++) {
          size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(13, inputStreamInfo_.get(i));
        }
        if (!getExecutorBytes().isEmpty()) {
          size += com.google.protobuf.GeneratedMessageV3.computeStringSize(14, executor_);
        }
        if (profilerConfig_ != null) {
          size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(15, getProfilerConfig());
        }
        if (maxInFlight_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeInt32Size(16, maxInFlight_);
        }
        {
          int dataSize = 0;
          for (int i = 0; i < externalInput_.size(); i++) {
            dataSize += computeStringSizeNoTag(externalInput_.getRaw(i));
          }
          size += dataSize;
          size += 2 * getExternalInputList().size();
        }
        memoizedSize = size;
        return size;
      }

      private static final long serialVersionUID = 0L;
      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node)) {
          return super.equals(obj);
        }
        com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node other = (com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node) obj;

        boolean result = true;
        result = result && getName()
            .equals(other.getName());
        result = result && getCalculator()
            .equals(other.getCalculator());
        result = result && getInputStreamList()
            .equals(other.getInputStreamList());
        result = result && getOutputStreamList()
            .equals(other.getOutputStreamList());
        result = result && getInputSidePacketList()
            .equals(other.getInputSidePacketList());
        result = result && getOutputSidePacketList()
            .equals(other.getOutputSidePacketList());
        result = result && (hasOptions() == other.hasOptions());
        if (hasOptions()) {
          result = result && getOptions()
              .equals(other.getOptions());
        }
        result = result && getNodeOptionsList()
            .equals(other.getNodeOptionsList());
        result = result && (getSourceLayer()
            == other.getSourceLayer());
        result = result && (getBufferSizeHint()
            == other.getBufferSizeHint());
        result = result && (hasInputStreamHandler() == other.hasInputStreamHandler());
        if (hasInputStreamHandler()) {
          result = result && getInputStreamHandler()
              .equals(other.getInputStreamHandler());
        }
        result = result && (hasOutputStreamHandler() == other.hasOutputStreamHandler());
        if (hasOutputStreamHandler()) {
          result = result && getOutputStreamHandler()
              .equals(other.getOutputStreamHandler());
        }
        result = result && getInputStreamInfoList()
            .equals(other.getInputStreamInfoList());
        result = result && getExecutor()
            .equals(other.getExecutor());
        result = result && (hasProfilerConfig() == other.hasProfilerConfig());
        if (hasProfilerConfig()) {
          result = result && getProfilerConfig()
              .equals(other.getProfilerConfig());
        }
        result = result && (getMaxInFlight()
            == other.getMaxInFlight());
        result = result && getExternalInputList()
            .equals(other.getExternalInputList());
        return result;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptorForType().hashCode();
        hash = (37 * hash) + NAME_FIELD_NUMBER;
        hash = (53 * hash) + getName().hashCode();
        hash = (37 * hash) + CALCULATOR_FIELD_NUMBER;
        hash = (53 * hash) + getCalculator().hashCode();
        if (getInputStreamCount() > 0) {
          hash = (37 * hash) + INPUT_STREAM_FIELD_NUMBER;
          hash = (53 * hash) + getInputStreamList().hashCode();
        }
        if (getOutputStreamCount() > 0) {
          hash = (37 * hash) + OUTPUT_STREAM_FIELD_NUMBER;
          hash = (53 * hash) + getOutputStreamList().hashCode();
        }
        if (getInputSidePacketCount() > 0) {
          hash = (37 * hash) + INPUT_SIDE_PACKET_FIELD_NUMBER;
          hash = (53 * hash) + getInputSidePacketList().hashCode();
        }
        if (getOutputSidePacketCount() > 0) {
          hash = (37 * hash) + OUTPUT_SIDE_PACKET_FIELD_NUMBER;
          hash = (53 * hash) + getOutputSidePacketList().hashCode();
        }
        if (hasOptions()) {
          hash = (37 * hash) + OPTIONS_FIELD_NUMBER;
          hash = (53 * hash) + getOptions().hashCode();
        }
        if (getNodeOptionsCount() > 0) {
          hash = (37 * hash) + NODE_OPTIONS_FIELD_NUMBER;
          hash = (53 * hash) + getNodeOptionsList().hashCode();
        }
        hash = (37 * hash) + SOURCE_LAYER_FIELD_NUMBER;
        hash = (53 * hash) + getSourceLayer();
        hash = (37 * hash) + BUFFER_SIZE_HINT_FIELD_NUMBER;
        hash = (53 * hash) + getBufferSizeHint();
        if (hasInputStreamHandler()) {
          hash = (37 * hash) + INPUT_STREAM_HANDLER_FIELD_NUMBER;
          hash = (53 * hash) + getInputStreamHandler().hashCode();
        }
        if (hasOutputStreamHandler()) {
          hash = (37 * hash) + OUTPUT_STREAM_HANDLER_FIELD_NUMBER;
          hash = (53 * hash) + getOutputStreamHandler().hashCode();
        }
        if (getInputStreamInfoCount() > 0) {
          hash = (37 * hash) + INPUT_STREAM_INFO_FIELD_NUMBER;
          hash = (53 * hash) + getInputStreamInfoList().hashCode();
        }
        hash = (37 * hash) + EXECUTOR_FIELD_NUMBER;
        hash = (53 * hash) + getExecutor().hashCode();
        if (hasProfilerConfig()) {
          hash = (37 * hash) + PROFILER_CONFIG_FIELD_NUMBER;
          hash = (53 * hash) + getProfilerConfig().hashCode();
        }
        hash = (37 * hash) + MAX_IN_FLIGHT_FIELD_NUMBER;
        hash = (53 * hash) + getMaxInFlight();
        if (getExternalInputCount() > 0) {
          hash = (37 * hash) + EXTERNAL_INPUT_FIELD_NUMBER;
          hash = (53 * hash) + getExternalInputList().hashCode();
        }
        hash = (29 * hash) + unknownFields.hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * <pre>
       * A single node in the DAG.
       * </pre>
       *
       * Protobuf type {@code mediapipe.CalculatorGraphConfig.Node}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:mediapipe.CalculatorGraphConfig.Node)
          com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.NodeOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return com.google.mediapipe.proto.CalculatorProto.internal_static_mediapipe_CalculatorGraphConfig_Node_descriptor;
        }

        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return com.google.mediapipe.proto.CalculatorProto.internal_static_mediapipe_CalculatorGraphConfig_Node_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node.class, com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node.Builder.class);
        }

        // Construct using com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessageV3
                  .alwaysUseFieldBuilders) {
            getNodeOptionsFieldBuilder();
            getInputStreamInfoFieldBuilder();
          }
        }
        public Builder clear() {
          super.clear();
          name_ = "";

          calculator_ = "";

          inputStream_ = com.google.protobuf.LazyStringArrayList.EMPTY;
          bitField0_ = (bitField0_ & ~0x00000004);
          outputStream_ = com.google.protobuf.LazyStringArrayList.EMPTY;
          bitField0_ = (bitField0_ & ~0x00000008);
          inputSidePacket_ = com.google.protobuf.LazyStringArrayList.EMPTY;
          bitField0_ = (bitField0_ & ~0x00000010);
          outputSidePacket_ = com.google.protobuf.LazyStringArrayList.EMPTY;
          bitField0_ = (bitField0_ & ~0x00000020);
          if (optionsBuilder_ == null) {
            options_ = null;
          } else {
            options_ = null;
            optionsBuilder_ = null;
          }
          if (nodeOptionsBuilder_ == null) {
            nodeOptions_ = java.util.Collections.emptyList();
            bitField0_ = (bitField0_ & ~0x00000080);
          } else {
            nodeOptionsBuilder_.clear();
          }
          sourceLayer_ = 0;

          bufferSizeHint_ = 0;

          if (inputStreamHandlerBuilder_ == null) {
            inputStreamHandler_ = null;
          } else {
            inputStreamHandler_ = null;
            inputStreamHandlerBuilder_ = null;
          }
          if (outputStreamHandlerBuilder_ == null) {
            outputStreamHandler_ = null;
          } else {
            outputStreamHandler_ = null;
            outputStreamHandlerBuilder_ = null;
          }
          if (inputStreamInfoBuilder_ == null) {
            inputStreamInfo_ = java.util.Collections.emptyList();
            bitField0_ = (bitField0_ & ~0x00001000);
          } else {
            inputStreamInfoBuilder_.clear();
          }
          executor_ = "";

          if (profilerConfigBuilder_ == null) {
            profilerConfig_ = null;
          } else {
            profilerConfig_ = null;
            profilerConfigBuilder_ = null;
          }
          maxInFlight_ = 0;

          externalInput_ = com.google.protobuf.LazyStringArrayList.EMPTY;
          bitField0_ = (bitField0_ & ~0x00010000);
          return this;
        }

        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return com.google.mediapipe.proto.CalculatorProto.internal_static_mediapipe_CalculatorGraphConfig_Node_descriptor;
        }

        public com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node getDefaultInstanceForType() {
          return com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node.getDefaultInstance();
        }

        public com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node build() {
          com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        public com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node buildPartial() {
          com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node result = new com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node(this);
          int from_bitField0_ = bitField0_;
          int to_bitField0_ = 0;
          result.name_ = name_;
          result.calculator_ = calculator_;
          if (((bitField0_ & 0x00000004) == 0x00000004)) {
            inputStream_ = inputStream_.getUnmodifiableView();
            bitField0_ = (bitField0_ & ~0x00000004);
          }
          result.inputStream_ = inputStream_;
          if (((bitField0_ & 0x00000008) == 0x00000008)) {
            outputStream_ = outputStream_.getUnmodifiableView();
            bitField0_ = (bitField0_ & ~0x00000008);
          }
          result.outputStream_ = outputStream_;
          if (((bitField0_ & 0x00000010) == 0x00000010)) {
            inputSidePacket_ = inputSidePacket_.getUnmodifiableView();
            bitField0_ = (bitField0_ & ~0x00000010);
          }
          result.inputSidePacket_ = inputSidePacket_;
          if (((bitField0_ & 0x00000020) == 0x00000020)) {
            outputSidePacket_ = outputSidePacket_.getUnmodifiableView();
            bitField0_ = (bitField0_ & ~0x00000020);
          }
          result.outputSidePacket_ = outputSidePacket_;
          if (optionsBuilder_ == null) {
            result.options_ = options_;
          } else {
            result.options_ = optionsBuilder_.build();
          }
          if (nodeOptionsBuilder_ == null) {
            if (((bitField0_ & 0x00000080) == 0x00000080)) {
              nodeOptions_ = java.util.Collections.unmodifiableList(nodeOptions_);
              bitField0_ = (bitField0_ & ~0x00000080);
            }
            result.nodeOptions_ = nodeOptions_;
          } else {
            result.nodeOptions_ = nodeOptionsBuilder_.build();
          }
          result.sourceLayer_ = sourceLayer_;
          result.bufferSizeHint_ = bufferSizeHint_;
          if (inputStreamHandlerBuilder_ == null) {
            result.inputStreamHandler_ = inputStreamHandler_;
          } else {
            result.inputStreamHandler_ = inputStreamHandlerBuilder_.build();
          }
          if (outputStreamHandlerBuilder_ == null) {
            result.outputStreamHandler_ = outputStreamHandler_;
          } else {
            result.outputStreamHandler_ = outputStreamHandlerBuilder_.build();
          }
          if (inputStreamInfoBuilder_ == null) {
            if (((bitField0_ & 0x00001000) == 0x00001000)) {
              inputStreamInfo_ = java.util.Collections.unmodifiableList(inputStreamInfo_);
              bitField0_ = (bitField0_ & ~0x00001000);
            }
            result.inputStreamInfo_ = inputStreamInfo_;
          } else {
            result.inputStreamInfo_ = inputStreamInfoBuilder_.build();
          }
          result.executor_ = executor_;
          if (profilerConfigBuilder_ == null) {
            result.profilerConfig_ = profilerConfig_;
          } else {
            result.profilerConfig_ = profilerConfigBuilder_.build();
          }
          result.maxInFlight_ = maxInFlight_;
          if (((bitField0_ & 0x00010000) == 0x00010000)) {
            externalInput_ = externalInput_.getUnmodifiableView();
            bitField0_ = (bitField0_ & ~0x00010000);
          }
          result.externalInput_ = externalInput_;
          result.bitField0_ = to_bitField0_;
          onBuilt();
          return result;
        }

        public Builder clone() {
          return (Builder) super.clone();
        }
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            Object value) {
          return (Builder) super.setField(field, value);
        }
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return (Builder) super.clearField(field);
        }
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return (Builder) super.clearOneof(oneof);
        }
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, Object value) {
          return (Builder) super.setRepeatedField(field, index, value);
        }
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            Object value) {
          return (Builder) super.addRepeatedField(field, value);
        }
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node) {
            return mergeFrom((com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node other) {
          if (other == com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node.getDefaultInstance()) return this;
          if (!other.getName().isEmpty()) {
            name_ = other.name_;
            onChanged();
          }
          if (!other.getCalculator().isEmpty()) {
            calculator_ = other.calculator_;
            onChanged();
          }
          if (!other.inputStream_.isEmpty()) {
            if (inputStream_.isEmpty()) {
              inputStream_ = other.inputStream_;
              bitField0_ = (bitField0_ & ~0x00000004);
            } else {
              ensureInputStreamIsMutable();
              inputStream_.addAll(other.inputStream_);
            }
            onChanged();
          }
          if (!other.outputStream_.isEmpty()) {
            if (outputStream_.isEmpty()) {
              outputStream_ = other.outputStream_;
              bitField0_ = (bitField0_ & ~0x00000008);
            } else {
              ensureOutputStreamIsMutable();
              outputStream_.addAll(other.outputStream_);
            }
            onChanged();
          }
          if (!other.inputSidePacket_.isEmpty()) {
            if (inputSidePacket_.isEmpty()) {
              inputSidePacket_ = other.inputSidePacket_;
              bitField0_ = (bitField0_ & ~0x00000010);
            } else {
              ensureInputSidePacketIsMutable();
              inputSidePacket_.addAll(other.inputSidePacket_);
            }
            onChanged();
          }
          if (!other.outputSidePacket_.isEmpty()) {
            if (outputSidePacket_.isEmpty()) {
              outputSidePacket_ = other.outputSidePacket_;
              bitField0_ = (bitField0_ & ~0x00000020);
            } else {
              ensureOutputSidePacketIsMutable();
              outputSidePacket_.addAll(other.outputSidePacket_);
            }
            onChanged();
          }
          if (other.hasOptions()) {
            mergeOptions(other.getOptions());
          }
          if (nodeOptionsBuilder_ == null) {
            if (!other.nodeOptions_.isEmpty()) {
              if (nodeOptions_.isEmpty()) {
                nodeOptions_ = other.nodeOptions_;
                bitField0_ = (bitField0_ & ~0x00000080);
              } else {
                ensureNodeOptionsIsMutable();
                nodeOptions_.addAll(other.nodeOptions_);
              }
              onChanged();
            }
          } else {
            if (!other.nodeOptions_.isEmpty()) {
              if (nodeOptionsBuilder_.isEmpty()) {
                nodeOptionsBuilder_.dispose();
                nodeOptionsBuilder_ = null;
                nodeOptions_ = other.nodeOptions_;
                bitField0_ = (bitField0_ & ~0x00000080);
                nodeOptionsBuilder_ = 
                  com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                     getNodeOptionsFieldBuilder() : null;
              } else {
                nodeOptionsBuilder_.addAllMessages(other.nodeOptions_);
              }
            }
          }
          if (other.getSourceLayer() != 0) {
            setSourceLayer(other.getSourceLayer());
          }
          if (other.getBufferSizeHint() != 0) {
            setBufferSizeHint(other.getBufferSizeHint());
          }
          if (other.hasInputStreamHandler()) {
            mergeInputStreamHandler(other.getInputStreamHandler());
          }
          if (other.hasOutputStreamHandler()) {
            mergeOutputStreamHandler(other.getOutputStreamHandler());
          }
          if (inputStreamInfoBuilder_ == null) {
            if (!other.inputStreamInfo_.isEmpty()) {
              if (inputStreamInfo_.isEmpty()) {
                inputStreamInfo_ = other.inputStreamInfo_;
                bitField0_ = (bitField0_ & ~0x00001000);
              } else {
                ensureInputStreamInfoIsMutable();
                inputStreamInfo_.addAll(other.inputStreamInfo_);
              }
              onChanged();
            }
          } else {
            if (!other.inputStreamInfo_.isEmpty()) {
              if (inputStreamInfoBuilder_.isEmpty()) {
                inputStreamInfoBuilder_.dispose();
                inputStreamInfoBuilder_ = null;
                inputStreamInfo_ = other.inputStreamInfo_;
                bitField0_ = (bitField0_ & ~0x00001000);
                inputStreamInfoBuilder_ = 
                  com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                     getInputStreamInfoFieldBuilder() : null;
              } else {
                inputStreamInfoBuilder_.addAllMessages(other.inputStreamInfo_);
              }
            }
          }
          if (!other.getExecutor().isEmpty()) {
            executor_ = other.executor_;
            onChanged();
          }
          if (other.hasProfilerConfig()) {
            mergeProfilerConfig(other.getProfilerConfig());
          }
          if (other.getMaxInFlight() != 0) {
            setMaxInFlight(other.getMaxInFlight());
          }
          if (!other.externalInput_.isEmpty()) {
            if (externalInput_.isEmpty()) {
              externalInput_ = other.externalInput_;
              bitField0_ = (bitField0_ & ~0x00010000);
            } else {
              ensureExternalInputIsMutable();
              externalInput_.addAll(other.externalInput_);
            }
            onChanged();
          }
          onChanged();
          return this;
        }

        public final boolean isInitialized() {
          if (hasOptions()) {
            if (!getOptions().isInitialized()) {
              return false;
            }
          }
          if (hasInputStreamHandler()) {
            if (!getInputStreamHandler().isInitialized()) {
              return false;
            }
          }
          if (hasOutputStreamHandler()) {
            if (!getOutputStreamHandler().isInitialized()) {
              return false;
            }
          }
          return true;
        }

        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node parsedMessage = null;
          try {
            parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            parsedMessage = (com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node) e.getUnfinishedMessage();
            throw e.unwrapIOException();
          } finally {
            if (parsedMessage != null) {
              mergeFrom(parsedMessage);
            }
          }
          return this;
        }
        private int bitField0_;

        private java.lang.Object name_ = "";
        /**
         * <pre>
         * The name of the node.  This field is optional and doesn't generally
         * need to be specified, but does improve error messaging.
         * </pre>
         *
         * <code>optional string name = 1;</code>
         */
        public java.lang.String getName() {
          java.lang.Object ref = name_;
          if (!(ref instanceof java.lang.String)) {
            com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
            java.lang.String s = bs.toStringUtf8();
            name_ = s;
            return s;
          } else {
            return (java.lang.String) ref;
          }
        }
        /**
         * <pre>
         * The name of the node.  This field is optional and doesn't generally
         * need to be specified, but does improve error messaging.
         * </pre>
         *
         * <code>optional string name = 1;</code>
         */
        public com.google.protobuf.ByteString
            getNameBytes() {
          java.lang.Object ref = name_;
          if (ref instanceof String) {
            com.google.protobuf.ByteString b = 
                com.google.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            name_ = b;
            return b;
          } else {
            return (com.google.protobuf.ByteString) ref;
          }
        }
        /**
         * <pre>
         * The name of the node.  This field is optional and doesn't generally
         * need to be specified, but does improve error messaging.
         * </pre>
         *
         * <code>optional string name = 1;</code>
         */
        public Builder setName(
            java.lang.String value) {
          if (value == null) {
    throw new NullPointerException();
  }
  
          name_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The name of the node.  This field is optional and doesn't generally
         * need to be specified, but does improve error messaging.
         * </pre>
         *
         * <code>optional string name = 1;</code>
         */
        public Builder clearName() {
          
          name_ = getDefaultInstance().getName();
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The name of the node.  This field is optional and doesn't generally
         * need to be specified, but does improve error messaging.
         * </pre>
         *
         * <code>optional string name = 1;</code>
         */
        public Builder setNameBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
          
          name_ = value;
          onChanged();
          return this;
        }

        private java.lang.Object calculator_ = "";
        /**
         * <pre>
         * The registered type of a calculator (provided via REGISTER_CALCULATOR),
         * or of a subgraph (via REGISTER_MEDIAPIPE_GRAPH).
         * </pre>
         *
         * <code>optional string calculator = 2;</code>
         */
        public java.lang.String getCalculator() {
          java.lang.Object ref = calculator_;
          if (!(ref instanceof java.lang.String)) {
            com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
            java.lang.String s = bs.toStringUtf8();
            calculator_ = s;
            return s;
          } else {
            return (java.lang.String) ref;
          }
        }
        /**
         * <pre>
         * The registered type of a calculator (provided via REGISTER_CALCULATOR),
         * or of a subgraph (via REGISTER_MEDIAPIPE_GRAPH).
         * </pre>
         *
         * <code>optional string calculator = 2;</code>
         */
        public com.google.protobuf.ByteString
            getCalculatorBytes() {
          java.lang.Object ref = calculator_;
          if (ref instanceof String) {
            com.google.protobuf.ByteString b = 
                com.google.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            calculator_ = b;
            return b;
          } else {
            return (com.google.protobuf.ByteString) ref;
          }
        }
        /**
         * <pre>
         * The registered type of a calculator (provided via REGISTER_CALCULATOR),
         * or of a subgraph (via REGISTER_MEDIAPIPE_GRAPH).
         * </pre>
         *
         * <code>optional string calculator = 2;</code>
         */
        public Builder setCalculator(
            java.lang.String value) {
          if (value == null) {
    throw new NullPointerException();
  }
  
          calculator_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The registered type of a calculator (provided via REGISTER_CALCULATOR),
         * or of a subgraph (via REGISTER_MEDIAPIPE_GRAPH).
         * </pre>
         *
         * <code>optional string calculator = 2;</code>
         */
        public Builder clearCalculator() {
          
          calculator_ = getDefaultInstance().getCalculator();
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The registered type of a calculator (provided via REGISTER_CALCULATOR),
         * or of a subgraph (via REGISTER_MEDIAPIPE_GRAPH).
         * </pre>
         *
         * <code>optional string calculator = 2;</code>
         */
        public Builder setCalculatorBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
          
          calculator_ = value;
          onChanged();
          return this;
        }

        private com.google.protobuf.LazyStringList inputStream_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        private void ensureInputStreamIsMutable() {
          if (!((bitField0_ & 0x00000004) == 0x00000004)) {
            inputStream_ = new com.google.protobuf.LazyStringArrayList(inputStream_);
            bitField0_ |= 0x00000004;
           }
        }
        /**
         * <pre>
         * String(s) representing "TAG:name" of the stream(s) from which the current
         * node will get its inputs. "TAG:" part is optional, see above.
         * A calculator with no input stream is a source.
         * </pre>
         *
         * <code>repeated string input_stream = 3;</code>
         */
        public com.google.protobuf.ProtocolStringList
            getInputStreamList() {
          return inputStream_.getUnmodifiableView();
        }
        /**
         * <pre>
         * String(s) representing "TAG:name" of the stream(s) from which the current
         * node will get its inputs. "TAG:" part is optional, see above.
         * A calculator with no input stream is a source.
         * </pre>
         *
         * <code>repeated string input_stream = 3;</code>
         */
        public int getInputStreamCount() {
          return inputStream_.size();
        }
        /**
         * <pre>
         * String(s) representing "TAG:name" of the stream(s) from which the current
         * node will get its inputs. "TAG:" part is optional, see above.
         * A calculator with no input stream is a source.
         * </pre>
         *
         * <code>repeated string input_stream = 3;</code>
         */
        public java.lang.String getInputStream(int index) {
          return inputStream_.get(index);
        }
        /**
         * <pre>
         * String(s) representing "TAG:name" of the stream(s) from which the current
         * node will get its inputs. "TAG:" part is optional, see above.
         * A calculator with no input stream is a source.
         * </pre>
         *
         * <code>repeated string input_stream = 3;</code>
         */
        public com.google.protobuf.ByteString
            getInputStreamBytes(int index) {
          return inputStream_.getByteString(index);
        }
        /**
         * <pre>
         * String(s) representing "TAG:name" of the stream(s) from which the current
         * node will get its inputs. "TAG:" part is optional, see above.
         * A calculator with no input stream is a source.
         * </pre>
         *
         * <code>repeated string input_stream = 3;</code>
         */
        public Builder setInputStream(
            int index, java.lang.String value) {
          if (value == null) {
    throw new NullPointerException();
  }
  ensureInputStreamIsMutable();
          inputStream_.set(index, value);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * String(s) representing "TAG:name" of the stream(s) from which the current
         * node will get its inputs. "TAG:" part is optional, see above.
         * A calculator with no input stream is a source.
         * </pre>
         *
         * <code>repeated string input_stream = 3;</code>
         */
        public Builder addInputStream(
            java.lang.String value) {
          if (value == null) {
    throw new NullPointerException();
  }
  ensureInputStreamIsMutable();
          inputStream_.add(value);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * String(s) representing "TAG:name" of the stream(s) from which the current
         * node will get its inputs. "TAG:" part is optional, see above.
         * A calculator with no input stream is a source.
         * </pre>
         *
         * <code>repeated string input_stream = 3;</code>
         */
        public Builder addAllInputStream(
            java.lang.Iterable<java.lang.String> values) {
          ensureInputStreamIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, inputStream_);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * String(s) representing "TAG:name" of the stream(s) from which the current
         * node will get its inputs. "TAG:" part is optional, see above.
         * A calculator with no input stream is a source.
         * </pre>
         *
         * <code>repeated string input_stream = 3;</code>
         */
        public Builder clearInputStream() {
          inputStream_ = com.google.protobuf.LazyStringArrayList.EMPTY;
          bitField0_ = (bitField0_ & ~0x00000004);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * String(s) representing "TAG:name" of the stream(s) from which the current
         * node will get its inputs. "TAG:" part is optional, see above.
         * A calculator with no input stream is a source.
         * </pre>
         *
         * <code>repeated string input_stream = 3;</code>
         */
        public Builder addInputStreamBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
          ensureInputStreamIsMutable();
          inputStream_.add(value);
          onChanged();
          return this;
        }

        private com.google.protobuf.LazyStringList outputStream_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        private void ensureOutputStreamIsMutable() {
          if (!((bitField0_ & 0x00000008) == 0x00000008)) {
            outputStream_ = new com.google.protobuf.LazyStringArrayList(outputStream_);
            bitField0_ |= 0x00000008;
           }
        }
        /**
         * <pre>
         * String(s) representing "TAG:name" of the stream(s) produced by this node.
         * "TAG:" part is optional, see above. These must be different from any
         * other output_streams specified for other nodes in the graph.
         * </pre>
         *
         * <code>repeated string output_stream = 4;</code>
         */
        public com.google.protobuf.ProtocolStringList
            getOutputStreamList() {
          return outputStream_.getUnmodifiableView();
        }
        /**
         * <pre>
         * String(s) representing "TAG:name" of the stream(s) produced by this node.
         * "TAG:" part is optional, see above. These must be different from any
         * other output_streams specified for other nodes in the graph.
         * </pre>
         *
         * <code>repeated string output_stream = 4;</code>
         */
        public int getOutputStreamCount() {
          return outputStream_.size();
        }
        /**
         * <pre>
         * String(s) representing "TAG:name" of the stream(s) produced by this node.
         * "TAG:" part is optional, see above. These must be different from any
         * other output_streams specified for other nodes in the graph.
         * </pre>
         *
         * <code>repeated string output_stream = 4;</code>
         */
        public java.lang.String getOutputStream(int index) {
          return outputStream_.get(index);
        }
        /**
         * <pre>
         * String(s) representing "TAG:name" of the stream(s) produced by this node.
         * "TAG:" part is optional, see above. These must be different from any
         * other output_streams specified for other nodes in the graph.
         * </pre>
         *
         * <code>repeated string output_stream = 4;</code>
         */
        public com.google.protobuf.ByteString
            getOutputStreamBytes(int index) {
          return outputStream_.getByteString(index);
        }
        /**
         * <pre>
         * String(s) representing "TAG:name" of the stream(s) produced by this node.
         * "TAG:" part is optional, see above. These must be different from any
         * other output_streams specified for other nodes in the graph.
         * </pre>
         *
         * <code>repeated string output_stream = 4;</code>
         */
        public Builder setOutputStream(
            int index, java.lang.String value) {
          if (value == null) {
    throw new NullPointerException();
  }
  ensureOutputStreamIsMutable();
          outputStream_.set(index, value);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * String(s) representing "TAG:name" of the stream(s) produced by this node.
         * "TAG:" part is optional, see above. These must be different from any
         * other output_streams specified for other nodes in the graph.
         * </pre>
         *
         * <code>repeated string output_stream = 4;</code>
         */
        public Builder addOutputStream(
            java.lang.String value) {
          if (value == null) {
    throw new NullPointerException();
  }
  ensureOutputStreamIsMutable();
          outputStream_.add(value);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * String(s) representing "TAG:name" of the stream(s) produced by this node.
         * "TAG:" part is optional, see above. These must be different from any
         * other output_streams specified for other nodes in the graph.
         * </pre>
         *
         * <code>repeated string output_stream = 4;</code>
         */
        public Builder addAllOutputStream(
            java.lang.Iterable<java.lang.String> values) {
          ensureOutputStreamIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, outputStream_);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * String(s) representing "TAG:name" of the stream(s) produced by this node.
         * "TAG:" part is optional, see above. These must be different from any
         * other output_streams specified for other nodes in the graph.
         * </pre>
         *
         * <code>repeated string output_stream = 4;</code>
         */
        public Builder clearOutputStream() {
          outputStream_ = com.google.protobuf.LazyStringArrayList.EMPTY;
          bitField0_ = (bitField0_ & ~0x00000008);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * String(s) representing "TAG:name" of the stream(s) produced by this node.
         * "TAG:" part is optional, see above. These must be different from any
         * other output_streams specified for other nodes in the graph.
         * </pre>
         *
         * <code>repeated string output_stream = 4;</code>
         */
        public Builder addOutputStreamBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
          ensureOutputStreamIsMutable();
          outputStream_.add(value);
          onChanged();
          return this;
        }

        private com.google.protobuf.LazyStringList inputSidePacket_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        private void ensureInputSidePacketIsMutable() {
          if (!((bitField0_ & 0x00000010) == 0x00000010)) {
            inputSidePacket_ = new com.google.protobuf.LazyStringArrayList(inputSidePacket_);
            bitField0_ |= 0x00000010;
           }
        }
        /**
         * <pre>
         * String(s) representing "TAG:name" of the input side packet(s).
         * "TAG:" part is optional, see above.
         * </pre>
         *
         * <code>repeated string input_side_packet = 5;</code>
         */
        public com.google.protobuf.ProtocolStringList
            getInputSidePacketList() {
          return inputSidePacket_.getUnmodifiableView();
        }
        /**
         * <pre>
         * String(s) representing "TAG:name" of the input side packet(s).
         * "TAG:" part is optional, see above.
         * </pre>
         *
         * <code>repeated string input_side_packet = 5;</code>
         */
        public int getInputSidePacketCount() {
          return inputSidePacket_.size();
        }
        /**
         * <pre>
         * String(s) representing "TAG:name" of the input side packet(s).
         * "TAG:" part is optional, see above.
         * </pre>
         *
         * <code>repeated string input_side_packet = 5;</code>
         */
        public java.lang.String getInputSidePacket(int index) {
          return inputSidePacket_.get(index);
        }
        /**
         * <pre>
         * String(s) representing "TAG:name" of the input side packet(s).
         * "TAG:" part is optional, see above.
         * </pre>
         *
         * <code>repeated string input_side_packet = 5;</code>
         */
        public com.google.protobuf.ByteString
            getInputSidePacketBytes(int index) {
          return inputSidePacket_.getByteString(index);
        }
        /**
         * <pre>
         * String(s) representing "TAG:name" of the input side packet(s).
         * "TAG:" part is optional, see above.
         * </pre>
         *
         * <code>repeated string input_side_packet = 5;</code>
         */
        public Builder setInputSidePacket(
            int index, java.lang.String value) {
          if (value == null) {
    throw new NullPointerException();
  }
  ensureInputSidePacketIsMutable();
          inputSidePacket_.set(index, value);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * String(s) representing "TAG:name" of the input side packet(s).
         * "TAG:" part is optional, see above.
         * </pre>
         *
         * <code>repeated string input_side_packet = 5;</code>
         */
        public Builder addInputSidePacket(
            java.lang.String value) {
          if (value == null) {
    throw new NullPointerException();
  }
  ensureInputSidePacketIsMutable();
          inputSidePacket_.add(value);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * String(s) representing "TAG:name" of the input side packet(s).
         * "TAG:" part is optional, see above.
         * </pre>
         *
         * <code>repeated string input_side_packet = 5;</code>
         */
        public Builder addAllInputSidePacket(
            java.lang.Iterable<java.lang.String> values) {
          ensureInputSidePacketIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, inputSidePacket_);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * String(s) representing "TAG:name" of the input side packet(s).
         * "TAG:" part is optional, see above.
         * </pre>
         *
         * <code>repeated string input_side_packet = 5;</code>
         */
        public Builder clearInputSidePacket() {
          inputSidePacket_ = com.google.protobuf.LazyStringArrayList.EMPTY;
          bitField0_ = (bitField0_ & ~0x00000010);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * String(s) representing "TAG:name" of the input side packet(s).
         * "TAG:" part is optional, see above.
         * </pre>
         *
         * <code>repeated string input_side_packet = 5;</code>
         */
        public Builder addInputSidePacketBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
          ensureInputSidePacketIsMutable();
          inputSidePacket_.add(value);
          onChanged();
          return this;
        }

        private com.google.protobuf.LazyStringList outputSidePacket_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        private void ensureOutputSidePacketIsMutable() {
          if (!((bitField0_ & 0x00000020) == 0x00000020)) {
            outputSidePacket_ = new com.google.protobuf.LazyStringArrayList(outputSidePacket_);
            bitField0_ |= 0x00000020;
           }
        }
        /**
         * <pre>
         * String(s) representing "TAG:name" of the output side packet(s). Only
         * used by subgraphs.
         * "TAG:" part is optional, see above.
         * </pre>
         *
         * <code>repeated string output_side_packet = 6;</code>
         */
        public com.google.protobuf.ProtocolStringList
            getOutputSidePacketList() {
          return outputSidePacket_.getUnmodifiableView();
        }
        /**
         * <pre>
         * String(s) representing "TAG:name" of the output side packet(s). Only
         * used by subgraphs.
         * "TAG:" part is optional, see above.
         * </pre>
         *
         * <code>repeated string output_side_packet = 6;</code>
         */
        public int getOutputSidePacketCount() {
          return outputSidePacket_.size();
        }
        /**
         * <pre>
         * String(s) representing "TAG:name" of the output side packet(s). Only
         * used by subgraphs.
         * "TAG:" part is optional, see above.
         * </pre>
         *
         * <code>repeated string output_side_packet = 6;</code>
         */
        public java.lang.String getOutputSidePacket(int index) {
          return outputSidePacket_.get(index);
        }
        /**
         * <pre>
         * String(s) representing "TAG:name" of the output side packet(s). Only
         * used by subgraphs.
         * "TAG:" part is optional, see above.
         * </pre>
         *
         * <code>repeated string output_side_packet = 6;</code>
         */
        public com.google.protobuf.ByteString
            getOutputSidePacketBytes(int index) {
          return outputSidePacket_.getByteString(index);
        }
        /**
         * <pre>
         * String(s) representing "TAG:name" of the output side packet(s). Only
         * used by subgraphs.
         * "TAG:" part is optional, see above.
         * </pre>
         *
         * <code>repeated string output_side_packet = 6;</code>
         */
        public Builder setOutputSidePacket(
            int index, java.lang.String value) {
          if (value == null) {
    throw new NullPointerException();
  }
  ensureOutputSidePacketIsMutable();
          outputSidePacket_.set(index, value);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * String(s) representing "TAG:name" of the output side packet(s). Only
         * used by subgraphs.
         * "TAG:" part is optional, see above.
         * </pre>
         *
         * <code>repeated string output_side_packet = 6;</code>
         */
        public Builder addOutputSidePacket(
            java.lang.String value) {
          if (value == null) {
    throw new NullPointerException();
  }
  ensureOutputSidePacketIsMutable();
          outputSidePacket_.add(value);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * String(s) representing "TAG:name" of the output side packet(s). Only
         * used by subgraphs.
         * "TAG:" part is optional, see above.
         * </pre>
         *
         * <code>repeated string output_side_packet = 6;</code>
         */
        public Builder addAllOutputSidePacket(
            java.lang.Iterable<java.lang.String> values) {
          ensureOutputSidePacketIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, outputSidePacket_);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * String(s) representing "TAG:name" of the output side packet(s). Only
         * used by subgraphs.
         * "TAG:" part is optional, see above.
         * </pre>
         *
         * <code>repeated string output_side_packet = 6;</code>
         */
        public Builder clearOutputSidePacket() {
          outputSidePacket_ = com.google.protobuf.LazyStringArrayList.EMPTY;
          bitField0_ = (bitField0_ & ~0x00000020);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * String(s) representing "TAG:name" of the output side packet(s). Only
         * used by subgraphs.
         * "TAG:" part is optional, see above.
         * </pre>
         *
         * <code>repeated string output_side_packet = 6;</code>
         */
        public Builder addOutputSidePacketBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
          ensureOutputSidePacketIsMutable();
          outputSidePacket_.add(value);
          onChanged();
          return this;
        }

        private com.google.mediapipe.proto.CalculatorOptionsProto.CalculatorOptions options_ = null;
        private com.google.protobuf.SingleFieldBuilderV3<
            com.google.mediapipe.proto.CalculatorOptionsProto.CalculatorOptions, com.google.mediapipe.proto.CalculatorOptionsProto.CalculatorOptions.Builder, com.google.mediapipe.proto.CalculatorOptionsProto.CalculatorOptionsOrBuilder> optionsBuilder_;
        /**
         * <pre>
         * The options passed to the Calculator, in proto2 syntax.
         * </pre>
         *
         * <code>optional .mediapipe.CalculatorOptions options = 7;</code>
         */
        public boolean hasOptions() {
          return optionsBuilder_ != null || options_ != null;
        }
        /**
         * <pre>
         * The options passed to the Calculator, in proto2 syntax.
         * </pre>
         *
         * <code>optional .mediapipe.CalculatorOptions options = 7;</code>
         */
        public com.google.mediapipe.proto.CalculatorOptionsProto.CalculatorOptions getOptions() {
          if (optionsBuilder_ == null) {
            return options_ == null ? com.google.mediapipe.proto.CalculatorOptionsProto.CalculatorOptions.getDefaultInstance() : options_;
          } else {
            return optionsBuilder_.getMessage();
          }
        }
        /**
         * <pre>
         * The options passed to the Calculator, in proto2 syntax.
         * </pre>
         *
         * <code>optional .mediapipe.CalculatorOptions options = 7;</code>
         */
        public Builder setOptions(com.google.mediapipe.proto.CalculatorOptionsProto.CalculatorOptions value) {
          if (optionsBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            options_ = value;
            onChanged();
          } else {
            optionsBuilder_.setMessage(value);
          }

          return this;
        }
        /**
         * <pre>
         * The options passed to the Calculator, in proto2 syntax.
         * </pre>
         *
         * <code>optional .mediapipe.CalculatorOptions options = 7;</code>
         */
        public Builder setOptions(
            com.google.mediapipe.proto.CalculatorOptionsProto.CalculatorOptions.Builder builderForValue) {
          if (optionsBuilder_ == null) {
            options_ = builderForValue.build();
            onChanged();
          } else {
            optionsBuilder_.setMessage(builderForValue.build());
          }

          return this;
        }
        /**
         * <pre>
         * The options passed to the Calculator, in proto2 syntax.
         * </pre>
         *
         * <code>optional .mediapipe.CalculatorOptions options = 7;</code>
         */
        public Builder mergeOptions(com.google.mediapipe.proto.CalculatorOptionsProto.CalculatorOptions value) {
          if (optionsBuilder_ == null) {
            if (options_ != null) {
              options_ =
                com.google.mediapipe.proto.CalculatorOptionsProto.CalculatorOptions.newBuilder(options_).mergeFrom(value).buildPartial();
            } else {
              options_ = value;
            }
            onChanged();
          } else {
            optionsBuilder_.mergeFrom(value);
          }

          return this;
        }
        /**
         * <pre>
         * The options passed to the Calculator, in proto2 syntax.
         * </pre>
         *
         * <code>optional .mediapipe.CalculatorOptions options = 7;</code>
         */
        public Builder clearOptions() {
          if (optionsBuilder_ == null) {
            options_ = null;
            onChanged();
          } else {
            options_ = null;
            optionsBuilder_ = null;
          }

          return this;
        }
        /**
         * <pre>
         * The options passed to the Calculator, in proto2 syntax.
         * </pre>
         *
         * <code>optional .mediapipe.CalculatorOptions options = 7;</code>
         */
        public com.google.mediapipe.proto.CalculatorOptionsProto.CalculatorOptions.Builder getOptionsBuilder() {
          
          onChanged();
          return getOptionsFieldBuilder().getBuilder();
        }
        /**
         * <pre>
         * The options passed to the Calculator, in proto2 syntax.
         * </pre>
         *
         * <code>optional .mediapipe.CalculatorOptions options = 7;</code>
         */
        public com.google.mediapipe.proto.CalculatorOptionsProto.CalculatorOptionsOrBuilder getOptionsOrBuilder() {
          if (optionsBuilder_ != null) {
            return optionsBuilder_.getMessageOrBuilder();
          } else {
            return options_ == null ?
                com.google.mediapipe.proto.CalculatorOptionsProto.CalculatorOptions.getDefaultInstance() : options_;
          }
        }
        /**
         * <pre>
         * The options passed to the Calculator, in proto2 syntax.
         * </pre>
         *
         * <code>optional .mediapipe.CalculatorOptions options = 7;</code>
         */
        private com.google.protobuf.SingleFieldBuilderV3<
            com.google.mediapipe.proto.CalculatorOptionsProto.CalculatorOptions, com.google.mediapipe.proto.CalculatorOptionsProto.CalculatorOptions.Builder, com.google.mediapipe.proto.CalculatorOptionsProto.CalculatorOptionsOrBuilder> 
            getOptionsFieldBuilder() {
          if (optionsBuilder_ == null) {
            optionsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
                com.google.mediapipe.proto.CalculatorOptionsProto.CalculatorOptions, com.google.mediapipe.proto.CalculatorOptionsProto.CalculatorOptions.Builder, com.google.mediapipe.proto.CalculatorOptionsProto.CalculatorOptionsOrBuilder>(
                    getOptions(),
                    getParentForChildren(),
                    isClean());
            options_ = null;
          }
          return optionsBuilder_;
        }

        private java.util.List<com.google.protobuf.Any> nodeOptions_ =
          java.util.Collections.emptyList();
        private void ensureNodeOptionsIsMutable() {
          if (!((bitField0_ & 0x00000080) == 0x00000080)) {
            nodeOptions_ = new java.util.ArrayList<com.google.protobuf.Any>(nodeOptions_);
            bitField0_ |= 0x00000080;
           }
        }

        private com.google.protobuf.RepeatedFieldBuilderV3<
            com.google.protobuf.Any, com.google.protobuf.Any.Builder, com.google.protobuf.AnyOrBuilder> nodeOptionsBuilder_;

        /**
         * <pre>
         * The options passed to the Calculator, in proto3 syntax.
         * Each node_options message must have a different message type.
         * If the same message type is specified in |options| and |node_options|,
         * only the message in |options| is used.
         * </pre>
         *
         * <code>repeated .google.protobuf.Any node_options = 8;</code>
         */
        public java.util.List<com.google.protobuf.Any> getNodeOptionsList() {
          if (nodeOptionsBuilder_ == null) {
            return java.util.Collections.unmodifiableList(nodeOptions_);
          } else {
            return nodeOptionsBuilder_.getMessageList();
          }
        }
        /**
         * <pre>
         * The options passed to the Calculator, in proto3 syntax.
         * Each node_options message must have a different message type.
         * If the same message type is specified in |options| and |node_options|,
         * only the message in |options| is used.
         * </pre>
         *
         * <code>repeated .google.protobuf.Any node_options = 8;</code>
         */
        public int getNodeOptionsCount() {
          if (nodeOptionsBuilder_ == null) {
            return nodeOptions_.size();
          } else {
            return nodeOptionsBuilder_.getCount();
          }
        }
        /**
         * <pre>
         * The options passed to the Calculator, in proto3 syntax.
         * Each node_options message must have a different message type.
         * If the same message type is specified in |options| and |node_options|,
         * only the message in |options| is used.
         * </pre>
         *
         * <code>repeated .google.protobuf.Any node_options = 8;</code>
         */
        public com.google.protobuf.Any getNodeOptions(int index) {
          if (nodeOptionsBuilder_ == null) {
            return nodeOptions_.get(index);
          } else {
            return nodeOptionsBuilder_.getMessage(index);
          }
        }
        /**
         * <pre>
         * The options passed to the Calculator, in proto3 syntax.
         * Each node_options message must have a different message type.
         * If the same message type is specified in |options| and |node_options|,
         * only the message in |options| is used.
         * </pre>
         *
         * <code>repeated .google.protobuf.Any node_options = 8;</code>
         */
        public Builder setNodeOptions(
            int index, com.google.protobuf.Any value) {
          if (nodeOptionsBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            ensureNodeOptionsIsMutable();
            nodeOptions_.set(index, value);
            onChanged();
          } else {
            nodeOptionsBuilder_.setMessage(index, value);
          }
          return this;
        }
        /**
         * <pre>
         * The options passed to the Calculator, in proto3 syntax.
         * Each node_options message must have a different message type.
         * If the same message type is specified in |options| and |node_options|,
         * only the message in |options| is used.
         * </pre>
         *
         * <code>repeated .google.protobuf.Any node_options = 8;</code>
         */
        public Builder setNodeOptions(
            int index, com.google.protobuf.Any.Builder builderForValue) {
          if (nodeOptionsBuilder_ == null) {
            ensureNodeOptionsIsMutable();
            nodeOptions_.set(index, builderForValue.build());
            onChanged();
          } else {
            nodeOptionsBuilder_.setMessage(index, builderForValue.build());
          }
          return this;
        }
        /**
         * <pre>
         * The options passed to the Calculator, in proto3 syntax.
         * Each node_options message must have a different message type.
         * If the same message type is specified in |options| and |node_options|,
         * only the message in |options| is used.
         * </pre>
         *
         * <code>repeated .google.protobuf.Any node_options = 8;</code>
         */
        public Builder addNodeOptions(com.google.protobuf.Any value) {
          if (nodeOptionsBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            ensureNodeOptionsIsMutable();
            nodeOptions_.add(value);
            onChanged();
          } else {
            nodeOptionsBuilder_.addMessage(value);
          }
          return this;
        }
        /**
         * <pre>
         * The options passed to the Calculator, in proto3 syntax.
         * Each node_options message must have a different message type.
         * If the same message type is specified in |options| and |node_options|,
         * only the message in |options| is used.
         * </pre>
         *
         * <code>repeated .google.protobuf.Any node_options = 8;</code>
         */
        public Builder addNodeOptions(
            int index, com.google.protobuf.Any value) {
          if (nodeOptionsBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            ensureNodeOptionsIsMutable();
            nodeOptions_.add(index, value);
            onChanged();
          } else {
            nodeOptionsBuilder_.addMessage(index, value);
          }
          return this;
        }
        /**
         * <pre>
         * The options passed to the Calculator, in proto3 syntax.
         * Each node_options message must have a different message type.
         * If the same message type is specified in |options| and |node_options|,
         * only the message in |options| is used.
         * </pre>
         *
         * <code>repeated .google.protobuf.Any node_options = 8;</code>
         */
        public Builder addNodeOptions(
            com.google.protobuf.Any.Builder builderForValue) {
          if (nodeOptionsBuilder_ == null) {
            ensureNodeOptionsIsMutable();
            nodeOptions_.add(builderForValue.build());
            onChanged();
          } else {
            nodeOptionsBuilder_.addMessage(builderForValue.build());
          }
          return this;
        }
        /**
         * <pre>
         * The options passed to the Calculator, in proto3 syntax.
         * Each node_options message must have a different message type.
         * If the same message type is specified in |options| and |node_options|,
         * only the message in |options| is used.
         * </pre>
         *
         * <code>repeated .google.protobuf.Any node_options = 8;</code>
         */
        public Builder addNodeOptions(
            int index, com.google.protobuf.Any.Builder builderForValue) {
          if (nodeOptionsBuilder_ == null) {
            ensureNodeOptionsIsMutable();
            nodeOptions_.add(index, builderForValue.build());
            onChanged();
          } else {
            nodeOptionsBuilder_.addMessage(index, builderForValue.build());
          }
          return this;
        }
        /**
         * <pre>
         * The options passed to the Calculator, in proto3 syntax.
         * Each node_options message must have a different message type.
         * If the same message type is specified in |options| and |node_options|,
         * only the message in |options| is used.
         * </pre>
         *
         * <code>repeated .google.protobuf.Any node_options = 8;</code>
         */
        public Builder addAllNodeOptions(
            java.lang.Iterable<? extends com.google.protobuf.Any> values) {
          if (nodeOptionsBuilder_ == null) {
            ensureNodeOptionsIsMutable();
            com.google.protobuf.AbstractMessageLite.Builder.addAll(
                values, nodeOptions_);
            onChanged();
          } else {
            nodeOptionsBuilder_.addAllMessages(values);
          }
          return this;
        }
        /**
         * <pre>
         * The options passed to the Calculator, in proto3 syntax.
         * Each node_options message must have a different message type.
         * If the same message type is specified in |options| and |node_options|,
         * only the message in |options| is used.
         * </pre>
         *
         * <code>repeated .google.protobuf.Any node_options = 8;</code>
         */
        public Builder clearNodeOptions() {
          if (nodeOptionsBuilder_ == null) {
            nodeOptions_ = java.util.Collections.emptyList();
            bitField0_ = (bitField0_ & ~0x00000080);
            onChanged();
          } else {
            nodeOptionsBuilder_.clear();
          }
          return this;
        }
        /**
         * <pre>
         * The options passed to the Calculator, in proto3 syntax.
         * Each node_options message must have a different message type.
         * If the same message type is specified in |options| and |node_options|,
         * only the message in |options| is used.
         * </pre>
         *
         * <code>repeated .google.protobuf.Any node_options = 8;</code>
         */
        public Builder removeNodeOptions(int index) {
          if (nodeOptionsBuilder_ == null) {
            ensureNodeOptionsIsMutable();
            nodeOptions_.remove(index);
            onChanged();
          } else {
            nodeOptionsBuilder_.remove(index);
          }
          return this;
        }
        /**
         * <pre>
         * The options passed to the Calculator, in proto3 syntax.
         * Each node_options message must have a different message type.
         * If the same message type is specified in |options| and |node_options|,
         * only the message in |options| is used.
         * </pre>
         *
         * <code>repeated .google.protobuf.Any node_options = 8;</code>
         */
        public com.google.protobuf.Any.Builder getNodeOptionsBuilder(
            int index) {
          return getNodeOptionsFieldBuilder().getBuilder(index);
        }
        /**
         * <pre>
         * The options passed to the Calculator, in proto3 syntax.
         * Each node_options message must have a different message type.
         * If the same message type is specified in |options| and |node_options|,
         * only the message in |options| is used.
         * </pre>
         *
         * <code>repeated .google.protobuf.Any node_options = 8;</code>
         */
        public com.google.protobuf.AnyOrBuilder getNodeOptionsOrBuilder(
            int index) {
          if (nodeOptionsBuilder_ == null) {
            return nodeOptions_.get(index);  } else {
            return nodeOptionsBuilder_.getMessageOrBuilder(index);
          }
        }
        /**
         * <pre>
         * The options passed to the Calculator, in proto3 syntax.
         * Each node_options message must have a different message type.
         * If the same message type is specified in |options| and |node_options|,
         * only the message in |options| is used.
         * </pre>
         *
         * <code>repeated .google.protobuf.Any node_options = 8;</code>
         */
        public java.util.List<? extends com.google.protobuf.AnyOrBuilder> 
             getNodeOptionsOrBuilderList() {
          if (nodeOptionsBuilder_ != null) {
            return nodeOptionsBuilder_.getMessageOrBuilderList();
          } else {
            return java.util.Collections.unmodifiableList(nodeOptions_);
          }
        }
        /**
         * <pre>
         * The options passed to the Calculator, in proto3 syntax.
         * Each node_options message must have a different message type.
         * If the same message type is specified in |options| and |node_options|,
         * only the message in |options| is used.
         * </pre>
         *
         * <code>repeated .google.protobuf.Any node_options = 8;</code>
         */
        public com.google.protobuf.Any.Builder addNodeOptionsBuilder() {
          return getNodeOptionsFieldBuilder().addBuilder(
              com.google.protobuf.Any.getDefaultInstance());
        }
        /**
         * <pre>
         * The options passed to the Calculator, in proto3 syntax.
         * Each node_options message must have a different message type.
         * If the same message type is specified in |options| and |node_options|,
         * only the message in |options| is used.
         * </pre>
         *
         * <code>repeated .google.protobuf.Any node_options = 8;</code>
         */
        public com.google.protobuf.Any.Builder addNodeOptionsBuilder(
            int index) {
          return getNodeOptionsFieldBuilder().addBuilder(
              index, com.google.protobuf.Any.getDefaultInstance());
        }
        /**
         * <pre>
         * The options passed to the Calculator, in proto3 syntax.
         * Each node_options message must have a different message type.
         * If the same message type is specified in |options| and |node_options|,
         * only the message in |options| is used.
         * </pre>
         *
         * <code>repeated .google.protobuf.Any node_options = 8;</code>
         */
        public java.util.List<com.google.protobuf.Any.Builder> 
             getNodeOptionsBuilderList() {
          return getNodeOptionsFieldBuilder().getBuilderList();
        }
        private com.google.protobuf.RepeatedFieldBuilderV3<
            com.google.protobuf.Any, com.google.protobuf.Any.Builder, com.google.protobuf.AnyOrBuilder> 
            getNodeOptionsFieldBuilder() {
          if (nodeOptionsBuilder_ == null) {
            nodeOptionsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
                com.google.protobuf.Any, com.google.protobuf.Any.Builder, com.google.protobuf.AnyOrBuilder>(
                    nodeOptions_,
                    ((bitField0_ & 0x00000080) == 0x00000080),
                    getParentForChildren(),
                    isClean());
            nodeOptions_ = null;
          }
          return nodeOptionsBuilder_;
        }

        private int sourceLayer_ ;
        /**
         * <pre>
         * For a Source Calculator (i.e. a calculator with no inputs),
         * this is the "layer" on which the calculator is executed.  For a
         * non-source calculator (i.e. a calculator with one or more input
         * streams) this field has no effect.  The sources on each layer
         * are completely exhausted before Process() is called on any source
         * calculator on a higher numbered layer.
         * Example:
         *   Decoder -&gt; Median Frame (requires all frames) -&gt; Image Subtraction
         *           ---------------------------------------&gt;
         * The entire video will be buffered on the edge from the decoder
         * to the Image subtraction.  To fix this problem, layers can be used.
         *   Decoder (layer 0) -&gt; Median Frame -&gt; Image Subtraction
         *   Decoder (layer 1) -----------------&gt;
         * The frames from layer 0 will no longer be buffered, but the video
         * will be decoded again instead.  Note, that different options can
         * be used in the second decoder.
         * </pre>
         *
         * <code>optional int32 source_layer = 9;</code>
         */
        public int getSourceLayer() {
          return sourceLayer_;
        }
        /**
         * <pre>
         * For a Source Calculator (i.e. a calculator with no inputs),
         * this is the "layer" on which the calculator is executed.  For a
         * non-source calculator (i.e. a calculator with one or more input
         * streams) this field has no effect.  The sources on each layer
         * are completely exhausted before Process() is called on any source
         * calculator on a higher numbered layer.
         * Example:
         *   Decoder -&gt; Median Frame (requires all frames) -&gt; Image Subtraction
         *           ---------------------------------------&gt;
         * The entire video will be buffered on the edge from the decoder
         * to the Image subtraction.  To fix this problem, layers can be used.
         *   Decoder (layer 0) -&gt; Median Frame -&gt; Image Subtraction
         *   Decoder (layer 1) -----------------&gt;
         * The frames from layer 0 will no longer be buffered, but the video
         * will be decoded again instead.  Note, that different options can
         * be used in the second decoder.
         * </pre>
         *
         * <code>optional int32 source_layer = 9;</code>
         */
        public Builder setSourceLayer(int value) {
          
          sourceLayer_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * For a Source Calculator (i.e. a calculator with no inputs),
         * this is the "layer" on which the calculator is executed.  For a
         * non-source calculator (i.e. a calculator with one or more input
         * streams) this field has no effect.  The sources on each layer
         * are completely exhausted before Process() is called on any source
         * calculator on a higher numbered layer.
         * Example:
         *   Decoder -&gt; Median Frame (requires all frames) -&gt; Image Subtraction
         *           ---------------------------------------&gt;
         * The entire video will be buffered on the edge from the decoder
         * to the Image subtraction.  To fix this problem, layers can be used.
         *   Decoder (layer 0) -&gt; Median Frame -&gt; Image Subtraction
         *   Decoder (layer 1) -----------------&gt;
         * The frames from layer 0 will no longer be buffered, but the video
         * will be decoded again instead.  Note, that different options can
         * be used in the second decoder.
         * </pre>
         *
         * <code>optional int32 source_layer = 9;</code>
         */
        public Builder clearSourceLayer() {
          
          sourceLayer_ = 0;
          onChanged();
          return this;
        }

        private int bufferSizeHint_ ;
        /**
         * <pre>
         * Optional parameter that allows the user to indicate to the scheduler that
         * this node has a buffering behavior (i.e. waits for a bunch of packets
         * before emitting any) and specify the size of the buffer that is built up.
         * The scheduler will then try to keep the maximum size of any input queues
         * in the graph to remain below the maximum of all buffer_size_hints and
         * max_queue_size (if specified). The ideal value is typically something
         * larger than the actual number of buffered packets to maintain pipelining.
         * The default value 0 indicates that the node has no buffering behavior.
         * </pre>
         *
         * <code>optional int32 buffer_size_hint = 10;</code>
         */
        public int getBufferSizeHint() {
          return bufferSizeHint_;
        }
        /**
         * <pre>
         * Optional parameter that allows the user to indicate to the scheduler that
         * this node has a buffering behavior (i.e. waits for a bunch of packets
         * before emitting any) and specify the size of the buffer that is built up.
         * The scheduler will then try to keep the maximum size of any input queues
         * in the graph to remain below the maximum of all buffer_size_hints and
         * max_queue_size (if specified). The ideal value is typically something
         * larger than the actual number of buffered packets to maintain pipelining.
         * The default value 0 indicates that the node has no buffering behavior.
         * </pre>
         *
         * <code>optional int32 buffer_size_hint = 10;</code>
         */
        public Builder setBufferSizeHint(int value) {
          
          bufferSizeHint_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Optional parameter that allows the user to indicate to the scheduler that
         * this node has a buffering behavior (i.e. waits for a bunch of packets
         * before emitting any) and specify the size of the buffer that is built up.
         * The scheduler will then try to keep the maximum size of any input queues
         * in the graph to remain below the maximum of all buffer_size_hints and
         * max_queue_size (if specified). The ideal value is typically something
         * larger than the actual number of buffered packets to maintain pipelining.
         * The default value 0 indicates that the node has no buffering behavior.
         * </pre>
         *
         * <code>optional int32 buffer_size_hint = 10;</code>
         */
        public Builder clearBufferSizeHint() {
          
          bufferSizeHint_ = 0;
          onChanged();
          return this;
        }

        private mediapipe.StreamHandler.InputStreamHandlerConfig inputStreamHandler_ = null;
        private com.google.protobuf.SingleFieldBuilderV3<
            mediapipe.StreamHandler.InputStreamHandlerConfig, mediapipe.StreamHandler.InputStreamHandlerConfig.Builder, mediapipe.StreamHandler.InputStreamHandlerConfigOrBuilder> inputStreamHandlerBuilder_;
        /**
         * <pre>
         * Config for this node's InputStreamHandler.
         * If unspecified, the graph-level input stream handler will be used.
         * </pre>
         *
         * <code>optional .mediapipe.InputStreamHandlerConfig input_stream_handler = 11;</code>
         */
        public boolean hasInputStreamHandler() {
          return inputStreamHandlerBuilder_ != null || inputStreamHandler_ != null;
        }
        /**
         * <pre>
         * Config for this node's InputStreamHandler.
         * If unspecified, the graph-level input stream handler will be used.
         * </pre>
         *
         * <code>optional .mediapipe.InputStreamHandlerConfig input_stream_handler = 11;</code>
         */
        public mediapipe.StreamHandler.InputStreamHandlerConfig getInputStreamHandler() {
          if (inputStreamHandlerBuilder_ == null) {
            return inputStreamHandler_ == null ? mediapipe.StreamHandler.InputStreamHandlerConfig.getDefaultInstance() : inputStreamHandler_;
          } else {
            return inputStreamHandlerBuilder_.getMessage();
          }
        }
        /**
         * <pre>
         * Config for this node's InputStreamHandler.
         * If unspecified, the graph-level input stream handler will be used.
         * </pre>
         *
         * <code>optional .mediapipe.InputStreamHandlerConfig input_stream_handler = 11;</code>
         */
        public Builder setInputStreamHandler(mediapipe.StreamHandler.InputStreamHandlerConfig value) {
          if (inputStreamHandlerBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            inputStreamHandler_ = value;
            onChanged();
          } else {
            inputStreamHandlerBuilder_.setMessage(value);
          }

          return this;
        }
        /**
         * <pre>
         * Config for this node's InputStreamHandler.
         * If unspecified, the graph-level input stream handler will be used.
         * </pre>
         *
         * <code>optional .mediapipe.InputStreamHandlerConfig input_stream_handler = 11;</code>
         */
        public Builder setInputStreamHandler(
            mediapipe.StreamHandler.InputStreamHandlerConfig.Builder builderForValue) {
          if (inputStreamHandlerBuilder_ == null) {
            inputStreamHandler_ = builderForValue.build();
            onChanged();
          } else {
            inputStreamHandlerBuilder_.setMessage(builderForValue.build());
          }

          return this;
        }
        /**
         * <pre>
         * Config for this node's InputStreamHandler.
         * If unspecified, the graph-level input stream handler will be used.
         * </pre>
         *
         * <code>optional .mediapipe.InputStreamHandlerConfig input_stream_handler = 11;</code>
         */
        public Builder mergeInputStreamHandler(mediapipe.StreamHandler.InputStreamHandlerConfig value) {
          if (inputStreamHandlerBuilder_ == null) {
            if (inputStreamHandler_ != null) {
              inputStreamHandler_ =
                mediapipe.StreamHandler.InputStreamHandlerConfig.newBuilder(inputStreamHandler_).mergeFrom(value).buildPartial();
            } else {
              inputStreamHandler_ = value;
            }
            onChanged();
          } else {
            inputStreamHandlerBuilder_.mergeFrom(value);
          }

          return this;
        }
        /**
         * <pre>
         * Config for this node's InputStreamHandler.
         * If unspecified, the graph-level input stream handler will be used.
         * </pre>
         *
         * <code>optional .mediapipe.InputStreamHandlerConfig input_stream_handler = 11;</code>
         */
        public Builder clearInputStreamHandler() {
          if (inputStreamHandlerBuilder_ == null) {
            inputStreamHandler_ = null;
            onChanged();
          } else {
            inputStreamHandler_ = null;
            inputStreamHandlerBuilder_ = null;
          }

          return this;
        }
        /**
         * <pre>
         * Config for this node's InputStreamHandler.
         * If unspecified, the graph-level input stream handler will be used.
         * </pre>
         *
         * <code>optional .mediapipe.InputStreamHandlerConfig input_stream_handler = 11;</code>
         */
        public mediapipe.StreamHandler.InputStreamHandlerConfig.Builder getInputStreamHandlerBuilder() {
          
          onChanged();
          return getInputStreamHandlerFieldBuilder().getBuilder();
        }
        /**
         * <pre>
         * Config for this node's InputStreamHandler.
         * If unspecified, the graph-level input stream handler will be used.
         * </pre>
         *
         * <code>optional .mediapipe.InputStreamHandlerConfig input_stream_handler = 11;</code>
         */
        public mediapipe.StreamHandler.InputStreamHandlerConfigOrBuilder getInputStreamHandlerOrBuilder() {
          if (inputStreamHandlerBuilder_ != null) {
            return inputStreamHandlerBuilder_.getMessageOrBuilder();
          } else {
            return inputStreamHandler_ == null ?
                mediapipe.StreamHandler.InputStreamHandlerConfig.getDefaultInstance() : inputStreamHandler_;
          }
        }
        /**
         * <pre>
         * Config for this node's InputStreamHandler.
         * If unspecified, the graph-level input stream handler will be used.
         * </pre>
         *
         * <code>optional .mediapipe.InputStreamHandlerConfig input_stream_handler = 11;</code>
         */
        private com.google.protobuf.SingleFieldBuilderV3<
            mediapipe.StreamHandler.InputStreamHandlerConfig, mediapipe.StreamHandler.InputStreamHandlerConfig.Builder, mediapipe.StreamHandler.InputStreamHandlerConfigOrBuilder> 
            getInputStreamHandlerFieldBuilder() {
          if (inputStreamHandlerBuilder_ == null) {
            inputStreamHandlerBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
                mediapipe.StreamHandler.InputStreamHandlerConfig, mediapipe.StreamHandler.InputStreamHandlerConfig.Builder, mediapipe.StreamHandler.InputStreamHandlerConfigOrBuilder>(
                    getInputStreamHandler(),
                    getParentForChildren(),
                    isClean());
            inputStreamHandler_ = null;
          }
          return inputStreamHandlerBuilder_;
        }

        private mediapipe.StreamHandler.OutputStreamHandlerConfig outputStreamHandler_ = null;
        private com.google.protobuf.SingleFieldBuilderV3<
            mediapipe.StreamHandler.OutputStreamHandlerConfig, mediapipe.StreamHandler.OutputStreamHandlerConfig.Builder, mediapipe.StreamHandler.OutputStreamHandlerConfigOrBuilder> outputStreamHandlerBuilder_;
        /**
         * <pre>
         * Config for this node's OutputStreamHandler.
         * If unspecified, the graph-level output stream handler will be used.
         * </pre>
         *
         * <code>optional .mediapipe.OutputStreamHandlerConfig output_stream_handler = 12;</code>
         */
        public boolean hasOutputStreamHandler() {
          return outputStreamHandlerBuilder_ != null || outputStreamHandler_ != null;
        }
        /**
         * <pre>
         * Config for this node's OutputStreamHandler.
         * If unspecified, the graph-level output stream handler will be used.
         * </pre>
         *
         * <code>optional .mediapipe.OutputStreamHandlerConfig output_stream_handler = 12;</code>
         */
        public mediapipe.StreamHandler.OutputStreamHandlerConfig getOutputStreamHandler() {
          if (outputStreamHandlerBuilder_ == null) {
            return outputStreamHandler_ == null ? mediapipe.StreamHandler.OutputStreamHandlerConfig.getDefaultInstance() : outputStreamHandler_;
          } else {
            return outputStreamHandlerBuilder_.getMessage();
          }
        }
        /**
         * <pre>
         * Config for this node's OutputStreamHandler.
         * If unspecified, the graph-level output stream handler will be used.
         * </pre>
         *
         * <code>optional .mediapipe.OutputStreamHandlerConfig output_stream_handler = 12;</code>
         */
        public Builder setOutputStreamHandler(mediapipe.StreamHandler.OutputStreamHandlerConfig value) {
          if (outputStreamHandlerBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            outputStreamHandler_ = value;
            onChanged();
          } else {
            outputStreamHandlerBuilder_.setMessage(value);
          }

          return this;
        }
        /**
         * <pre>
         * Config for this node's OutputStreamHandler.
         * If unspecified, the graph-level output stream handler will be used.
         * </pre>
         *
         * <code>optional .mediapipe.OutputStreamHandlerConfig output_stream_handler = 12;</code>
         */
        public Builder setOutputStreamHandler(
            mediapipe.StreamHandler.OutputStreamHandlerConfig.Builder builderForValue) {
          if (outputStreamHandlerBuilder_ == null) {
            outputStreamHandler_ = builderForValue.build();
            onChanged();
          } else {
            outputStreamHandlerBuilder_.setMessage(builderForValue.build());
          }

          return this;
        }
        /**
         * <pre>
         * Config for this node's OutputStreamHandler.
         * If unspecified, the graph-level output stream handler will be used.
         * </pre>
         *
         * <code>optional .mediapipe.OutputStreamHandlerConfig output_stream_handler = 12;</code>
         */
        public Builder mergeOutputStreamHandler(mediapipe.StreamHandler.OutputStreamHandlerConfig value) {
          if (outputStreamHandlerBuilder_ == null) {
            if (outputStreamHandler_ != null) {
              outputStreamHandler_ =
                mediapipe.StreamHandler.OutputStreamHandlerConfig.newBuilder(outputStreamHandler_).mergeFrom(value).buildPartial();
            } else {
              outputStreamHandler_ = value;
            }
            onChanged();
          } else {
            outputStreamHandlerBuilder_.mergeFrom(value);
          }

          return this;
        }
        /**
         * <pre>
         * Config for this node's OutputStreamHandler.
         * If unspecified, the graph-level output stream handler will be used.
         * </pre>
         *
         * <code>optional .mediapipe.OutputStreamHandlerConfig output_stream_handler = 12;</code>
         */
        public Builder clearOutputStreamHandler() {
          if (outputStreamHandlerBuilder_ == null) {
            outputStreamHandler_ = null;
            onChanged();
          } else {
            outputStreamHandler_ = null;
            outputStreamHandlerBuilder_ = null;
          }

          return this;
        }
        /**
         * <pre>
         * Config for this node's OutputStreamHandler.
         * If unspecified, the graph-level output stream handler will be used.
         * </pre>
         *
         * <code>optional .mediapipe.OutputStreamHandlerConfig output_stream_handler = 12;</code>
         */
        public mediapipe.StreamHandler.OutputStreamHandlerConfig.Builder getOutputStreamHandlerBuilder() {
          
          onChanged();
          return getOutputStreamHandlerFieldBuilder().getBuilder();
        }
        /**
         * <pre>
         * Config for this node's OutputStreamHandler.
         * If unspecified, the graph-level output stream handler will be used.
         * </pre>
         *
         * <code>optional .mediapipe.OutputStreamHandlerConfig output_stream_handler = 12;</code>
         */
        public mediapipe.StreamHandler.OutputStreamHandlerConfigOrBuilder getOutputStreamHandlerOrBuilder() {
          if (outputStreamHandlerBuilder_ != null) {
            return outputStreamHandlerBuilder_.getMessageOrBuilder();
          } else {
            return outputStreamHandler_ == null ?
                mediapipe.StreamHandler.OutputStreamHandlerConfig.getDefaultInstance() : outputStreamHandler_;
          }
        }
        /**
         * <pre>
         * Config for this node's OutputStreamHandler.
         * If unspecified, the graph-level output stream handler will be used.
         * </pre>
         *
         * <code>optional .mediapipe.OutputStreamHandlerConfig output_stream_handler = 12;</code>
         */
        private com.google.protobuf.SingleFieldBuilderV3<
            mediapipe.StreamHandler.OutputStreamHandlerConfig, mediapipe.StreamHandler.OutputStreamHandlerConfig.Builder, mediapipe.StreamHandler.OutputStreamHandlerConfigOrBuilder> 
            getOutputStreamHandlerFieldBuilder() {
          if (outputStreamHandlerBuilder_ == null) {
            outputStreamHandlerBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
                mediapipe.StreamHandler.OutputStreamHandlerConfig, mediapipe.StreamHandler.OutputStreamHandlerConfig.Builder, mediapipe.StreamHandler.OutputStreamHandlerConfigOrBuilder>(
                    getOutputStreamHandler(),
                    getParentForChildren(),
                    isClean());
            outputStreamHandler_ = null;
          }
          return outputStreamHandlerBuilder_;
        }

        private java.util.List<com.google.mediapipe.proto.CalculatorProto.InputStreamInfo> inputStreamInfo_ =
          java.util.Collections.emptyList();
        private void ensureInputStreamInfoIsMutable() {
          if (!((bitField0_ & 0x00001000) == 0x00001000)) {
            inputStreamInfo_ = new java.util.ArrayList<com.google.mediapipe.proto.CalculatorProto.InputStreamInfo>(inputStreamInfo_);
            bitField0_ |= 0x00001000;
           }
        }

        private com.google.protobuf.RepeatedFieldBuilderV3<
            com.google.mediapipe.proto.CalculatorProto.InputStreamInfo, com.google.mediapipe.proto.CalculatorProto.InputStreamInfo.Builder, com.google.mediapipe.proto.CalculatorProto.InputStreamInfoOrBuilder> inputStreamInfoBuilder_;

        /**
         * <pre>
         * Additional information about an input stream. The |name| field of the
         * InputStreamInfo must match an input_stream.
         * </pre>
         *
         * <code>repeated .mediapipe.InputStreamInfo input_stream_info = 13;</code>
         */
        public java.util.List<com.google.mediapipe.proto.CalculatorProto.InputStreamInfo> getInputStreamInfoList() {
          if (inputStreamInfoBuilder_ == null) {
            return java.util.Collections.unmodifiableList(inputStreamInfo_);
          } else {
            return inputStreamInfoBuilder_.getMessageList();
          }
        }
        /**
         * <pre>
         * Additional information about an input stream. The |name| field of the
         * InputStreamInfo must match an input_stream.
         * </pre>
         *
         * <code>repeated .mediapipe.InputStreamInfo input_stream_info = 13;</code>
         */
        public int getInputStreamInfoCount() {
          if (inputStreamInfoBuilder_ == null) {
            return inputStreamInfo_.size();
          } else {
            return inputStreamInfoBuilder_.getCount();
          }
        }
        /**
         * <pre>
         * Additional information about an input stream. The |name| field of the
         * InputStreamInfo must match an input_stream.
         * </pre>
         *
         * <code>repeated .mediapipe.InputStreamInfo input_stream_info = 13;</code>
         */
        public com.google.mediapipe.proto.CalculatorProto.InputStreamInfo getInputStreamInfo(int index) {
          if (inputStreamInfoBuilder_ == null) {
            return inputStreamInfo_.get(index);
          } else {
            return inputStreamInfoBuilder_.getMessage(index);
          }
        }
        /**
         * <pre>
         * Additional information about an input stream. The |name| field of the
         * InputStreamInfo must match an input_stream.
         * </pre>
         *
         * <code>repeated .mediapipe.InputStreamInfo input_stream_info = 13;</code>
         */
        public Builder setInputStreamInfo(
            int index, com.google.mediapipe.proto.CalculatorProto.InputStreamInfo value) {
          if (inputStreamInfoBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            ensureInputStreamInfoIsMutable();
            inputStreamInfo_.set(index, value);
            onChanged();
          } else {
            inputStreamInfoBuilder_.setMessage(index, value);
          }
          return this;
        }
        /**
         * <pre>
         * Additional information about an input stream. The |name| field of the
         * InputStreamInfo must match an input_stream.
         * </pre>
         *
         * <code>repeated .mediapipe.InputStreamInfo input_stream_info = 13;</code>
         */
        public Builder setInputStreamInfo(
            int index, com.google.mediapipe.proto.CalculatorProto.InputStreamInfo.Builder builderForValue) {
          if (inputStreamInfoBuilder_ == null) {
            ensureInputStreamInfoIsMutable();
            inputStreamInfo_.set(index, builderForValue.build());
            onChanged();
          } else {
            inputStreamInfoBuilder_.setMessage(index, builderForValue.build());
          }
          return this;
        }
        /**
         * <pre>
         * Additional information about an input stream. The |name| field of the
         * InputStreamInfo must match an input_stream.
         * </pre>
         *
         * <code>repeated .mediapipe.InputStreamInfo input_stream_info = 13;</code>
         */
        public Builder addInputStreamInfo(com.google.mediapipe.proto.CalculatorProto.InputStreamInfo value) {
          if (inputStreamInfoBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            ensureInputStreamInfoIsMutable();
            inputStreamInfo_.add(value);
            onChanged();
          } else {
            inputStreamInfoBuilder_.addMessage(value);
          }
          return this;
        }
        /**
         * <pre>
         * Additional information about an input stream. The |name| field of the
         * InputStreamInfo must match an input_stream.
         * </pre>
         *
         * <code>repeated .mediapipe.InputStreamInfo input_stream_info = 13;</code>
         */
        public Builder addInputStreamInfo(
            int index, com.google.mediapipe.proto.CalculatorProto.InputStreamInfo value) {
          if (inputStreamInfoBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            ensureInputStreamInfoIsMutable();
            inputStreamInfo_.add(index, value);
            onChanged();
          } else {
            inputStreamInfoBuilder_.addMessage(index, value);
          }
          return this;
        }
        /**
         * <pre>
         * Additional information about an input stream. The |name| field of the
         * InputStreamInfo must match an input_stream.
         * </pre>
         *
         * <code>repeated .mediapipe.InputStreamInfo input_stream_info = 13;</code>
         */
        public Builder addInputStreamInfo(
            com.google.mediapipe.proto.CalculatorProto.InputStreamInfo.Builder builderForValue) {
          if (inputStreamInfoBuilder_ == null) {
            ensureInputStreamInfoIsMutable();
            inputStreamInfo_.add(builderForValue.build());
            onChanged();
          } else {
            inputStreamInfoBuilder_.addMessage(builderForValue.build());
          }
          return this;
        }
        /**
         * <pre>
         * Additional information about an input stream. The |name| field of the
         * InputStreamInfo must match an input_stream.
         * </pre>
         *
         * <code>repeated .mediapipe.InputStreamInfo input_stream_info = 13;</code>
         */
        public Builder addInputStreamInfo(
            int index, com.google.mediapipe.proto.CalculatorProto.InputStreamInfo.Builder builderForValue) {
          if (inputStreamInfoBuilder_ == null) {
            ensureInputStreamInfoIsMutable();
            inputStreamInfo_.add(index, builderForValue.build());
            onChanged();
          } else {
            inputStreamInfoBuilder_.addMessage(index, builderForValue.build());
          }
          return this;
        }
        /**
         * <pre>
         * Additional information about an input stream. The |name| field of the
         * InputStreamInfo must match an input_stream.
         * </pre>
         *
         * <code>repeated .mediapipe.InputStreamInfo input_stream_info = 13;</code>
         */
        public Builder addAllInputStreamInfo(
            java.lang.Iterable<? extends com.google.mediapipe.proto.CalculatorProto.InputStreamInfo> values) {
          if (inputStreamInfoBuilder_ == null) {
            ensureInputStreamInfoIsMutable();
            com.google.protobuf.AbstractMessageLite.Builder.addAll(
                values, inputStreamInfo_);
            onChanged();
          } else {
            inputStreamInfoBuilder_.addAllMessages(values);
          }
          return this;
        }
        /**
         * <pre>
         * Additional information about an input stream. The |name| field of the
         * InputStreamInfo must match an input_stream.
         * </pre>
         *
         * <code>repeated .mediapipe.InputStreamInfo input_stream_info = 13;</code>
         */
        public Builder clearInputStreamInfo() {
          if (inputStreamInfoBuilder_ == null) {
            inputStreamInfo_ = java.util.Collections.emptyList();
            bitField0_ = (bitField0_ & ~0x00001000);
            onChanged();
          } else {
            inputStreamInfoBuilder_.clear();
          }
          return this;
        }
        /**
         * <pre>
         * Additional information about an input stream. The |name| field of the
         * InputStreamInfo must match an input_stream.
         * </pre>
         *
         * <code>repeated .mediapipe.InputStreamInfo input_stream_info = 13;</code>
         */
        public Builder removeInputStreamInfo(int index) {
          if (inputStreamInfoBuilder_ == null) {
            ensureInputStreamInfoIsMutable();
            inputStreamInfo_.remove(index);
            onChanged();
          } else {
            inputStreamInfoBuilder_.remove(index);
          }
          return this;
        }
        /**
         * <pre>
         * Additional information about an input stream. The |name| field of the
         * InputStreamInfo must match an input_stream.
         * </pre>
         *
         * <code>repeated .mediapipe.InputStreamInfo input_stream_info = 13;</code>
         */
        public com.google.mediapipe.proto.CalculatorProto.InputStreamInfo.Builder getInputStreamInfoBuilder(
            int index) {
          return getInputStreamInfoFieldBuilder().getBuilder(index);
        }
        /**
         * <pre>
         * Additional information about an input stream. The |name| field of the
         * InputStreamInfo must match an input_stream.
         * </pre>
         *
         * <code>repeated .mediapipe.InputStreamInfo input_stream_info = 13;</code>
         */
        public com.google.mediapipe.proto.CalculatorProto.InputStreamInfoOrBuilder getInputStreamInfoOrBuilder(
            int index) {
          if (inputStreamInfoBuilder_ == null) {
            return inputStreamInfo_.get(index);  } else {
            return inputStreamInfoBuilder_.getMessageOrBuilder(index);
          }
        }
        /**
         * <pre>
         * Additional information about an input stream. The |name| field of the
         * InputStreamInfo must match an input_stream.
         * </pre>
         *
         * <code>repeated .mediapipe.InputStreamInfo input_stream_info = 13;</code>
         */
        public java.util.List<? extends com.google.mediapipe.proto.CalculatorProto.InputStreamInfoOrBuilder> 
             getInputStreamInfoOrBuilderList() {
          if (inputStreamInfoBuilder_ != null) {
            return inputStreamInfoBuilder_.getMessageOrBuilderList();
          } else {
            return java.util.Collections.unmodifiableList(inputStreamInfo_);
          }
        }
        /**
         * <pre>
         * Additional information about an input stream. The |name| field of the
         * InputStreamInfo must match an input_stream.
         * </pre>
         *
         * <code>repeated .mediapipe.InputStreamInfo input_stream_info = 13;</code>
         */
        public com.google.mediapipe.proto.CalculatorProto.InputStreamInfo.Builder addInputStreamInfoBuilder() {
          return getInputStreamInfoFieldBuilder().addBuilder(
              com.google.mediapipe.proto.CalculatorProto.InputStreamInfo.getDefaultInstance());
        }
        /**
         * <pre>
         * Additional information about an input stream. The |name| field of the
         * InputStreamInfo must match an input_stream.
         * </pre>
         *
         * <code>repeated .mediapipe.InputStreamInfo input_stream_info = 13;</code>
         */
        public com.google.mediapipe.proto.CalculatorProto.InputStreamInfo.Builder addInputStreamInfoBuilder(
            int index) {
          return getInputStreamInfoFieldBuilder().addBuilder(
              index, com.google.mediapipe.proto.CalculatorProto.InputStreamInfo.getDefaultInstance());
        }
        /**
         * <pre>
         * Additional information about an input stream. The |name| field of the
         * InputStreamInfo must match an input_stream.
         * </pre>
         *
         * <code>repeated .mediapipe.InputStreamInfo input_stream_info = 13;</code>
         */
        public java.util.List<com.google.mediapipe.proto.CalculatorProto.InputStreamInfo.Builder> 
             getInputStreamInfoBuilderList() {
          return getInputStreamInfoFieldBuilder().getBuilderList();
        }
        private com.google.protobuf.RepeatedFieldBuilderV3<
            com.google.mediapipe.proto.CalculatorProto.InputStreamInfo, com.google.mediapipe.proto.CalculatorProto.InputStreamInfo.Builder, com.google.mediapipe.proto.CalculatorProto.InputStreamInfoOrBuilder> 
            getInputStreamInfoFieldBuilder() {
          if (inputStreamInfoBuilder_ == null) {
            inputStreamInfoBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
                com.google.mediapipe.proto.CalculatorProto.InputStreamInfo, com.google.mediapipe.proto.CalculatorProto.InputStreamInfo.Builder, com.google.mediapipe.proto.CalculatorProto.InputStreamInfoOrBuilder>(
                    inputStreamInfo_,
                    ((bitField0_ & 0x00001000) == 0x00001000),
                    getParentForChildren(),
                    isClean());
            inputStreamInfo_ = null;
          }
          return inputStreamInfoBuilder_;
        }

        private java.lang.Object executor_ = "";
        /**
         * <pre>
         * Set the executor which the calculator will execute on.
         * </pre>
         *
         * <code>optional string executor = 14;</code>
         */
        public java.lang.String getExecutor() {
          java.lang.Object ref = executor_;
          if (!(ref instanceof java.lang.String)) {
            com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
            java.lang.String s = bs.toStringUtf8();
            executor_ = s;
            return s;
          } else {
            return (java.lang.String) ref;
          }
        }
        /**
         * <pre>
         * Set the executor which the calculator will execute on.
         * </pre>
         *
         * <code>optional string executor = 14;</code>
         */
        public com.google.protobuf.ByteString
            getExecutorBytes() {
          java.lang.Object ref = executor_;
          if (ref instanceof String) {
            com.google.protobuf.ByteString b = 
                com.google.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            executor_ = b;
            return b;
          } else {
            return (com.google.protobuf.ByteString) ref;
          }
        }
        /**
         * <pre>
         * Set the executor which the calculator will execute on.
         * </pre>
         *
         * <code>optional string executor = 14;</code>
         */
        public Builder setExecutor(
            java.lang.String value) {
          if (value == null) {
    throw new NullPointerException();
  }
  
          executor_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Set the executor which the calculator will execute on.
         * </pre>
         *
         * <code>optional string executor = 14;</code>
         */
        public Builder clearExecutor() {
          
          executor_ = getDefaultInstance().getExecutor();
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Set the executor which the calculator will execute on.
         * </pre>
         *
         * <code>optional string executor = 14;</code>
         */
        public Builder setExecutorBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
          
          executor_ = value;
          onChanged();
          return this;
        }

        private com.google.mediapipe.proto.CalculatorProto.ProfilerConfig profilerConfig_ = null;
        private com.google.protobuf.SingleFieldBuilderV3<
            com.google.mediapipe.proto.CalculatorProto.ProfilerConfig, com.google.mediapipe.proto.CalculatorProto.ProfilerConfig.Builder, com.google.mediapipe.proto.CalculatorProto.ProfilerConfigOrBuilder> profilerConfigBuilder_;
        /**
         * <pre>
         * TODO: Remove from Node when switched to Profiler.
         * DEPRECATED: Configs for the profiler.
         * </pre>
         *
         * <code>optional .mediapipe.ProfilerConfig profiler_config = 15 [deprecated = true];</code>
         */
        @java.lang.Deprecated public boolean hasProfilerConfig() {
          return profilerConfigBuilder_ != null || profilerConfig_ != null;
        }
        /**
         * <pre>
         * TODO: Remove from Node when switched to Profiler.
         * DEPRECATED: Configs for the profiler.
         * </pre>
         *
         * <code>optional .mediapipe.ProfilerConfig profiler_config = 15 [deprecated = true];</code>
         */
        @java.lang.Deprecated public com.google.mediapipe.proto.CalculatorProto.ProfilerConfig getProfilerConfig() {
          if (profilerConfigBuilder_ == null) {
            return profilerConfig_ == null ? com.google.mediapipe.proto.CalculatorProto.ProfilerConfig.getDefaultInstance() : profilerConfig_;
          } else {
            return profilerConfigBuilder_.getMessage();
          }
        }
        /**
         * <pre>
         * TODO: Remove from Node when switched to Profiler.
         * DEPRECATED: Configs for the profiler.
         * </pre>
         *
         * <code>optional .mediapipe.ProfilerConfig profiler_config = 15 [deprecated = true];</code>
         */
        @java.lang.Deprecated public Builder setProfilerConfig(com.google.mediapipe.proto.CalculatorProto.ProfilerConfig value) {
          if (profilerConfigBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            profilerConfig_ = value;
            onChanged();
          } else {
            profilerConfigBuilder_.setMessage(value);
          }

          return this;
        }
        /**
         * <pre>
         * TODO: Remove from Node when switched to Profiler.
         * DEPRECATED: Configs for the profiler.
         * </pre>
         *
         * <code>optional .mediapipe.ProfilerConfig profiler_config = 15 [deprecated = true];</code>
         */
        @java.lang.Deprecated public Builder setProfilerConfig(
            com.google.mediapipe.proto.CalculatorProto.ProfilerConfig.Builder builderForValue) {
          if (profilerConfigBuilder_ == null) {
            profilerConfig_ = builderForValue.build();
            onChanged();
          } else {
            profilerConfigBuilder_.setMessage(builderForValue.build());
          }

          return this;
        }
        /**
         * <pre>
         * TODO: Remove from Node when switched to Profiler.
         * DEPRECATED: Configs for the profiler.
         * </pre>
         *
         * <code>optional .mediapipe.ProfilerConfig profiler_config = 15 [deprecated = true];</code>
         */
        @java.lang.Deprecated public Builder mergeProfilerConfig(com.google.mediapipe.proto.CalculatorProto.ProfilerConfig value) {
          if (profilerConfigBuilder_ == null) {
            if (profilerConfig_ != null) {
              profilerConfig_ =
                com.google.mediapipe.proto.CalculatorProto.ProfilerConfig.newBuilder(profilerConfig_).mergeFrom(value).buildPartial();
            } else {
              profilerConfig_ = value;
            }
            onChanged();
          } else {
            profilerConfigBuilder_.mergeFrom(value);
          }

          return this;
        }
        /**
         * <pre>
         * TODO: Remove from Node when switched to Profiler.
         * DEPRECATED: Configs for the profiler.
         * </pre>
         *
         * <code>optional .mediapipe.ProfilerConfig profiler_config = 15 [deprecated = true];</code>
         */
        @java.lang.Deprecated public Builder clearProfilerConfig() {
          if (profilerConfigBuilder_ == null) {
            profilerConfig_ = null;
            onChanged();
          } else {
            profilerConfig_ = null;
            profilerConfigBuilder_ = null;
          }

          return this;
        }
        /**
         * <pre>
         * TODO: Remove from Node when switched to Profiler.
         * DEPRECATED: Configs for the profiler.
         * </pre>
         *
         * <code>optional .mediapipe.ProfilerConfig profiler_config = 15 [deprecated = true];</code>
         */
        @java.lang.Deprecated public com.google.mediapipe.proto.CalculatorProto.ProfilerConfig.Builder getProfilerConfigBuilder() {
          

          onChanged();
          return getProfilerConfigFieldBuilder().getBuilder();
        }
        /**
         * <pre>
         * TODO: Remove from Node when switched to Profiler.
         * DEPRECATED: Configs for the profiler.
         * </pre>
         *
         * <code>optional .mediapipe.ProfilerConfig profiler_config = 15 [deprecated = true];</code>
         */
        @java.lang.Deprecated public com.google.mediapipe.proto.CalculatorProto.ProfilerConfigOrBuilder getProfilerConfigOrBuilder() {
          if (profilerConfigBuilder_ != null) {
            return profilerConfigBuilder_.getMessageOrBuilder();
          } else {
            return profilerConfig_ == null ?
                com.google.mediapipe.proto.CalculatorProto.ProfilerConfig.getDefaultInstance() : profilerConfig_;
          }
        }
        /**
         * <pre>
         * TODO: Remove from Node when switched to Profiler.
         * DEPRECATED: Configs for the profiler.
         * </pre>
         *
         * <code>optional .mediapipe.ProfilerConfig profiler_config = 15 [deprecated = true];</code>
         */
        private com.google.protobuf.SingleFieldBuilderV3<
            com.google.mediapipe.proto.CalculatorProto.ProfilerConfig, com.google.mediapipe.proto.CalculatorProto.ProfilerConfig.Builder, com.google.mediapipe.proto.CalculatorProto.ProfilerConfigOrBuilder> 
            getProfilerConfigFieldBuilder() {
          if (profilerConfigBuilder_ == null) {
            profilerConfigBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
                com.google.mediapipe.proto.CalculatorProto.ProfilerConfig, com.google.mediapipe.proto.CalculatorProto.ProfilerConfig.Builder, com.google.mediapipe.proto.CalculatorProto.ProfilerConfigOrBuilder>(
                    getProfilerConfig(),
                    getParentForChildren(),
                    isClean());
            profilerConfig_ = null;
          }
          return profilerConfigBuilder_;
        }

        private int maxInFlight_ ;
        /**
         * <pre>
         * The maximum number of invocations that can be executed in parallel.
         * If not specified, the limit is one invocation.
         * </pre>
         *
         * <code>optional int32 max_in_flight = 16;</code>
         */
        public int getMaxInFlight() {
          return maxInFlight_;
        }
        /**
         * <pre>
         * The maximum number of invocations that can be executed in parallel.
         * If not specified, the limit is one invocation.
         * </pre>
         *
         * <code>optional int32 max_in_flight = 16;</code>
         */
        public Builder setMaxInFlight(int value) {
          
          maxInFlight_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The maximum number of invocations that can be executed in parallel.
         * If not specified, the limit is one invocation.
         * </pre>
         *
         * <code>optional int32 max_in_flight = 16;</code>
         */
        public Builder clearMaxInFlight() {
          
          maxInFlight_ = 0;
          onChanged();
          return this;
        }

        private com.google.protobuf.LazyStringList externalInput_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        private void ensureExternalInputIsMutable() {
          if (!((bitField0_ & 0x00010000) == 0x00010000)) {
            externalInput_ = new com.google.protobuf.LazyStringArrayList(externalInput_);
            bitField0_ |= 0x00010000;
           }
        }
        /**
         * <pre>
         * DEPRECATED: For backwards compatibility we allow users to
         * specify the old name for "input_side_packet" in proto configs.
         * These are automatically converted to input_side_packets during
         * config canonicalization.
         * </pre>
         *
         * <code>repeated string external_input = 1005;</code>
         */
        public com.google.protobuf.ProtocolStringList
            getExternalInputList() {
          return externalInput_.getUnmodifiableView();
        }
        /**
         * <pre>
         * DEPRECATED: For backwards compatibility we allow users to
         * specify the old name for "input_side_packet" in proto configs.
         * These are automatically converted to input_side_packets during
         * config canonicalization.
         * </pre>
         *
         * <code>repeated string external_input = 1005;</code>
         */
        public int getExternalInputCount() {
          return externalInput_.size();
        }
        /**
         * <pre>
         * DEPRECATED: For backwards compatibility we allow users to
         * specify the old name for "input_side_packet" in proto configs.
         * These are automatically converted to input_side_packets during
         * config canonicalization.
         * </pre>
         *
         * <code>repeated string external_input = 1005;</code>
         */
        public java.lang.String getExternalInput(int index) {
          return externalInput_.get(index);
        }
        /**
         * <pre>
         * DEPRECATED: For backwards compatibility we allow users to
         * specify the old name for "input_side_packet" in proto configs.
         * These are automatically converted to input_side_packets during
         * config canonicalization.
         * </pre>
         *
         * <code>repeated string external_input = 1005;</code>
         */
        public com.google.protobuf.ByteString
            getExternalInputBytes(int index) {
          return externalInput_.getByteString(index);
        }
        /**
         * <pre>
         * DEPRECATED: For backwards compatibility we allow users to
         * specify the old name for "input_side_packet" in proto configs.
         * These are automatically converted to input_side_packets during
         * config canonicalization.
         * </pre>
         *
         * <code>repeated string external_input = 1005;</code>
         */
        public Builder setExternalInput(
            int index, java.lang.String value) {
          if (value == null) {
    throw new NullPointerException();
  }
  ensureExternalInputIsMutable();
          externalInput_.set(index, value);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * DEPRECATED: For backwards compatibility we allow users to
         * specify the old name for "input_side_packet" in proto configs.
         * These are automatically converted to input_side_packets during
         * config canonicalization.
         * </pre>
         *
         * <code>repeated string external_input = 1005;</code>
         */
        public Builder addExternalInput(
            java.lang.String value) {
          if (value == null) {
    throw new NullPointerException();
  }
  ensureExternalInputIsMutable();
          externalInput_.add(value);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * DEPRECATED: For backwards compatibility we allow users to
         * specify the old name for "input_side_packet" in proto configs.
         * These are automatically converted to input_side_packets during
         * config canonicalization.
         * </pre>
         *
         * <code>repeated string external_input = 1005;</code>
         */
        public Builder addAllExternalInput(
            java.lang.Iterable<java.lang.String> values) {
          ensureExternalInputIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, externalInput_);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * DEPRECATED: For backwards compatibility we allow users to
         * specify the old name for "input_side_packet" in proto configs.
         * These are automatically converted to input_side_packets during
         * config canonicalization.
         * </pre>
         *
         * <code>repeated string external_input = 1005;</code>
         */
        public Builder clearExternalInput() {
          externalInput_ = com.google.protobuf.LazyStringArrayList.EMPTY;
          bitField0_ = (bitField0_ & ~0x00010000);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * DEPRECATED: For backwards compatibility we allow users to
         * specify the old name for "input_side_packet" in proto configs.
         * These are automatically converted to input_side_packets during
         * config canonicalization.
         * </pre>
         *
         * <code>repeated string external_input = 1005;</code>
         */
        public Builder addExternalInputBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
          ensureExternalInputIsMutable();
          externalInput_.add(value);
          onChanged();
          return this;
        }
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return this;
        }

        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return this;
        }


        // @@protoc_insertion_point(builder_scope:mediapipe.CalculatorGraphConfig.Node)
      }

      // @@protoc_insertion_point(class_scope:mediapipe.CalculatorGraphConfig.Node)
      private static final com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node();
      }

      public static com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<Node>
          PARSER = new com.google.protobuf.AbstractParser<Node>() {
        public Node parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return new Node(input, extensionRegistry);
        }
      };

      public static com.google.protobuf.Parser<Node> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<Node> getParserForType() {
        return PARSER;
      }

      public com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    private int bitField0_;
    public static final int NODE_FIELD_NUMBER = 1;
    private java.util.List<com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node> node_;
    /**
     * <pre>
     * The nodes.
     * </pre>
     *
     * <code>repeated .mediapipe.CalculatorGraphConfig.Node node = 1;</code>
     */
    public java.util.List<com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node> getNodeList() {
      return node_;
    }
    /**
     * <pre>
     * The nodes.
     * </pre>
     *
     * <code>repeated .mediapipe.CalculatorGraphConfig.Node node = 1;</code>
     */
    public java.util.List<? extends com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.NodeOrBuilder> 
        getNodeOrBuilderList() {
      return node_;
    }
    /**
     * <pre>
     * The nodes.
     * </pre>
     *
     * <code>repeated .mediapipe.CalculatorGraphConfig.Node node = 1;</code>
     */
    public int getNodeCount() {
      return node_.size();
    }
    /**
     * <pre>
     * The nodes.
     * </pre>
     *
     * <code>repeated .mediapipe.CalculatorGraphConfig.Node node = 1;</code>
     */
    public com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node getNode(int index) {
      return node_.get(index);
    }
    /**
     * <pre>
     * The nodes.
     * </pre>
     *
     * <code>repeated .mediapipe.CalculatorGraphConfig.Node node = 1;</code>
     */
    public com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.NodeOrBuilder getNodeOrBuilder(
        int index) {
      return node_.get(index);
    }

    public static final int PACKET_FACTORY_FIELD_NUMBER = 6;
    private java.util.List<mediapipe.PacketFactory.PacketFactoryConfig> packetFactory_;
    /**
     * <pre>
     * Create a side packet using a PacketFactory.  This side packet is
     * created as close to the worker that does the work as possible.  A
     * PacketFactory is basically a PacketGenerator that takes no input side
     * packets and produces a single output side packet.
     * </pre>
     *
     * <code>repeated .mediapipe.PacketFactoryConfig packet_factory = 6;</code>
     */
    public java.util.List<mediapipe.PacketFactory.PacketFactoryConfig> getPacketFactoryList() {
      return packetFactory_;
    }
    /**
     * <pre>
     * Create a side packet using a PacketFactory.  This side packet is
     * created as close to the worker that does the work as possible.  A
     * PacketFactory is basically a PacketGenerator that takes no input side
     * packets and produces a single output side packet.
     * </pre>
     *
     * <code>repeated .mediapipe.PacketFactoryConfig packet_factory = 6;</code>
     */
    public java.util.List<? extends mediapipe.PacketFactory.PacketFactoryConfigOrBuilder> 
        getPacketFactoryOrBuilderList() {
      return packetFactory_;
    }
    /**
     * <pre>
     * Create a side packet using a PacketFactory.  This side packet is
     * created as close to the worker that does the work as possible.  A
     * PacketFactory is basically a PacketGenerator that takes no input side
     * packets and produces a single output side packet.
     * </pre>
     *
     * <code>repeated .mediapipe.PacketFactoryConfig packet_factory = 6;</code>
     */
    public int getPacketFactoryCount() {
      return packetFactory_.size();
    }
    /**
     * <pre>
     * Create a side packet using a PacketFactory.  This side packet is
     * created as close to the worker that does the work as possible.  A
     * PacketFactory is basically a PacketGenerator that takes no input side
     * packets and produces a single output side packet.
     * </pre>
     *
     * <code>repeated .mediapipe.PacketFactoryConfig packet_factory = 6;</code>
     */
    public mediapipe.PacketFactory.PacketFactoryConfig getPacketFactory(int index) {
      return packetFactory_.get(index);
    }
    /**
     * <pre>
     * Create a side packet using a PacketFactory.  This side packet is
     * created as close to the worker that does the work as possible.  A
     * PacketFactory is basically a PacketGenerator that takes no input side
     * packets and produces a single output side packet.
     * </pre>
     *
     * <code>repeated .mediapipe.PacketFactoryConfig packet_factory = 6;</code>
     */
    public mediapipe.PacketFactory.PacketFactoryConfigOrBuilder getPacketFactoryOrBuilder(
        int index) {
      return packetFactory_.get(index);
    }

    public static final int PACKET_GENERATOR_FIELD_NUMBER = 7;
    private java.util.List<mediapipe.PacketGenerator.PacketGeneratorConfig> packetGenerator_;
    /**
     * <pre>
     * Configs for PacketGenerators.  Generators take zero or more
     * input side packets and produce any number of output side
     * packets.  For example, MediaDecoderCalculator takes an input
     * side packet with type DeletingFile.  However, most users want
     * to specify videos by ContentIdHex (i.e. video id).  By using
     * the VideoIdToLocalFileGenerator, a user can specify a video id
     * (as a string) and obtain a DeletingFile to use with the decoder.
     * PacketGenerators can take as a input side packet the output side
     * packet of another PacketGenerator.  The graph of PacketGenerators
     * must be a directed acyclic graph.
     * </pre>
     *
     * <code>repeated .mediapipe.PacketGeneratorConfig packet_generator = 7;</code>
     */
    public java.util.List<mediapipe.PacketGenerator.PacketGeneratorConfig> getPacketGeneratorList() {
      return packetGenerator_;
    }
    /**
     * <pre>
     * Configs for PacketGenerators.  Generators take zero or more
     * input side packets and produce any number of output side
     * packets.  For example, MediaDecoderCalculator takes an input
     * side packet with type DeletingFile.  However, most users want
     * to specify videos by ContentIdHex (i.e. video id).  By using
     * the VideoIdToLocalFileGenerator, a user can specify a video id
     * (as a string) and obtain a DeletingFile to use with the decoder.
     * PacketGenerators can take as a input side packet the output side
     * packet of another PacketGenerator.  The graph of PacketGenerators
     * must be a directed acyclic graph.
     * </pre>
     *
     * <code>repeated .mediapipe.PacketGeneratorConfig packet_generator = 7;</code>
     */
    public java.util.List<? extends mediapipe.PacketGenerator.PacketGeneratorConfigOrBuilder> 
        getPacketGeneratorOrBuilderList() {
      return packetGenerator_;
    }
    /**
     * <pre>
     * Configs for PacketGenerators.  Generators take zero or more
     * input side packets and produce any number of output side
     * packets.  For example, MediaDecoderCalculator takes an input
     * side packet with type DeletingFile.  However, most users want
     * to specify videos by ContentIdHex (i.e. video id).  By using
     * the VideoIdToLocalFileGenerator, a user can specify a video id
     * (as a string) and obtain a DeletingFile to use with the decoder.
     * PacketGenerators can take as a input side packet the output side
     * packet of another PacketGenerator.  The graph of PacketGenerators
     * must be a directed acyclic graph.
     * </pre>
     *
     * <code>repeated .mediapipe.PacketGeneratorConfig packet_generator = 7;</code>
     */
    public int getPacketGeneratorCount() {
      return packetGenerator_.size();
    }
    /**
     * <pre>
     * Configs for PacketGenerators.  Generators take zero or more
     * input side packets and produce any number of output side
     * packets.  For example, MediaDecoderCalculator takes an input
     * side packet with type DeletingFile.  However, most users want
     * to specify videos by ContentIdHex (i.e. video id).  By using
     * the VideoIdToLocalFileGenerator, a user can specify a video id
     * (as a string) and obtain a DeletingFile to use with the decoder.
     * PacketGenerators can take as a input side packet the output side
     * packet of another PacketGenerator.  The graph of PacketGenerators
     * must be a directed acyclic graph.
     * </pre>
     *
     * <code>repeated .mediapipe.PacketGeneratorConfig packet_generator = 7;</code>
     */
    public mediapipe.PacketGenerator.PacketGeneratorConfig getPacketGenerator(int index) {
      return packetGenerator_.get(index);
    }
    /**
     * <pre>
     * Configs for PacketGenerators.  Generators take zero or more
     * input side packets and produce any number of output side
     * packets.  For example, MediaDecoderCalculator takes an input
     * side packet with type DeletingFile.  However, most users want
     * to specify videos by ContentIdHex (i.e. video id).  By using
     * the VideoIdToLocalFileGenerator, a user can specify a video id
     * (as a string) and obtain a DeletingFile to use with the decoder.
     * PacketGenerators can take as a input side packet the output side
     * packet of another PacketGenerator.  The graph of PacketGenerators
     * must be a directed acyclic graph.
     * </pre>
     *
     * <code>repeated .mediapipe.PacketGeneratorConfig packet_generator = 7;</code>
     */
    public mediapipe.PacketGenerator.PacketGeneratorConfigOrBuilder getPacketGeneratorOrBuilder(
        int index) {
      return packetGenerator_.get(index);
    }

    public static final int NUM_THREADS_FIELD_NUMBER = 8;
    private int numThreads_;
    /**
     * <pre>
     * Number of threads for running calculators in multithreaded mode.
     * If not specified, the scheduler will pick an appropriate number
     * of threads depending on the number of available processors.
     * To run on the calling thread, specify "ApplicationThreadExecutor"
     * see: http://g3doc/mediapipe/g3doc/running.md.
     * </pre>
     *
     * <code>optional int32 num_threads = 8;</code>
     */
    public int getNumThreads() {
      return numThreads_;
    }

    public static final int STATUS_HANDLER_FIELD_NUMBER = 9;
    private java.util.List<mediapipe.StatusHandler.StatusHandlerConfig> statusHandler_;
    /**
     * <pre>
     * Configs for StatusHandlers that will be called after each call to
     * Run() on the graph.  StatusHandlers take zero or more input side
     * packets and the ::util::Status returned by a graph run.  For example,
     * a StatusHandler could store information about graph failures and
     * their causes for later monitoring.  Note that graph failures during
     * initialization may cause required input side packets (created by a
     * PacketFactory or PacketGenerator) to be missing.  In these cases,
     * the handler with missing input side packets will be skipped.
     * </pre>
     *
     * <code>repeated .mediapipe.StatusHandlerConfig status_handler = 9;</code>
     */
    public java.util.List<mediapipe.StatusHandler.StatusHandlerConfig> getStatusHandlerList() {
      return statusHandler_;
    }
    /**
     * <pre>
     * Configs for StatusHandlers that will be called after each call to
     * Run() on the graph.  StatusHandlers take zero or more input side
     * packets and the ::util::Status returned by a graph run.  For example,
     * a StatusHandler could store information about graph failures and
     * their causes for later monitoring.  Note that graph failures during
     * initialization may cause required input side packets (created by a
     * PacketFactory or PacketGenerator) to be missing.  In these cases,
     * the handler with missing input side packets will be skipped.
     * </pre>
     *
     * <code>repeated .mediapipe.StatusHandlerConfig status_handler = 9;</code>
     */
    public java.util.List<? extends mediapipe.StatusHandler.StatusHandlerConfigOrBuilder> 
        getStatusHandlerOrBuilderList() {
      return statusHandler_;
    }
    /**
     * <pre>
     * Configs for StatusHandlers that will be called after each call to
     * Run() on the graph.  StatusHandlers take zero or more input side
     * packets and the ::util::Status returned by a graph run.  For example,
     * a StatusHandler could store information about graph failures and
     * their causes for later monitoring.  Note that graph failures during
     * initialization may cause required input side packets (created by a
     * PacketFactory or PacketGenerator) to be missing.  In these cases,
     * the handler with missing input side packets will be skipped.
     * </pre>
     *
     * <code>repeated .mediapipe.StatusHandlerConfig status_handler = 9;</code>
     */
    public int getStatusHandlerCount() {
      return statusHandler_.size();
    }
    /**
     * <pre>
     * Configs for StatusHandlers that will be called after each call to
     * Run() on the graph.  StatusHandlers take zero or more input side
     * packets and the ::util::Status returned by a graph run.  For example,
     * a StatusHandler could store information about graph failures and
     * their causes for later monitoring.  Note that graph failures during
     * initialization may cause required input side packets (created by a
     * PacketFactory or PacketGenerator) to be missing.  In these cases,
     * the handler with missing input side packets will be skipped.
     * </pre>
     *
     * <code>repeated .mediapipe.StatusHandlerConfig status_handler = 9;</code>
     */
    public mediapipe.StatusHandler.StatusHandlerConfig getStatusHandler(int index) {
      return statusHandler_.get(index);
    }
    /**
     * <pre>
     * Configs for StatusHandlers that will be called after each call to
     * Run() on the graph.  StatusHandlers take zero or more input side
     * packets and the ::util::Status returned by a graph run.  For example,
     * a StatusHandler could store information about graph failures and
     * their causes for later monitoring.  Note that graph failures during
     * initialization may cause required input side packets (created by a
     * PacketFactory or PacketGenerator) to be missing.  In these cases,
     * the handler with missing input side packets will be skipped.
     * </pre>
     *
     * <code>repeated .mediapipe.StatusHandlerConfig status_handler = 9;</code>
     */
    public mediapipe.StatusHandler.StatusHandlerConfigOrBuilder getStatusHandlerOrBuilder(
        int index) {
      return statusHandler_.get(index);
    }

    public static final int INPUT_STREAM_FIELD_NUMBER = 10;
    private com.google.protobuf.LazyStringList inputStream_;
    /**
     * <pre>
     * Specify input streams to the entire graph.  Streams specified here may have
     * packets added to them using CalculatorGraph::AddPacketToInputStream.  This
     * works much like a source calculator, except that the source is outside of
     * the mediapipe graph.
     * </pre>
     *
     * <code>repeated string input_stream = 10;</code>
     */
    public com.google.protobuf.ProtocolStringList
        getInputStreamList() {
      return inputStream_;
    }
    /**
     * <pre>
     * Specify input streams to the entire graph.  Streams specified here may have
     * packets added to them using CalculatorGraph::AddPacketToInputStream.  This
     * works much like a source calculator, except that the source is outside of
     * the mediapipe graph.
     * </pre>
     *
     * <code>repeated string input_stream = 10;</code>
     */
    public int getInputStreamCount() {
      return inputStream_.size();
    }
    /**
     * <pre>
     * Specify input streams to the entire graph.  Streams specified here may have
     * packets added to them using CalculatorGraph::AddPacketToInputStream.  This
     * works much like a source calculator, except that the source is outside of
     * the mediapipe graph.
     * </pre>
     *
     * <code>repeated string input_stream = 10;</code>
     */
    public java.lang.String getInputStream(int index) {
      return inputStream_.get(index);
    }
    /**
     * <pre>
     * Specify input streams to the entire graph.  Streams specified here may have
     * packets added to them using CalculatorGraph::AddPacketToInputStream.  This
     * works much like a source calculator, except that the source is outside of
     * the mediapipe graph.
     * </pre>
     *
     * <code>repeated string input_stream = 10;</code>
     */
    public com.google.protobuf.ByteString
        getInputStreamBytes(int index) {
      return inputStream_.getByteString(index);
    }

    public static final int OUTPUT_STREAM_FIELD_NUMBER = 15;
    private com.google.protobuf.LazyStringList outputStream_;
    /**
     * <pre>
     * Output streams for the graph when used as a subgraph.
     * </pre>
     *
     * <code>repeated string output_stream = 15;</code>
     */
    public com.google.protobuf.ProtocolStringList
        getOutputStreamList() {
      return outputStream_;
    }
    /**
     * <pre>
     * Output streams for the graph when used as a subgraph.
     * </pre>
     *
     * <code>repeated string output_stream = 15;</code>
     */
    public int getOutputStreamCount() {
      return outputStream_.size();
    }
    /**
     * <pre>
     * Output streams for the graph when used as a subgraph.
     * </pre>
     *
     * <code>repeated string output_stream = 15;</code>
     */
    public java.lang.String getOutputStream(int index) {
      return outputStream_.get(index);
    }
    /**
     * <pre>
     * Output streams for the graph when used as a subgraph.
     * </pre>
     *
     * <code>repeated string output_stream = 15;</code>
     */
    public com.google.protobuf.ByteString
        getOutputStreamBytes(int index) {
      return outputStream_.getByteString(index);
    }

    public static final int INPUT_SIDE_PACKET_FIELD_NUMBER = 16;
    private com.google.protobuf.LazyStringList inputSidePacket_;
    /**
     * <pre>
     * Input side packets for the graph when used as a subgraph.
     * </pre>
     *
     * <code>repeated string input_side_packet = 16;</code>
     */
    public com.google.protobuf.ProtocolStringList
        getInputSidePacketList() {
      return inputSidePacket_;
    }
    /**
     * <pre>
     * Input side packets for the graph when used as a subgraph.
     * </pre>
     *
     * <code>repeated string input_side_packet = 16;</code>
     */
    public int getInputSidePacketCount() {
      return inputSidePacket_.size();
    }
    /**
     * <pre>
     * Input side packets for the graph when used as a subgraph.
     * </pre>
     *
     * <code>repeated string input_side_packet = 16;</code>
     */
    public java.lang.String getInputSidePacket(int index) {
      return inputSidePacket_.get(index);
    }
    /**
     * <pre>
     * Input side packets for the graph when used as a subgraph.
     * </pre>
     *
     * <code>repeated string input_side_packet = 16;</code>
     */
    public com.google.protobuf.ByteString
        getInputSidePacketBytes(int index) {
      return inputSidePacket_.getByteString(index);
    }

    public static final int OUTPUT_SIDE_PACKET_FIELD_NUMBER = 17;
    private com.google.protobuf.LazyStringList outputSidePacket_;
    /**
     * <pre>
     * Output side packets for the graph when used as a subgraph.
     * </pre>
     *
     * <code>repeated string output_side_packet = 17;</code>
     */
    public com.google.protobuf.ProtocolStringList
        getOutputSidePacketList() {
      return outputSidePacket_;
    }
    /**
     * <pre>
     * Output side packets for the graph when used as a subgraph.
     * </pre>
     *
     * <code>repeated string output_side_packet = 17;</code>
     */
    public int getOutputSidePacketCount() {
      return outputSidePacket_.size();
    }
    /**
     * <pre>
     * Output side packets for the graph when used as a subgraph.
     * </pre>
     *
     * <code>repeated string output_side_packet = 17;</code>
     */
    public java.lang.String getOutputSidePacket(int index) {
      return outputSidePacket_.get(index);
    }
    /**
     * <pre>
     * Output side packets for the graph when used as a subgraph.
     * </pre>
     *
     * <code>repeated string output_side_packet = 17;</code>
     */
    public com.google.protobuf.ByteString
        getOutputSidePacketBytes(int index) {
      return outputSidePacket_.getByteString(index);
    }

    public static final int MAX_QUEUE_SIZE_FIELD_NUMBER = 11;
    private int maxQueueSize_;
    /**
     * <pre>
     * Maximum queue size of any input stream in the graph. This can be used to
     * control the memory usage of a MediaPipe graph by preventing fast sources
     * from flooding the graph with packets. Any source that is connected to an
     * input stream that has hit its maximum capacity will not be scheduled until
     * the queue size falls under the specified limits, or if the scheduler queue
     * is empty and no other nodes are running (to prevent possible deadlocks due
     * to a incorrectly specified value). This global parameter is set to 100
     * packets by default to enable pipelining. If any node indicates that it
     * buffers packets before emitting them, then the max(node_buffer_size,
     * max_queue_size) is used. Set this parameter to -1 to disable throttling
     * (i.e. the graph will use as much memory as it requires). If not specified,
     * the limit is 100 packets.
     * </pre>
     *
     * <code>optional int32 max_queue_size = 11;</code>
     */
    public int getMaxQueueSize() {
      return maxQueueSize_;
    }

    public static final int REPORT_DEADLOCK_FIELD_NUMBER = 21;
    private boolean reportDeadlock_;
    /**
     * <pre>
     * If true, the graph run fails with an error when throttling prevents all
     * calculators from running.  If false, max_queue_size for an input stream
     * is adjusted when throttling prevents all calculators from running.
     * </pre>
     *
     * <code>optional bool report_deadlock = 21;</code>
     */
    public boolean getReportDeadlock() {
      return reportDeadlock_;
    }

    public static final int INPUT_STREAM_HANDLER_FIELD_NUMBER = 12;
    private mediapipe.StreamHandler.InputStreamHandlerConfig inputStreamHandler_;
    /**
     * <pre>
     * Config for this graph's InputStreamHandler.
     * If unspecified, the framework will automatically install the default
     * handler, which works as follows.
     * The calculator's Process() method is called for timestamp t when:
     * - at least one stream has a packet available at t; and,
     * - all other streams either have packets at t, or it is known that they will
     * not have packets at t (i.e. their next timestamp bound is greater than t).
     * The handler then provides all available packets with timestamp t, with no
     * preprocessing.
     * </pre>
     *
     * <code>optional .mediapipe.InputStreamHandlerConfig input_stream_handler = 12;</code>
     */
    public boolean hasInputStreamHandler() {
      return inputStreamHandler_ != null;
    }
    /**
     * <pre>
     * Config for this graph's InputStreamHandler.
     * If unspecified, the framework will automatically install the default
     * handler, which works as follows.
     * The calculator's Process() method is called for timestamp t when:
     * - at least one stream has a packet available at t; and,
     * - all other streams either have packets at t, or it is known that they will
     * not have packets at t (i.e. their next timestamp bound is greater than t).
     * The handler then provides all available packets with timestamp t, with no
     * preprocessing.
     * </pre>
     *
     * <code>optional .mediapipe.InputStreamHandlerConfig input_stream_handler = 12;</code>
     */
    public mediapipe.StreamHandler.InputStreamHandlerConfig getInputStreamHandler() {
      return inputStreamHandler_ == null ? mediapipe.StreamHandler.InputStreamHandlerConfig.getDefaultInstance() : inputStreamHandler_;
    }
    /**
     * <pre>
     * Config for this graph's InputStreamHandler.
     * If unspecified, the framework will automatically install the default
     * handler, which works as follows.
     * The calculator's Process() method is called for timestamp t when:
     * - at least one stream has a packet available at t; and,
     * - all other streams either have packets at t, or it is known that they will
     * not have packets at t (i.e. their next timestamp bound is greater than t).
     * The handler then provides all available packets with timestamp t, with no
     * preprocessing.
     * </pre>
     *
     * <code>optional .mediapipe.InputStreamHandlerConfig input_stream_handler = 12;</code>
     */
    public mediapipe.StreamHandler.InputStreamHandlerConfigOrBuilder getInputStreamHandlerOrBuilder() {
      return getInputStreamHandler();
    }

    public static final int OUTPUT_STREAM_HANDLER_FIELD_NUMBER = 13;
    private mediapipe.StreamHandler.OutputStreamHandlerConfig outputStreamHandler_;
    /**
     * <pre>
     * Config for this graph's OutputStreamHandler.
     * If unspecified, the default output stream handler will be automatically
     * installed by the framework which does not modify any outgoing packets.
     * </pre>
     *
     * <code>optional .mediapipe.OutputStreamHandlerConfig output_stream_handler = 13;</code>
     */
    public boolean hasOutputStreamHandler() {
      return outputStreamHandler_ != null;
    }
    /**
     * <pre>
     * Config for this graph's OutputStreamHandler.
     * If unspecified, the default output stream handler will be automatically
     * installed by the framework which does not modify any outgoing packets.
     * </pre>
     *
     * <code>optional .mediapipe.OutputStreamHandlerConfig output_stream_handler = 13;</code>
     */
    public mediapipe.StreamHandler.OutputStreamHandlerConfig getOutputStreamHandler() {
      return outputStreamHandler_ == null ? mediapipe.StreamHandler.OutputStreamHandlerConfig.getDefaultInstance() : outputStreamHandler_;
    }
    /**
     * <pre>
     * Config for this graph's OutputStreamHandler.
     * If unspecified, the default output stream handler will be automatically
     * installed by the framework which does not modify any outgoing packets.
     * </pre>
     *
     * <code>optional .mediapipe.OutputStreamHandlerConfig output_stream_handler = 13;</code>
     */
    public mediapipe.StreamHandler.OutputStreamHandlerConfigOrBuilder getOutputStreamHandlerOrBuilder() {
      return getOutputStreamHandler();
    }

    public static final int EXECUTOR_FIELD_NUMBER = 14;
    private java.util.List<com.google.mediapipe.proto.CalculatorProto.ExecutorConfig> executor_;
    /**
     * <pre>
     * Configs for Executors.
     * The names of the executors must be distinct. The default executor, whose
     * name is the empty string, is predefined. The num_threads field of the
     * CalculatorGraphConfig specifies the number of threads in the default
     * executor. If the config for the default executor is specified, the
     * CalculatorGraphConfig must not have the num_threads field.
     * </pre>
     *
     * <code>repeated .mediapipe.ExecutorConfig executor = 14;</code>
     */
    public java.util.List<com.google.mediapipe.proto.CalculatorProto.ExecutorConfig> getExecutorList() {
      return executor_;
    }
    /**
     * <pre>
     * Configs for Executors.
     * The names of the executors must be distinct. The default executor, whose
     * name is the empty string, is predefined. The num_threads field of the
     * CalculatorGraphConfig specifies the number of threads in the default
     * executor. If the config for the default executor is specified, the
     * CalculatorGraphConfig must not have the num_threads field.
     * </pre>
     *
     * <code>repeated .mediapipe.ExecutorConfig executor = 14;</code>
     */
    public java.util.List<? extends com.google.mediapipe.proto.CalculatorProto.ExecutorConfigOrBuilder> 
        getExecutorOrBuilderList() {
      return executor_;
    }
    /**
     * <pre>
     * Configs for Executors.
     * The names of the executors must be distinct. The default executor, whose
     * name is the empty string, is predefined. The num_threads field of the
     * CalculatorGraphConfig specifies the number of threads in the default
     * executor. If the config for the default executor is specified, the
     * CalculatorGraphConfig must not have the num_threads field.
     * </pre>
     *
     * <code>repeated .mediapipe.ExecutorConfig executor = 14;</code>
     */
    public int getExecutorCount() {
      return executor_.size();
    }
    /**
     * <pre>
     * Configs for Executors.
     * The names of the executors must be distinct. The default executor, whose
     * name is the empty string, is predefined. The num_threads field of the
     * CalculatorGraphConfig specifies the number of threads in the default
     * executor. If the config for the default executor is specified, the
     * CalculatorGraphConfig must not have the num_threads field.
     * </pre>
     *
     * <code>repeated .mediapipe.ExecutorConfig executor = 14;</code>
     */
    public com.google.mediapipe.proto.CalculatorProto.ExecutorConfig getExecutor(int index) {
      return executor_.get(index);
    }
    /**
     * <pre>
     * Configs for Executors.
     * The names of the executors must be distinct. The default executor, whose
     * name is the empty string, is predefined. The num_threads field of the
     * CalculatorGraphConfig specifies the number of threads in the default
     * executor. If the config for the default executor is specified, the
     * CalculatorGraphConfig must not have the num_threads field.
     * </pre>
     *
     * <code>repeated .mediapipe.ExecutorConfig executor = 14;</code>
     */
    public com.google.mediapipe.proto.CalculatorProto.ExecutorConfigOrBuilder getExecutorOrBuilder(
        int index) {
      return executor_.get(index);
    }

    public static final int PROFILER_CONFIG_FIELD_NUMBER = 18;
    private com.google.mediapipe.proto.CalculatorProto.ProfilerConfig profilerConfig_;
    /**
     * <pre>
     * The default profiler-config for all calculators.  If set, this defines the
     * profiling settings such as num_histogram_intervals for every calculator in
     * the graph.  Each of these settings can be overridden by the
     * |profiler_config| specified for a node.
     * </pre>
     *
     * <code>optional .mediapipe.ProfilerConfig profiler_config = 18;</code>
     */
    public boolean hasProfilerConfig() {
      return profilerConfig_ != null;
    }
    /**
     * <pre>
     * The default profiler-config for all calculators.  If set, this defines the
     * profiling settings such as num_histogram_intervals for every calculator in
     * the graph.  Each of these settings can be overridden by the
     * |profiler_config| specified for a node.
     * </pre>
     *
     * <code>optional .mediapipe.ProfilerConfig profiler_config = 18;</code>
     */
    public com.google.mediapipe.proto.CalculatorProto.ProfilerConfig getProfilerConfig() {
      return profilerConfig_ == null ? com.google.mediapipe.proto.CalculatorProto.ProfilerConfig.getDefaultInstance() : profilerConfig_;
    }
    /**
     * <pre>
     * The default profiler-config for all calculators.  If set, this defines the
     * profiling settings such as num_histogram_intervals for every calculator in
     * the graph.  Each of these settings can be overridden by the
     * |profiler_config| specified for a node.
     * </pre>
     *
     * <code>optional .mediapipe.ProfilerConfig profiler_config = 18;</code>
     */
    public com.google.mediapipe.proto.CalculatorProto.ProfilerConfigOrBuilder getProfilerConfigOrBuilder() {
      return getProfilerConfig();
    }

    public static final int PACKAGE_FIELD_NUMBER = 19;
    private volatile java.lang.Object package_;
    /**
     * <pre>
     * The namespace used for class name lookup within this graph.
     * An unqualified or partially qualified class name is looked up in
     * this namespace first and then in enclosing namespaces.
     * </pre>
     *
     * <code>optional string package = 19;</code>
     */
    public java.lang.String getPackage() {
      java.lang.Object ref = package_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        package_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The namespace used for class name lookup within this graph.
     * An unqualified or partially qualified class name is looked up in
     * this namespace first and then in enclosing namespaces.
     * </pre>
     *
     * <code>optional string package = 19;</code>
     */
    public com.google.protobuf.ByteString
        getPackageBytes() {
      java.lang.Object ref = package_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        package_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int TYPE_FIELD_NUMBER = 20;
    private volatile java.lang.Object type_;
    /**
     * <pre>
     * The type name for the graph config, used for registering and referencing
     * the graph config.
     * </pre>
     *
     * <code>optional string type = 20;</code>
     */
    public java.lang.String getType() {
      java.lang.Object ref = type_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        type_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The type name for the graph config, used for registering and referencing
     * the graph config.
     * </pre>
     *
     * <code>optional string type = 20;</code>
     */
    public com.google.protobuf.ByteString
        getTypeBytes() {
      java.lang.Object ref = type_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        type_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int OPTIONS_FIELD_NUMBER = 1001;
    private mediapipe.MediapipeOptions.MediaPipeOptions options_;
    /**
     * <pre>
     * Can be used for annotating a graph.
     * </pre>
     *
     * <code>optional .mediapipe.MediaPipeOptions options = 1001;</code>
     */
    public boolean hasOptions() {
      return options_ != null;
    }
    /**
     * <pre>
     * Can be used for annotating a graph.
     * </pre>
     *
     * <code>optional .mediapipe.MediaPipeOptions options = 1001;</code>
     */
    public mediapipe.MediapipeOptions.MediaPipeOptions getOptions() {
      return options_ == null ? mediapipe.MediapipeOptions.MediaPipeOptions.getDefaultInstance() : options_;
    }
    /**
     * <pre>
     * Can be used for annotating a graph.
     * </pre>
     *
     * <code>optional .mediapipe.MediaPipeOptions options = 1001;</code>
     */
    public mediapipe.MediapipeOptions.MediaPipeOptionsOrBuilder getOptionsOrBuilder() {
      return getOptions();
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      for (int i = 0; i < getNodeCount(); i++) {
        if (!getNode(i).isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      for (int i = 0; i < getPacketFactoryCount(); i++) {
        if (!getPacketFactory(i).isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      for (int i = 0; i < getPacketGeneratorCount(); i++) {
        if (!getPacketGenerator(i).isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      for (int i = 0; i < getStatusHandlerCount(); i++) {
        if (!getStatusHandler(i).isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      if (hasInputStreamHandler()) {
        if (!getInputStreamHandler().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      if (hasOutputStreamHandler()) {
        if (!getOutputStreamHandler().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      for (int i = 0; i < getExecutorCount(); i++) {
        if (!getExecutor(i).isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      if (hasOptions()) {
        if (!getOptions().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < node_.size(); i++) {
        output.writeMessage(1, node_.get(i));
      }
      for (int i = 0; i < packetFactory_.size(); i++) {
        output.writeMessage(6, packetFactory_.get(i));
      }
      for (int i = 0; i < packetGenerator_.size(); i++) {
        output.writeMessage(7, packetGenerator_.get(i));
      }
      if (numThreads_ != 0) {
        output.writeInt32(8, numThreads_);
      }
      for (int i = 0; i < statusHandler_.size(); i++) {
        output.writeMessage(9, statusHandler_.get(i));
      }
      for (int i = 0; i < inputStream_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 10, inputStream_.getRaw(i));
      }
      if (maxQueueSize_ != 0) {
        output.writeInt32(11, maxQueueSize_);
      }
      if (inputStreamHandler_ != null) {
        output.writeMessage(12, getInputStreamHandler());
      }
      if (outputStreamHandler_ != null) {
        output.writeMessage(13, getOutputStreamHandler());
      }
      for (int i = 0; i < executor_.size(); i++) {
        output.writeMessage(14, executor_.get(i));
      }
      for (int i = 0; i < outputStream_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 15, outputStream_.getRaw(i));
      }
      for (int i = 0; i < inputSidePacket_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 16, inputSidePacket_.getRaw(i));
      }
      for (int i = 0; i < outputSidePacket_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 17, outputSidePacket_.getRaw(i));
      }
      if (profilerConfig_ != null) {
        output.writeMessage(18, getProfilerConfig());
      }
      if (!getPackageBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 19, package_);
      }
      if (!getTypeBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 20, type_);
      }
      if (reportDeadlock_ != false) {
        output.writeBool(21, reportDeadlock_);
      }
      if (options_ != null) {
        output.writeMessage(1001, getOptions());
      }
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < node_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, node_.get(i));
      }
      for (int i = 0; i < packetFactory_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(6, packetFactory_.get(i));
      }
      for (int i = 0; i < packetGenerator_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(7, packetGenerator_.get(i));
      }
      if (numThreads_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(8, numThreads_);
      }
      for (int i = 0; i < statusHandler_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(9, statusHandler_.get(i));
      }
      {
        int dataSize = 0;
        for (int i = 0; i < inputStream_.size(); i++) {
          dataSize += computeStringSizeNoTag(inputStream_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getInputStreamList().size();
      }
      if (maxQueueSize_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(11, maxQueueSize_);
      }
      if (inputStreamHandler_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(12, getInputStreamHandler());
      }
      if (outputStreamHandler_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(13, getOutputStreamHandler());
      }
      for (int i = 0; i < executor_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(14, executor_.get(i));
      }
      {
        int dataSize = 0;
        for (int i = 0; i < outputStream_.size(); i++) {
          dataSize += computeStringSizeNoTag(outputStream_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getOutputStreamList().size();
      }
      {
        int dataSize = 0;
        for (int i = 0; i < inputSidePacket_.size(); i++) {
          dataSize += computeStringSizeNoTag(inputSidePacket_.getRaw(i));
        }
        size += dataSize;
        size += 2 * getInputSidePacketList().size();
      }
      {
        int dataSize = 0;
        for (int i = 0; i < outputSidePacket_.size(); i++) {
          dataSize += computeStringSizeNoTag(outputSidePacket_.getRaw(i));
        }
        size += dataSize;
        size += 2 * getOutputSidePacketList().size();
      }
      if (profilerConfig_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(18, getProfilerConfig());
      }
      if (!getPackageBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(19, package_);
      }
      if (!getTypeBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(20, type_);
      }
      if (reportDeadlock_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(21, reportDeadlock_);
      }
      if (options_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1001, getOptions());
      }
      memoizedSize = size;
      return size;
    }

    private static final long serialVersionUID = 0L;
    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig)) {
        return super.equals(obj);
      }
      com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig other = (com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig) obj;

      boolean result = true;
      result = result && getNodeList()
          .equals(other.getNodeList());
      result = result && getPacketFactoryList()
          .equals(other.getPacketFactoryList());
      result = result && getPacketGeneratorList()
          .equals(other.getPacketGeneratorList());
      result = result && (getNumThreads()
          == other.getNumThreads());
      result = result && getStatusHandlerList()
          .equals(other.getStatusHandlerList());
      result = result && getInputStreamList()
          .equals(other.getInputStreamList());
      result = result && getOutputStreamList()
          .equals(other.getOutputStreamList());
      result = result && getInputSidePacketList()
          .equals(other.getInputSidePacketList());
      result = result && getOutputSidePacketList()
          .equals(other.getOutputSidePacketList());
      result = result && (getMaxQueueSize()
          == other.getMaxQueueSize());
      result = result && (getReportDeadlock()
          == other.getReportDeadlock());
      result = result && (hasInputStreamHandler() == other.hasInputStreamHandler());
      if (hasInputStreamHandler()) {
        result = result && getInputStreamHandler()
            .equals(other.getInputStreamHandler());
      }
      result = result && (hasOutputStreamHandler() == other.hasOutputStreamHandler());
      if (hasOutputStreamHandler()) {
        result = result && getOutputStreamHandler()
            .equals(other.getOutputStreamHandler());
      }
      result = result && getExecutorList()
          .equals(other.getExecutorList());
      result = result && (hasProfilerConfig() == other.hasProfilerConfig());
      if (hasProfilerConfig()) {
        result = result && getProfilerConfig()
            .equals(other.getProfilerConfig());
      }
      result = result && getPackage()
          .equals(other.getPackage());
      result = result && getType()
          .equals(other.getType());
      result = result && (hasOptions() == other.hasOptions());
      if (hasOptions()) {
        result = result && getOptions()
            .equals(other.getOptions());
      }
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptorForType().hashCode();
      if (getNodeCount() > 0) {
        hash = (37 * hash) + NODE_FIELD_NUMBER;
        hash = (53 * hash) + getNodeList().hashCode();
      }
      if (getPacketFactoryCount() > 0) {
        hash = (37 * hash) + PACKET_FACTORY_FIELD_NUMBER;
        hash = (53 * hash) + getPacketFactoryList().hashCode();
      }
      if (getPacketGeneratorCount() > 0) {
        hash = (37 * hash) + PACKET_GENERATOR_FIELD_NUMBER;
        hash = (53 * hash) + getPacketGeneratorList().hashCode();
      }
      hash = (37 * hash) + NUM_THREADS_FIELD_NUMBER;
      hash = (53 * hash) + getNumThreads();
      if (getStatusHandlerCount() > 0) {
        hash = (37 * hash) + STATUS_HANDLER_FIELD_NUMBER;
        hash = (53 * hash) + getStatusHandlerList().hashCode();
      }
      if (getInputStreamCount() > 0) {
        hash = (37 * hash) + INPUT_STREAM_FIELD_NUMBER;
        hash = (53 * hash) + getInputStreamList().hashCode();
      }
      if (getOutputStreamCount() > 0) {
        hash = (37 * hash) + OUTPUT_STREAM_FIELD_NUMBER;
        hash = (53 * hash) + getOutputStreamList().hashCode();
      }
      if (getInputSidePacketCount() > 0) {
        hash = (37 * hash) + INPUT_SIDE_PACKET_FIELD_NUMBER;
        hash = (53 * hash) + getInputSidePacketList().hashCode();
      }
      if (getOutputSidePacketCount() > 0) {
        hash = (37 * hash) + OUTPUT_SIDE_PACKET_FIELD_NUMBER;
        hash = (53 * hash) + getOutputSidePacketList().hashCode();
      }
      hash = (37 * hash) + MAX_QUEUE_SIZE_FIELD_NUMBER;
      hash = (53 * hash) + getMaxQueueSize();
      hash = (37 * hash) + REPORT_DEADLOCK_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getReportDeadlock());
      if (hasInputStreamHandler()) {
        hash = (37 * hash) + INPUT_STREAM_HANDLER_FIELD_NUMBER;
        hash = (53 * hash) + getInputStreamHandler().hashCode();
      }
      if (hasOutputStreamHandler()) {
        hash = (37 * hash) + OUTPUT_STREAM_HANDLER_FIELD_NUMBER;
        hash = (53 * hash) + getOutputStreamHandler().hashCode();
      }
      if (getExecutorCount() > 0) {
        hash = (37 * hash) + EXECUTOR_FIELD_NUMBER;
        hash = (53 * hash) + getExecutorList().hashCode();
      }
      if (hasProfilerConfig()) {
        hash = (37 * hash) + PROFILER_CONFIG_FIELD_NUMBER;
        hash = (53 * hash) + getProfilerConfig().hashCode();
      }
      hash = (37 * hash) + PACKAGE_FIELD_NUMBER;
      hash = (53 * hash) + getPackage().hashCode();
      hash = (37 * hash) + TYPE_FIELD_NUMBER;
      hash = (53 * hash) + getType().hashCode();
      if (hasOptions()) {
        hash = (37 * hash) + OPTIONS_FIELD_NUMBER;
        hash = (53 * hash) + getOptions().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Describes the topology and function of a MediaPipe Graph.  The graph of
     * Nodes must be a Directed Acyclic Graph (DAG) except as annotated by
     * "back_edge" in InputStreamInfo.  Use a mediapipe::CalculatorGraph object to
     * run the graph.
     * </pre>
     *
     * Protobuf type {@code mediapipe.CalculatorGraphConfig}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:mediapipe.CalculatorGraphConfig)
        com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfigOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.google.mediapipe.proto.CalculatorProto.internal_static_mediapipe_CalculatorGraphConfig_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.google.mediapipe.proto.CalculatorProto.internal_static_mediapipe_CalculatorGraphConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.class, com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Builder.class);
      }

      // Construct using com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getNodeFieldBuilder();
          getPacketFactoryFieldBuilder();
          getPacketGeneratorFieldBuilder();
          getStatusHandlerFieldBuilder();
          getExecutorFieldBuilder();
        }
      }
      public Builder clear() {
        super.clear();
        if (nodeBuilder_ == null) {
          node_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
        } else {
          nodeBuilder_.clear();
        }
        if (packetFactoryBuilder_ == null) {
          packetFactory_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
        } else {
          packetFactoryBuilder_.clear();
        }
        if (packetGeneratorBuilder_ == null) {
          packetGenerator_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
        } else {
          packetGeneratorBuilder_.clear();
        }
        numThreads_ = 0;

        if (statusHandlerBuilder_ == null) {
          statusHandler_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000010);
        } else {
          statusHandlerBuilder_.clear();
        }
        inputStream_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000020);
        outputStream_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000040);
        inputSidePacket_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000080);
        outputSidePacket_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000100);
        maxQueueSize_ = 0;

        reportDeadlock_ = false;

        if (inputStreamHandlerBuilder_ == null) {
          inputStreamHandler_ = null;
        } else {
          inputStreamHandler_ = null;
          inputStreamHandlerBuilder_ = null;
        }
        if (outputStreamHandlerBuilder_ == null) {
          outputStreamHandler_ = null;
        } else {
          outputStreamHandler_ = null;
          outputStreamHandlerBuilder_ = null;
        }
        if (executorBuilder_ == null) {
          executor_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00002000);
        } else {
          executorBuilder_.clear();
        }
        if (profilerConfigBuilder_ == null) {
          profilerConfig_ = null;
        } else {
          profilerConfig_ = null;
          profilerConfigBuilder_ = null;
        }
        package_ = "";

        type_ = "";

        if (optionsBuilder_ == null) {
          options_ = null;
        } else {
          options_ = null;
          optionsBuilder_ = null;
        }
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.google.mediapipe.proto.CalculatorProto.internal_static_mediapipe_CalculatorGraphConfig_descriptor;
      }

      public com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig getDefaultInstanceForType() {
        return com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.getDefaultInstance();
      }

      public com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig build() {
        com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig buildPartial() {
        com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig result = new com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (nodeBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001)) {
            node_ = java.util.Collections.unmodifiableList(node_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.node_ = node_;
        } else {
          result.node_ = nodeBuilder_.build();
        }
        if (packetFactoryBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002)) {
            packetFactory_ = java.util.Collections.unmodifiableList(packetFactory_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.packetFactory_ = packetFactory_;
        } else {
          result.packetFactory_ = packetFactoryBuilder_.build();
        }
        if (packetGeneratorBuilder_ == null) {
          if (((bitField0_ & 0x00000004) == 0x00000004)) {
            packetGenerator_ = java.util.Collections.unmodifiableList(packetGenerator_);
            bitField0_ = (bitField0_ & ~0x00000004);
          }
          result.packetGenerator_ = packetGenerator_;
        } else {
          result.packetGenerator_ = packetGeneratorBuilder_.build();
        }
        result.numThreads_ = numThreads_;
        if (statusHandlerBuilder_ == null) {
          if (((bitField0_ & 0x00000010) == 0x00000010)) {
            statusHandler_ = java.util.Collections.unmodifiableList(statusHandler_);
            bitField0_ = (bitField0_ & ~0x00000010);
          }
          result.statusHandler_ = statusHandler_;
        } else {
          result.statusHandler_ = statusHandlerBuilder_.build();
        }
        if (((bitField0_ & 0x00000020) == 0x00000020)) {
          inputStream_ = inputStream_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000020);
        }
        result.inputStream_ = inputStream_;
        if (((bitField0_ & 0x00000040) == 0x00000040)) {
          outputStream_ = outputStream_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000040);
        }
        result.outputStream_ = outputStream_;
        if (((bitField0_ & 0x00000080) == 0x00000080)) {
          inputSidePacket_ = inputSidePacket_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000080);
        }
        result.inputSidePacket_ = inputSidePacket_;
        if (((bitField0_ & 0x00000100) == 0x00000100)) {
          outputSidePacket_ = outputSidePacket_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000100);
        }
        result.outputSidePacket_ = outputSidePacket_;
        result.maxQueueSize_ = maxQueueSize_;
        result.reportDeadlock_ = reportDeadlock_;
        if (inputStreamHandlerBuilder_ == null) {
          result.inputStreamHandler_ = inputStreamHandler_;
        } else {
          result.inputStreamHandler_ = inputStreamHandlerBuilder_.build();
        }
        if (outputStreamHandlerBuilder_ == null) {
          result.outputStreamHandler_ = outputStreamHandler_;
        } else {
          result.outputStreamHandler_ = outputStreamHandlerBuilder_.build();
        }
        if (executorBuilder_ == null) {
          if (((bitField0_ & 0x00002000) == 0x00002000)) {
            executor_ = java.util.Collections.unmodifiableList(executor_);
            bitField0_ = (bitField0_ & ~0x00002000);
          }
          result.executor_ = executor_;
        } else {
          result.executor_ = executorBuilder_.build();
        }
        if (profilerConfigBuilder_ == null) {
          result.profilerConfig_ = profilerConfig_;
        } else {
          result.profilerConfig_ = profilerConfigBuilder_.build();
        }
        result.package_ = package_;
        result.type_ = type_;
        if (optionsBuilder_ == null) {
          result.options_ = options_;
        } else {
          result.options_ = optionsBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig) {
          return mergeFrom((com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig other) {
        if (other == com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.getDefaultInstance()) return this;
        if (nodeBuilder_ == null) {
          if (!other.node_.isEmpty()) {
            if (node_.isEmpty()) {
              node_ = other.node_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureNodeIsMutable();
              node_.addAll(other.node_);
            }
            onChanged();
          }
        } else {
          if (!other.node_.isEmpty()) {
            if (nodeBuilder_.isEmpty()) {
              nodeBuilder_.dispose();
              nodeBuilder_ = null;
              node_ = other.node_;
              bitField0_ = (bitField0_ & ~0x00000001);
              nodeBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getNodeFieldBuilder() : null;
            } else {
              nodeBuilder_.addAllMessages(other.node_);
            }
          }
        }
        if (packetFactoryBuilder_ == null) {
          if (!other.packetFactory_.isEmpty()) {
            if (packetFactory_.isEmpty()) {
              packetFactory_ = other.packetFactory_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensurePacketFactoryIsMutable();
              packetFactory_.addAll(other.packetFactory_);
            }
            onChanged();
          }
        } else {
          if (!other.packetFactory_.isEmpty()) {
            if (packetFactoryBuilder_.isEmpty()) {
              packetFactoryBuilder_.dispose();
              packetFactoryBuilder_ = null;
              packetFactory_ = other.packetFactory_;
              bitField0_ = (bitField0_ & ~0x00000002);
              packetFactoryBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getPacketFactoryFieldBuilder() : null;
            } else {
              packetFactoryBuilder_.addAllMessages(other.packetFactory_);
            }
          }
        }
        if (packetGeneratorBuilder_ == null) {
          if (!other.packetGenerator_.isEmpty()) {
            if (packetGenerator_.isEmpty()) {
              packetGenerator_ = other.packetGenerator_;
              bitField0_ = (bitField0_ & ~0x00000004);
            } else {
              ensurePacketGeneratorIsMutable();
              packetGenerator_.addAll(other.packetGenerator_);
            }
            onChanged();
          }
        } else {
          if (!other.packetGenerator_.isEmpty()) {
            if (packetGeneratorBuilder_.isEmpty()) {
              packetGeneratorBuilder_.dispose();
              packetGeneratorBuilder_ = null;
              packetGenerator_ = other.packetGenerator_;
              bitField0_ = (bitField0_ & ~0x00000004);
              packetGeneratorBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getPacketGeneratorFieldBuilder() : null;
            } else {
              packetGeneratorBuilder_.addAllMessages(other.packetGenerator_);
            }
          }
        }
        if (other.getNumThreads() != 0) {
          setNumThreads(other.getNumThreads());
        }
        if (statusHandlerBuilder_ == null) {
          if (!other.statusHandler_.isEmpty()) {
            if (statusHandler_.isEmpty()) {
              statusHandler_ = other.statusHandler_;
              bitField0_ = (bitField0_ & ~0x00000010);
            } else {
              ensureStatusHandlerIsMutable();
              statusHandler_.addAll(other.statusHandler_);
            }
            onChanged();
          }
        } else {
          if (!other.statusHandler_.isEmpty()) {
            if (statusHandlerBuilder_.isEmpty()) {
              statusHandlerBuilder_.dispose();
              statusHandlerBuilder_ = null;
              statusHandler_ = other.statusHandler_;
              bitField0_ = (bitField0_ & ~0x00000010);
              statusHandlerBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getStatusHandlerFieldBuilder() : null;
            } else {
              statusHandlerBuilder_.addAllMessages(other.statusHandler_);
            }
          }
        }
        if (!other.inputStream_.isEmpty()) {
          if (inputStream_.isEmpty()) {
            inputStream_ = other.inputStream_;
            bitField0_ = (bitField0_ & ~0x00000020);
          } else {
            ensureInputStreamIsMutable();
            inputStream_.addAll(other.inputStream_);
          }
          onChanged();
        }
        if (!other.outputStream_.isEmpty()) {
          if (outputStream_.isEmpty()) {
            outputStream_ = other.outputStream_;
            bitField0_ = (bitField0_ & ~0x00000040);
          } else {
            ensureOutputStreamIsMutable();
            outputStream_.addAll(other.outputStream_);
          }
          onChanged();
        }
        if (!other.inputSidePacket_.isEmpty()) {
          if (inputSidePacket_.isEmpty()) {
            inputSidePacket_ = other.inputSidePacket_;
            bitField0_ = (bitField0_ & ~0x00000080);
          } else {
            ensureInputSidePacketIsMutable();
            inputSidePacket_.addAll(other.inputSidePacket_);
          }
          onChanged();
        }
        if (!other.outputSidePacket_.isEmpty()) {
          if (outputSidePacket_.isEmpty()) {
            outputSidePacket_ = other.outputSidePacket_;
            bitField0_ = (bitField0_ & ~0x00000100);
          } else {
            ensureOutputSidePacketIsMutable();
            outputSidePacket_.addAll(other.outputSidePacket_);
          }
          onChanged();
        }
        if (other.getMaxQueueSize() != 0) {
          setMaxQueueSize(other.getMaxQueueSize());
        }
        if (other.getReportDeadlock() != false) {
          setReportDeadlock(other.getReportDeadlock());
        }
        if (other.hasInputStreamHandler()) {
          mergeInputStreamHandler(other.getInputStreamHandler());
        }
        if (other.hasOutputStreamHandler()) {
          mergeOutputStreamHandler(other.getOutputStreamHandler());
        }
        if (executorBuilder_ == null) {
          if (!other.executor_.isEmpty()) {
            if (executor_.isEmpty()) {
              executor_ = other.executor_;
              bitField0_ = (bitField0_ & ~0x00002000);
            } else {
              ensureExecutorIsMutable();
              executor_.addAll(other.executor_);
            }
            onChanged();
          }
        } else {
          if (!other.executor_.isEmpty()) {
            if (executorBuilder_.isEmpty()) {
              executorBuilder_.dispose();
              executorBuilder_ = null;
              executor_ = other.executor_;
              bitField0_ = (bitField0_ & ~0x00002000);
              executorBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getExecutorFieldBuilder() : null;
            } else {
              executorBuilder_.addAllMessages(other.executor_);
            }
          }
        }
        if (other.hasProfilerConfig()) {
          mergeProfilerConfig(other.getProfilerConfig());
        }
        if (!other.getPackage().isEmpty()) {
          package_ = other.package_;
          onChanged();
        }
        if (!other.getType().isEmpty()) {
          type_ = other.type_;
          onChanged();
        }
        if (other.hasOptions()) {
          mergeOptions(other.getOptions());
        }
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        for (int i = 0; i < getNodeCount(); i++) {
          if (!getNode(i).isInitialized()) {
            return false;
          }
        }
        for (int i = 0; i < getPacketFactoryCount(); i++) {
          if (!getPacketFactory(i).isInitialized()) {
            return false;
          }
        }
        for (int i = 0; i < getPacketGeneratorCount(); i++) {
          if (!getPacketGenerator(i).isInitialized()) {
            return false;
          }
        }
        for (int i = 0; i < getStatusHandlerCount(); i++) {
          if (!getStatusHandler(i).isInitialized()) {
            return false;
          }
        }
        if (hasInputStreamHandler()) {
          if (!getInputStreamHandler().isInitialized()) {
            return false;
          }
        }
        if (hasOutputStreamHandler()) {
          if (!getOutputStreamHandler().isInitialized()) {
            return false;
          }
        }
        for (int i = 0; i < getExecutorCount(); i++) {
          if (!getExecutor(i).isInitialized()) {
            return false;
          }
        }
        if (hasOptions()) {
          if (!getOptions().isInitialized()) {
            return false;
          }
        }
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.util.List<com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node> node_ =
        java.util.Collections.emptyList();
      private void ensureNodeIsMutable() {
        if (!((bitField0_ & 0x00000001) == 0x00000001)) {
          node_ = new java.util.ArrayList<com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node>(node_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node, com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node.Builder, com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.NodeOrBuilder> nodeBuilder_;

      /**
       * <pre>
       * The nodes.
       * </pre>
       *
       * <code>repeated .mediapipe.CalculatorGraphConfig.Node node = 1;</code>
       */
      public java.util.List<com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node> getNodeList() {
        if (nodeBuilder_ == null) {
          return java.util.Collections.unmodifiableList(node_);
        } else {
          return nodeBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * The nodes.
       * </pre>
       *
       * <code>repeated .mediapipe.CalculatorGraphConfig.Node node = 1;</code>
       */
      public int getNodeCount() {
        if (nodeBuilder_ == null) {
          return node_.size();
        } else {
          return nodeBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * The nodes.
       * </pre>
       *
       * <code>repeated .mediapipe.CalculatorGraphConfig.Node node = 1;</code>
       */
      public com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node getNode(int index) {
        if (nodeBuilder_ == null) {
          return node_.get(index);
        } else {
          return nodeBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * The nodes.
       * </pre>
       *
       * <code>repeated .mediapipe.CalculatorGraphConfig.Node node = 1;</code>
       */
      public Builder setNode(
          int index, com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node value) {
        if (nodeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureNodeIsMutable();
          node_.set(index, value);
          onChanged();
        } else {
          nodeBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * The nodes.
       * </pre>
       *
       * <code>repeated .mediapipe.CalculatorGraphConfig.Node node = 1;</code>
       */
      public Builder setNode(
          int index, com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node.Builder builderForValue) {
        if (nodeBuilder_ == null) {
          ensureNodeIsMutable();
          node_.set(index, builderForValue.build());
          onChanged();
        } else {
          nodeBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The nodes.
       * </pre>
       *
       * <code>repeated .mediapipe.CalculatorGraphConfig.Node node = 1;</code>
       */
      public Builder addNode(com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node value) {
        if (nodeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureNodeIsMutable();
          node_.add(value);
          onChanged();
        } else {
          nodeBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * The nodes.
       * </pre>
       *
       * <code>repeated .mediapipe.CalculatorGraphConfig.Node node = 1;</code>
       */
      public Builder addNode(
          int index, com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node value) {
        if (nodeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureNodeIsMutable();
          node_.add(index, value);
          onChanged();
        } else {
          nodeBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * The nodes.
       * </pre>
       *
       * <code>repeated .mediapipe.CalculatorGraphConfig.Node node = 1;</code>
       */
      public Builder addNode(
          com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node.Builder builderForValue) {
        if (nodeBuilder_ == null) {
          ensureNodeIsMutable();
          node_.add(builderForValue.build());
          onChanged();
        } else {
          nodeBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The nodes.
       * </pre>
       *
       * <code>repeated .mediapipe.CalculatorGraphConfig.Node node = 1;</code>
       */
      public Builder addNode(
          int index, com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node.Builder builderForValue) {
        if (nodeBuilder_ == null) {
          ensureNodeIsMutable();
          node_.add(index, builderForValue.build());
          onChanged();
        } else {
          nodeBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The nodes.
       * </pre>
       *
       * <code>repeated .mediapipe.CalculatorGraphConfig.Node node = 1;</code>
       */
      public Builder addAllNode(
          java.lang.Iterable<? extends com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node> values) {
        if (nodeBuilder_ == null) {
          ensureNodeIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, node_);
          onChanged();
        } else {
          nodeBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * The nodes.
       * </pre>
       *
       * <code>repeated .mediapipe.CalculatorGraphConfig.Node node = 1;</code>
       */
      public Builder clearNode() {
        if (nodeBuilder_ == null) {
          node_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          nodeBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * The nodes.
       * </pre>
       *
       * <code>repeated .mediapipe.CalculatorGraphConfig.Node node = 1;</code>
       */
      public Builder removeNode(int index) {
        if (nodeBuilder_ == null) {
          ensureNodeIsMutable();
          node_.remove(index);
          onChanged();
        } else {
          nodeBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * The nodes.
       * </pre>
       *
       * <code>repeated .mediapipe.CalculatorGraphConfig.Node node = 1;</code>
       */
      public com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node.Builder getNodeBuilder(
          int index) {
        return getNodeFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * The nodes.
       * </pre>
       *
       * <code>repeated .mediapipe.CalculatorGraphConfig.Node node = 1;</code>
       */
      public com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.NodeOrBuilder getNodeOrBuilder(
          int index) {
        if (nodeBuilder_ == null) {
          return node_.get(index);  } else {
          return nodeBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * The nodes.
       * </pre>
       *
       * <code>repeated .mediapipe.CalculatorGraphConfig.Node node = 1;</code>
       */
      public java.util.List<? extends com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.NodeOrBuilder> 
           getNodeOrBuilderList() {
        if (nodeBuilder_ != null) {
          return nodeBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(node_);
        }
      }
      /**
       * <pre>
       * The nodes.
       * </pre>
       *
       * <code>repeated .mediapipe.CalculatorGraphConfig.Node node = 1;</code>
       */
      public com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node.Builder addNodeBuilder() {
        return getNodeFieldBuilder().addBuilder(
            com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node.getDefaultInstance());
      }
      /**
       * <pre>
       * The nodes.
       * </pre>
       *
       * <code>repeated .mediapipe.CalculatorGraphConfig.Node node = 1;</code>
       */
      public com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node.Builder addNodeBuilder(
          int index) {
        return getNodeFieldBuilder().addBuilder(
            index, com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node.getDefaultInstance());
      }
      /**
       * <pre>
       * The nodes.
       * </pre>
       *
       * <code>repeated .mediapipe.CalculatorGraphConfig.Node node = 1;</code>
       */
      public java.util.List<com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node.Builder> 
           getNodeBuilderList() {
        return getNodeFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node, com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node.Builder, com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.NodeOrBuilder> 
          getNodeFieldBuilder() {
        if (nodeBuilder_ == null) {
          nodeBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node, com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.Node.Builder, com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig.NodeOrBuilder>(
                  node_,
                  ((bitField0_ & 0x00000001) == 0x00000001),
                  getParentForChildren(),
                  isClean());
          node_ = null;
        }
        return nodeBuilder_;
      }

      private java.util.List<mediapipe.PacketFactory.PacketFactoryConfig> packetFactory_ =
        java.util.Collections.emptyList();
      private void ensurePacketFactoryIsMutable() {
        if (!((bitField0_ & 0x00000002) == 0x00000002)) {
          packetFactory_ = new java.util.ArrayList<mediapipe.PacketFactory.PacketFactoryConfig>(packetFactory_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          mediapipe.PacketFactory.PacketFactoryConfig, mediapipe.PacketFactory.PacketFactoryConfig.Builder, mediapipe.PacketFactory.PacketFactoryConfigOrBuilder> packetFactoryBuilder_;

      /**
       * <pre>
       * Create a side packet using a PacketFactory.  This side packet is
       * created as close to the worker that does the work as possible.  A
       * PacketFactory is basically a PacketGenerator that takes no input side
       * packets and produces a single output side packet.
       * </pre>
       *
       * <code>repeated .mediapipe.PacketFactoryConfig packet_factory = 6;</code>
       */
      public java.util.List<mediapipe.PacketFactory.PacketFactoryConfig> getPacketFactoryList() {
        if (packetFactoryBuilder_ == null) {
          return java.util.Collections.unmodifiableList(packetFactory_);
        } else {
          return packetFactoryBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Create a side packet using a PacketFactory.  This side packet is
       * created as close to the worker that does the work as possible.  A
       * PacketFactory is basically a PacketGenerator that takes no input side
       * packets and produces a single output side packet.
       * </pre>
       *
       * <code>repeated .mediapipe.PacketFactoryConfig packet_factory = 6;</code>
       */
      public int getPacketFactoryCount() {
        if (packetFactoryBuilder_ == null) {
          return packetFactory_.size();
        } else {
          return packetFactoryBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Create a side packet using a PacketFactory.  This side packet is
       * created as close to the worker that does the work as possible.  A
       * PacketFactory is basically a PacketGenerator that takes no input side
       * packets and produces a single output side packet.
       * </pre>
       *
       * <code>repeated .mediapipe.PacketFactoryConfig packet_factory = 6;</code>
       */
      public mediapipe.PacketFactory.PacketFactoryConfig getPacketFactory(int index) {
        if (packetFactoryBuilder_ == null) {
          return packetFactory_.get(index);
        } else {
          return packetFactoryBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Create a side packet using a PacketFactory.  This side packet is
       * created as close to the worker that does the work as possible.  A
       * PacketFactory is basically a PacketGenerator that takes no input side
       * packets and produces a single output side packet.
       * </pre>
       *
       * <code>repeated .mediapipe.PacketFactoryConfig packet_factory = 6;</code>
       */
      public Builder setPacketFactory(
          int index, mediapipe.PacketFactory.PacketFactoryConfig value) {
        if (packetFactoryBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensurePacketFactoryIsMutable();
          packetFactory_.set(index, value);
          onChanged();
        } else {
          packetFactoryBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Create a side packet using a PacketFactory.  This side packet is
       * created as close to the worker that does the work as possible.  A
       * PacketFactory is basically a PacketGenerator that takes no input side
       * packets and produces a single output side packet.
       * </pre>
       *
       * <code>repeated .mediapipe.PacketFactoryConfig packet_factory = 6;</code>
       */
      public Builder setPacketFactory(
          int index, mediapipe.PacketFactory.PacketFactoryConfig.Builder builderForValue) {
        if (packetFactoryBuilder_ == null) {
          ensurePacketFactoryIsMutable();
          packetFactory_.set(index, builderForValue.build());
          onChanged();
        } else {
          packetFactoryBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Create a side packet using a PacketFactory.  This side packet is
       * created as close to the worker that does the work as possible.  A
       * PacketFactory is basically a PacketGenerator that takes no input side
       * packets and produces a single output side packet.
       * </pre>
       *
       * <code>repeated .mediapipe.PacketFactoryConfig packet_factory = 6;</code>
       */
      public Builder addPacketFactory(mediapipe.PacketFactory.PacketFactoryConfig value) {
        if (packetFactoryBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensurePacketFactoryIsMutable();
          packetFactory_.add(value);
          onChanged();
        } else {
          packetFactoryBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Create a side packet using a PacketFactory.  This side packet is
       * created as close to the worker that does the work as possible.  A
       * PacketFactory is basically a PacketGenerator that takes no input side
       * packets and produces a single output side packet.
       * </pre>
       *
       * <code>repeated .mediapipe.PacketFactoryConfig packet_factory = 6;</code>
       */
      public Builder addPacketFactory(
          int index, mediapipe.PacketFactory.PacketFactoryConfig value) {
        if (packetFactoryBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensurePacketFactoryIsMutable();
          packetFactory_.add(index, value);
          onChanged();
        } else {
          packetFactoryBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Create a side packet using a PacketFactory.  This side packet is
       * created as close to the worker that does the work as possible.  A
       * PacketFactory is basically a PacketGenerator that takes no input side
       * packets and produces a single output side packet.
       * </pre>
       *
       * <code>repeated .mediapipe.PacketFactoryConfig packet_factory = 6;</code>
       */
      public Builder addPacketFactory(
          mediapipe.PacketFactory.PacketFactoryConfig.Builder builderForValue) {
        if (packetFactoryBuilder_ == null) {
          ensurePacketFactoryIsMutable();
          packetFactory_.add(builderForValue.build());
          onChanged();
        } else {
          packetFactoryBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Create a side packet using a PacketFactory.  This side packet is
       * created as close to the worker that does the work as possible.  A
       * PacketFactory is basically a PacketGenerator that takes no input side
       * packets and produces a single output side packet.
       * </pre>
       *
       * <code>repeated .mediapipe.PacketFactoryConfig packet_factory = 6;</code>
       */
      public Builder addPacketFactory(
          int index, mediapipe.PacketFactory.PacketFactoryConfig.Builder builderForValue) {
        if (packetFactoryBuilder_ == null) {
          ensurePacketFactoryIsMutable();
          packetFactory_.add(index, builderForValue.build());
          onChanged();
        } else {
          packetFactoryBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Create a side packet using a PacketFactory.  This side packet is
       * created as close to the worker that does the work as possible.  A
       * PacketFactory is basically a PacketGenerator that takes no input side
       * packets and produces a single output side packet.
       * </pre>
       *
       * <code>repeated .mediapipe.PacketFactoryConfig packet_factory = 6;</code>
       */
      public Builder addAllPacketFactory(
          java.lang.Iterable<? extends mediapipe.PacketFactory.PacketFactoryConfig> values) {
        if (packetFactoryBuilder_ == null) {
          ensurePacketFactoryIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, packetFactory_);
          onChanged();
        } else {
          packetFactoryBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Create a side packet using a PacketFactory.  This side packet is
       * created as close to the worker that does the work as possible.  A
       * PacketFactory is basically a PacketGenerator that takes no input side
       * packets and produces a single output side packet.
       * </pre>
       *
       * <code>repeated .mediapipe.PacketFactoryConfig packet_factory = 6;</code>
       */
      public Builder clearPacketFactory() {
        if (packetFactoryBuilder_ == null) {
          packetFactory_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          packetFactoryBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Create a side packet using a PacketFactory.  This side packet is
       * created as close to the worker that does the work as possible.  A
       * PacketFactory is basically a PacketGenerator that takes no input side
       * packets and produces a single output side packet.
       * </pre>
       *
       * <code>repeated .mediapipe.PacketFactoryConfig packet_factory = 6;</code>
       */
      public Builder removePacketFactory(int index) {
        if (packetFactoryBuilder_ == null) {
          ensurePacketFactoryIsMutable();
          packetFactory_.remove(index);
          onChanged();
        } else {
          packetFactoryBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Create a side packet using a PacketFactory.  This side packet is
       * created as close to the worker that does the work as possible.  A
       * PacketFactory is basically a PacketGenerator that takes no input side
       * packets and produces a single output side packet.
       * </pre>
       *
       * <code>repeated .mediapipe.PacketFactoryConfig packet_factory = 6;</code>
       */
      public mediapipe.PacketFactory.PacketFactoryConfig.Builder getPacketFactoryBuilder(
          int index) {
        return getPacketFactoryFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Create a side packet using a PacketFactory.  This side packet is
       * created as close to the worker that does the work as possible.  A
       * PacketFactory is basically a PacketGenerator that takes no input side
       * packets and produces a single output side packet.
       * </pre>
       *
       * <code>repeated .mediapipe.PacketFactoryConfig packet_factory = 6;</code>
       */
      public mediapipe.PacketFactory.PacketFactoryConfigOrBuilder getPacketFactoryOrBuilder(
          int index) {
        if (packetFactoryBuilder_ == null) {
          return packetFactory_.get(index);  } else {
          return packetFactoryBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Create a side packet using a PacketFactory.  This side packet is
       * created as close to the worker that does the work as possible.  A
       * PacketFactory is basically a PacketGenerator that takes no input side
       * packets and produces a single output side packet.
       * </pre>
       *
       * <code>repeated .mediapipe.PacketFactoryConfig packet_factory = 6;</code>
       */
      public java.util.List<? extends mediapipe.PacketFactory.PacketFactoryConfigOrBuilder> 
           getPacketFactoryOrBuilderList() {
        if (packetFactoryBuilder_ != null) {
          return packetFactoryBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(packetFactory_);
        }
      }
      /**
       * <pre>
       * Create a side packet using a PacketFactory.  This side packet is
       * created as close to the worker that does the work as possible.  A
       * PacketFactory is basically a PacketGenerator that takes no input side
       * packets and produces a single output side packet.
       * </pre>
       *
       * <code>repeated .mediapipe.PacketFactoryConfig packet_factory = 6;</code>
       */
      public mediapipe.PacketFactory.PacketFactoryConfig.Builder addPacketFactoryBuilder() {
        return getPacketFactoryFieldBuilder().addBuilder(
            mediapipe.PacketFactory.PacketFactoryConfig.getDefaultInstance());
      }
      /**
       * <pre>
       * Create a side packet using a PacketFactory.  This side packet is
       * created as close to the worker that does the work as possible.  A
       * PacketFactory is basically a PacketGenerator that takes no input side
       * packets and produces a single output side packet.
       * </pre>
       *
       * <code>repeated .mediapipe.PacketFactoryConfig packet_factory = 6;</code>
       */
      public mediapipe.PacketFactory.PacketFactoryConfig.Builder addPacketFactoryBuilder(
          int index) {
        return getPacketFactoryFieldBuilder().addBuilder(
            index, mediapipe.PacketFactory.PacketFactoryConfig.getDefaultInstance());
      }
      /**
       * <pre>
       * Create a side packet using a PacketFactory.  This side packet is
       * created as close to the worker that does the work as possible.  A
       * PacketFactory is basically a PacketGenerator that takes no input side
       * packets and produces a single output side packet.
       * </pre>
       *
       * <code>repeated .mediapipe.PacketFactoryConfig packet_factory = 6;</code>
       */
      public java.util.List<mediapipe.PacketFactory.PacketFactoryConfig.Builder> 
           getPacketFactoryBuilderList() {
        return getPacketFactoryFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          mediapipe.PacketFactory.PacketFactoryConfig, mediapipe.PacketFactory.PacketFactoryConfig.Builder, mediapipe.PacketFactory.PacketFactoryConfigOrBuilder> 
          getPacketFactoryFieldBuilder() {
        if (packetFactoryBuilder_ == null) {
          packetFactoryBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              mediapipe.PacketFactory.PacketFactoryConfig, mediapipe.PacketFactory.PacketFactoryConfig.Builder, mediapipe.PacketFactory.PacketFactoryConfigOrBuilder>(
                  packetFactory_,
                  ((bitField0_ & 0x00000002) == 0x00000002),
                  getParentForChildren(),
                  isClean());
          packetFactory_ = null;
        }
        return packetFactoryBuilder_;
      }

      private java.util.List<mediapipe.PacketGenerator.PacketGeneratorConfig> packetGenerator_ =
        java.util.Collections.emptyList();
      private void ensurePacketGeneratorIsMutable() {
        if (!((bitField0_ & 0x00000004) == 0x00000004)) {
          packetGenerator_ = new java.util.ArrayList<mediapipe.PacketGenerator.PacketGeneratorConfig>(packetGenerator_);
          bitField0_ |= 0x00000004;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          mediapipe.PacketGenerator.PacketGeneratorConfig, mediapipe.PacketGenerator.PacketGeneratorConfig.Builder, mediapipe.PacketGenerator.PacketGeneratorConfigOrBuilder> packetGeneratorBuilder_;

      /**
       * <pre>
       * Configs for PacketGenerators.  Generators take zero or more
       * input side packets and produce any number of output side
       * packets.  For example, MediaDecoderCalculator takes an input
       * side packet with type DeletingFile.  However, most users want
       * to specify videos by ContentIdHex (i.e. video id).  By using
       * the VideoIdToLocalFileGenerator, a user can specify a video id
       * (as a string) and obtain a DeletingFile to use with the decoder.
       * PacketGenerators can take as a input side packet the output side
       * packet of another PacketGenerator.  The graph of PacketGenerators
       * must be a directed acyclic graph.
       * </pre>
       *
       * <code>repeated .mediapipe.PacketGeneratorConfig packet_generator = 7;</code>
       */
      public java.util.List<mediapipe.PacketGenerator.PacketGeneratorConfig> getPacketGeneratorList() {
        if (packetGeneratorBuilder_ == null) {
          return java.util.Collections.unmodifiableList(packetGenerator_);
        } else {
          return packetGeneratorBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Configs for PacketGenerators.  Generators take zero or more
       * input side packets and produce any number of output side
       * packets.  For example, MediaDecoderCalculator takes an input
       * side packet with type DeletingFile.  However, most users want
       * to specify videos by ContentIdHex (i.e. video id).  By using
       * the VideoIdToLocalFileGenerator, a user can specify a video id
       * (as a string) and obtain a DeletingFile to use with the decoder.
       * PacketGenerators can take as a input side packet the output side
       * packet of another PacketGenerator.  The graph of PacketGenerators
       * must be a directed acyclic graph.
       * </pre>
       *
       * <code>repeated .mediapipe.PacketGeneratorConfig packet_generator = 7;</code>
       */
      public int getPacketGeneratorCount() {
        if (packetGeneratorBuilder_ == null) {
          return packetGenerator_.size();
        } else {
          return packetGeneratorBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Configs for PacketGenerators.  Generators take zero or more
       * input side packets and produce any number of output side
       * packets.  For example, MediaDecoderCalculator takes an input
       * side packet with type DeletingFile.  However, most users want
       * to specify videos by ContentIdHex (i.e. video id).  By using
       * the VideoIdToLocalFileGenerator, a user can specify a video id
       * (as a string) and obtain a DeletingFile to use with the decoder.
       * PacketGenerators can take as a input side packet the output side
       * packet of another PacketGenerator.  The graph of PacketGenerators
       * must be a directed acyclic graph.
       * </pre>
       *
       * <code>repeated .mediapipe.PacketGeneratorConfig packet_generator = 7;</code>
       */
      public mediapipe.PacketGenerator.PacketGeneratorConfig getPacketGenerator(int index) {
        if (packetGeneratorBuilder_ == null) {
          return packetGenerator_.get(index);
        } else {
          return packetGeneratorBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Configs for PacketGenerators.  Generators take zero or more
       * input side packets and produce any number of output side
       * packets.  For example, MediaDecoderCalculator takes an input
       * side packet with type DeletingFile.  However, most users want
       * to specify videos by ContentIdHex (i.e. video id).  By using
       * the VideoIdToLocalFileGenerator, a user can specify a video id
       * (as a string) and obtain a DeletingFile to use with the decoder.
       * PacketGenerators can take as a input side packet the output side
       * packet of another PacketGenerator.  The graph of PacketGenerators
       * must be a directed acyclic graph.
       * </pre>
       *
       * <code>repeated .mediapipe.PacketGeneratorConfig packet_generator = 7;</code>
       */
      public Builder setPacketGenerator(
          int index, mediapipe.PacketGenerator.PacketGeneratorConfig value) {
        if (packetGeneratorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensurePacketGeneratorIsMutable();
          packetGenerator_.set(index, value);
          onChanged();
        } else {
          packetGeneratorBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Configs for PacketGenerators.  Generators take zero or more
       * input side packets and produce any number of output side
       * packets.  For example, MediaDecoderCalculator takes an input
       * side packet with type DeletingFile.  However, most users want
       * to specify videos by ContentIdHex (i.e. video id).  By using
       * the VideoIdToLocalFileGenerator, a user can specify a video id
       * (as a string) and obtain a DeletingFile to use with the decoder.
       * PacketGenerators can take as a input side packet the output side
       * packet of another PacketGenerator.  The graph of PacketGenerators
       * must be a directed acyclic graph.
       * </pre>
       *
       * <code>repeated .mediapipe.PacketGeneratorConfig packet_generator = 7;</code>
       */
      public Builder setPacketGenerator(
          int index, mediapipe.PacketGenerator.PacketGeneratorConfig.Builder builderForValue) {
        if (packetGeneratorBuilder_ == null) {
          ensurePacketGeneratorIsMutable();
          packetGenerator_.set(index, builderForValue.build());
          onChanged();
        } else {
          packetGeneratorBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Configs for PacketGenerators.  Generators take zero or more
       * input side packets and produce any number of output side
       * packets.  For example, MediaDecoderCalculator takes an input
       * side packet with type DeletingFile.  However, most users want
       * to specify videos by ContentIdHex (i.e. video id).  By using
       * the VideoIdToLocalFileGenerator, a user can specify a video id
       * (as a string) and obtain a DeletingFile to use with the decoder.
       * PacketGenerators can take as a input side packet the output side
       * packet of another PacketGenerator.  The graph of PacketGenerators
       * must be a directed acyclic graph.
       * </pre>
       *
       * <code>repeated .mediapipe.PacketGeneratorConfig packet_generator = 7;</code>
       */
      public Builder addPacketGenerator(mediapipe.PacketGenerator.PacketGeneratorConfig value) {
        if (packetGeneratorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensurePacketGeneratorIsMutable();
          packetGenerator_.add(value);
          onChanged();
        } else {
          packetGeneratorBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Configs for PacketGenerators.  Generators take zero or more
       * input side packets and produce any number of output side
       * packets.  For example, MediaDecoderCalculator takes an input
       * side packet with type DeletingFile.  However, most users want
       * to specify videos by ContentIdHex (i.e. video id).  By using
       * the VideoIdToLocalFileGenerator, a user can specify a video id
       * (as a string) and obtain a DeletingFile to use with the decoder.
       * PacketGenerators can take as a input side packet the output side
       * packet of another PacketGenerator.  The graph of PacketGenerators
       * must be a directed acyclic graph.
       * </pre>
       *
       * <code>repeated .mediapipe.PacketGeneratorConfig packet_generator = 7;</code>
       */
      public Builder addPacketGenerator(
          int index, mediapipe.PacketGenerator.PacketGeneratorConfig value) {
        if (packetGeneratorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensurePacketGeneratorIsMutable();
          packetGenerator_.add(index, value);
          onChanged();
        } else {
          packetGeneratorBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Configs for PacketGenerators.  Generators take zero or more
       * input side packets and produce any number of output side
       * packets.  For example, MediaDecoderCalculator takes an input
       * side packet with type DeletingFile.  However, most users want
       * to specify videos by ContentIdHex (i.e. video id).  By using
       * the VideoIdToLocalFileGenerator, a user can specify a video id
       * (as a string) and obtain a DeletingFile to use with the decoder.
       * PacketGenerators can take as a input side packet the output side
       * packet of another PacketGenerator.  The graph of PacketGenerators
       * must be a directed acyclic graph.
       * </pre>
       *
       * <code>repeated .mediapipe.PacketGeneratorConfig packet_generator = 7;</code>
       */
      public Builder addPacketGenerator(
          mediapipe.PacketGenerator.PacketGeneratorConfig.Builder builderForValue) {
        if (packetGeneratorBuilder_ == null) {
          ensurePacketGeneratorIsMutable();
          packetGenerator_.add(builderForValue.build());
          onChanged();
        } else {
          packetGeneratorBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Configs for PacketGenerators.  Generators take zero or more
       * input side packets and produce any number of output side
       * packets.  For example, MediaDecoderCalculator takes an input
       * side packet with type DeletingFile.  However, most users want
       * to specify videos by ContentIdHex (i.e. video id).  By using
       * the VideoIdToLocalFileGenerator, a user can specify a video id
       * (as a string) and obtain a DeletingFile to use with the decoder.
       * PacketGenerators can take as a input side packet the output side
       * packet of another PacketGenerator.  The graph of PacketGenerators
       * must be a directed acyclic graph.
       * </pre>
       *
       * <code>repeated .mediapipe.PacketGeneratorConfig packet_generator = 7;</code>
       */
      public Builder addPacketGenerator(
          int index, mediapipe.PacketGenerator.PacketGeneratorConfig.Builder builderForValue) {
        if (packetGeneratorBuilder_ == null) {
          ensurePacketGeneratorIsMutable();
          packetGenerator_.add(index, builderForValue.build());
          onChanged();
        } else {
          packetGeneratorBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Configs for PacketGenerators.  Generators take zero or more
       * input side packets and produce any number of output side
       * packets.  For example, MediaDecoderCalculator takes an input
       * side packet with type DeletingFile.  However, most users want
       * to specify videos by ContentIdHex (i.e. video id).  By using
       * the VideoIdToLocalFileGenerator, a user can specify a video id
       * (as a string) and obtain a DeletingFile to use with the decoder.
       * PacketGenerators can take as a input side packet the output side
       * packet of another PacketGenerator.  The graph of PacketGenerators
       * must be a directed acyclic graph.
       * </pre>
       *
       * <code>repeated .mediapipe.PacketGeneratorConfig packet_generator = 7;</code>
       */
      public Builder addAllPacketGenerator(
          java.lang.Iterable<? extends mediapipe.PacketGenerator.PacketGeneratorConfig> values) {
        if (packetGeneratorBuilder_ == null) {
          ensurePacketGeneratorIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, packetGenerator_);
          onChanged();
        } else {
          packetGeneratorBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Configs for PacketGenerators.  Generators take zero or more
       * input side packets and produce any number of output side
       * packets.  For example, MediaDecoderCalculator takes an input
       * side packet with type DeletingFile.  However, most users want
       * to specify videos by ContentIdHex (i.e. video id).  By using
       * the VideoIdToLocalFileGenerator, a user can specify a video id
       * (as a string) and obtain a DeletingFile to use with the decoder.
       * PacketGenerators can take as a input side packet the output side
       * packet of another PacketGenerator.  The graph of PacketGenerators
       * must be a directed acyclic graph.
       * </pre>
       *
       * <code>repeated .mediapipe.PacketGeneratorConfig packet_generator = 7;</code>
       */
      public Builder clearPacketGenerator() {
        if (packetGeneratorBuilder_ == null) {
          packetGenerator_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
          onChanged();
        } else {
          packetGeneratorBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Configs for PacketGenerators.  Generators take zero or more
       * input side packets and produce any number of output side
       * packets.  For example, MediaDecoderCalculator takes an input
       * side packet with type DeletingFile.  However, most users want
       * to specify videos by ContentIdHex (i.e. video id).  By using
       * the VideoIdToLocalFileGenerator, a user can specify a video id
       * (as a string) and obtain a DeletingFile to use with the decoder.
       * PacketGenerators can take as a input side packet the output side
       * packet of another PacketGenerator.  The graph of PacketGenerators
       * must be a directed acyclic graph.
       * </pre>
       *
       * <code>repeated .mediapipe.PacketGeneratorConfig packet_generator = 7;</code>
       */
      public Builder removePacketGenerator(int index) {
        if (packetGeneratorBuilder_ == null) {
          ensurePacketGeneratorIsMutable();
          packetGenerator_.remove(index);
          onChanged();
        } else {
          packetGeneratorBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Configs for PacketGenerators.  Generators take zero or more
       * input side packets and produce any number of output side
       * packets.  For example, MediaDecoderCalculator takes an input
       * side packet with type DeletingFile.  However, most users want
       * to specify videos by ContentIdHex (i.e. video id).  By using
       * the VideoIdToLocalFileGenerator, a user can specify a video id
       * (as a string) and obtain a DeletingFile to use with the decoder.
       * PacketGenerators can take as a input side packet the output side
       * packet of another PacketGenerator.  The graph of PacketGenerators
       * must be a directed acyclic graph.
       * </pre>
       *
       * <code>repeated .mediapipe.PacketGeneratorConfig packet_generator = 7;</code>
       */
      public mediapipe.PacketGenerator.PacketGeneratorConfig.Builder getPacketGeneratorBuilder(
          int index) {
        return getPacketGeneratorFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Configs for PacketGenerators.  Generators take zero or more
       * input side packets and produce any number of output side
       * packets.  For example, MediaDecoderCalculator takes an input
       * side packet with type DeletingFile.  However, most users want
       * to specify videos by ContentIdHex (i.e. video id).  By using
       * the VideoIdToLocalFileGenerator, a user can specify a video id
       * (as a string) and obtain a DeletingFile to use with the decoder.
       * PacketGenerators can take as a input side packet the output side
       * packet of another PacketGenerator.  The graph of PacketGenerators
       * must be a directed acyclic graph.
       * </pre>
       *
       * <code>repeated .mediapipe.PacketGeneratorConfig packet_generator = 7;</code>
       */
      public mediapipe.PacketGenerator.PacketGeneratorConfigOrBuilder getPacketGeneratorOrBuilder(
          int index) {
        if (packetGeneratorBuilder_ == null) {
          return packetGenerator_.get(index);  } else {
          return packetGeneratorBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Configs for PacketGenerators.  Generators take zero or more
       * input side packets and produce any number of output side
       * packets.  For example, MediaDecoderCalculator takes an input
       * side packet with type DeletingFile.  However, most users want
       * to specify videos by ContentIdHex (i.e. video id).  By using
       * the VideoIdToLocalFileGenerator, a user can specify a video id
       * (as a string) and obtain a DeletingFile to use with the decoder.
       * PacketGenerators can take as a input side packet the output side
       * packet of another PacketGenerator.  The graph of PacketGenerators
       * must be a directed acyclic graph.
       * </pre>
       *
       * <code>repeated .mediapipe.PacketGeneratorConfig packet_generator = 7;</code>
       */
      public java.util.List<? extends mediapipe.PacketGenerator.PacketGeneratorConfigOrBuilder> 
           getPacketGeneratorOrBuilderList() {
        if (packetGeneratorBuilder_ != null) {
          return packetGeneratorBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(packetGenerator_);
        }
      }
      /**
       * <pre>
       * Configs for PacketGenerators.  Generators take zero or more
       * input side packets and produce any number of output side
       * packets.  For example, MediaDecoderCalculator takes an input
       * side packet with type DeletingFile.  However, most users want
       * to specify videos by ContentIdHex (i.e. video id).  By using
       * the VideoIdToLocalFileGenerator, a user can specify a video id
       * (as a string) and obtain a DeletingFile to use with the decoder.
       * PacketGenerators can take as a input side packet the output side
       * packet of another PacketGenerator.  The graph of PacketGenerators
       * must be a directed acyclic graph.
       * </pre>
       *
       * <code>repeated .mediapipe.PacketGeneratorConfig packet_generator = 7;</code>
       */
      public mediapipe.PacketGenerator.PacketGeneratorConfig.Builder addPacketGeneratorBuilder() {
        return getPacketGeneratorFieldBuilder().addBuilder(
            mediapipe.PacketGenerator.PacketGeneratorConfig.getDefaultInstance());
      }
      /**
       * <pre>
       * Configs for PacketGenerators.  Generators take zero or more
       * input side packets and produce any number of output side
       * packets.  For example, MediaDecoderCalculator takes an input
       * side packet with type DeletingFile.  However, most users want
       * to specify videos by ContentIdHex (i.e. video id).  By using
       * the VideoIdToLocalFileGenerator, a user can specify a video id
       * (as a string) and obtain a DeletingFile to use with the decoder.
       * PacketGenerators can take as a input side packet the output side
       * packet of another PacketGenerator.  The graph of PacketGenerators
       * must be a directed acyclic graph.
       * </pre>
       *
       * <code>repeated .mediapipe.PacketGeneratorConfig packet_generator = 7;</code>
       */
      public mediapipe.PacketGenerator.PacketGeneratorConfig.Builder addPacketGeneratorBuilder(
          int index) {
        return getPacketGeneratorFieldBuilder().addBuilder(
            index, mediapipe.PacketGenerator.PacketGeneratorConfig.getDefaultInstance());
      }
      /**
       * <pre>
       * Configs for PacketGenerators.  Generators take zero or more
       * input side packets and produce any number of output side
       * packets.  For example, MediaDecoderCalculator takes an input
       * side packet with type DeletingFile.  However, most users want
       * to specify videos by ContentIdHex (i.e. video id).  By using
       * the VideoIdToLocalFileGenerator, a user can specify a video id
       * (as a string) and obtain a DeletingFile to use with the decoder.
       * PacketGenerators can take as a input side packet the output side
       * packet of another PacketGenerator.  The graph of PacketGenerators
       * must be a directed acyclic graph.
       * </pre>
       *
       * <code>repeated .mediapipe.PacketGeneratorConfig packet_generator = 7;</code>
       */
      public java.util.List<mediapipe.PacketGenerator.PacketGeneratorConfig.Builder> 
           getPacketGeneratorBuilderList() {
        return getPacketGeneratorFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          mediapipe.PacketGenerator.PacketGeneratorConfig, mediapipe.PacketGenerator.PacketGeneratorConfig.Builder, mediapipe.PacketGenerator.PacketGeneratorConfigOrBuilder> 
          getPacketGeneratorFieldBuilder() {
        if (packetGeneratorBuilder_ == null) {
          packetGeneratorBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              mediapipe.PacketGenerator.PacketGeneratorConfig, mediapipe.PacketGenerator.PacketGeneratorConfig.Builder, mediapipe.PacketGenerator.PacketGeneratorConfigOrBuilder>(
                  packetGenerator_,
                  ((bitField0_ & 0x00000004) == 0x00000004),
                  getParentForChildren(),
                  isClean());
          packetGenerator_ = null;
        }
        return packetGeneratorBuilder_;
      }

      private int numThreads_ ;
      /**
       * <pre>
       * Number of threads for running calculators in multithreaded mode.
       * If not specified, the scheduler will pick an appropriate number
       * of threads depending on the number of available processors.
       * To run on the calling thread, specify "ApplicationThreadExecutor"
       * see: http://g3doc/mediapipe/g3doc/running.md.
       * </pre>
       *
       * <code>optional int32 num_threads = 8;</code>
       */
      public int getNumThreads() {
        return numThreads_;
      }
      /**
       * <pre>
       * Number of threads for running calculators in multithreaded mode.
       * If not specified, the scheduler will pick an appropriate number
       * of threads depending on the number of available processors.
       * To run on the calling thread, specify "ApplicationThreadExecutor"
       * see: http://g3doc/mediapipe/g3doc/running.md.
       * </pre>
       *
       * <code>optional int32 num_threads = 8;</code>
       */
      public Builder setNumThreads(int value) {
        
        numThreads_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Number of threads for running calculators in multithreaded mode.
       * If not specified, the scheduler will pick an appropriate number
       * of threads depending on the number of available processors.
       * To run on the calling thread, specify "ApplicationThreadExecutor"
       * see: http://g3doc/mediapipe/g3doc/running.md.
       * </pre>
       *
       * <code>optional int32 num_threads = 8;</code>
       */
      public Builder clearNumThreads() {
        
        numThreads_ = 0;
        onChanged();
        return this;
      }

      private java.util.List<mediapipe.StatusHandler.StatusHandlerConfig> statusHandler_ =
        java.util.Collections.emptyList();
      private void ensureStatusHandlerIsMutable() {
        if (!((bitField0_ & 0x00000010) == 0x00000010)) {
          statusHandler_ = new java.util.ArrayList<mediapipe.StatusHandler.StatusHandlerConfig>(statusHandler_);
          bitField0_ |= 0x00000010;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          mediapipe.StatusHandler.StatusHandlerConfig, mediapipe.StatusHandler.StatusHandlerConfig.Builder, mediapipe.StatusHandler.StatusHandlerConfigOrBuilder> statusHandlerBuilder_;

      /**
       * <pre>
       * Configs for StatusHandlers that will be called after each call to
       * Run() on the graph.  StatusHandlers take zero or more input side
       * packets and the ::util::Status returned by a graph run.  For example,
       * a StatusHandler could store information about graph failures and
       * their causes for later monitoring.  Note that graph failures during
       * initialization may cause required input side packets (created by a
       * PacketFactory or PacketGenerator) to be missing.  In these cases,
       * the handler with missing input side packets will be skipped.
       * </pre>
       *
       * <code>repeated .mediapipe.StatusHandlerConfig status_handler = 9;</code>
       */
      public java.util.List<mediapipe.StatusHandler.StatusHandlerConfig> getStatusHandlerList() {
        if (statusHandlerBuilder_ == null) {
          return java.util.Collections.unmodifiableList(statusHandler_);
        } else {
          return statusHandlerBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Configs for StatusHandlers that will be called after each call to
       * Run() on the graph.  StatusHandlers take zero or more input side
       * packets and the ::util::Status returned by a graph run.  For example,
       * a StatusHandler could store information about graph failures and
       * their causes for later monitoring.  Note that graph failures during
       * initialization may cause required input side packets (created by a
       * PacketFactory or PacketGenerator) to be missing.  In these cases,
       * the handler with missing input side packets will be skipped.
       * </pre>
       *
       * <code>repeated .mediapipe.StatusHandlerConfig status_handler = 9;</code>
       */
      public int getStatusHandlerCount() {
        if (statusHandlerBuilder_ == null) {
          return statusHandler_.size();
        } else {
          return statusHandlerBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Configs for StatusHandlers that will be called after each call to
       * Run() on the graph.  StatusHandlers take zero or more input side
       * packets and the ::util::Status returned by a graph run.  For example,
       * a StatusHandler could store information about graph failures and
       * their causes for later monitoring.  Note that graph failures during
       * initialization may cause required input side packets (created by a
       * PacketFactory or PacketGenerator) to be missing.  In these cases,
       * the handler with missing input side packets will be skipped.
       * </pre>
       *
       * <code>repeated .mediapipe.StatusHandlerConfig status_handler = 9;</code>
       */
      public mediapipe.StatusHandler.StatusHandlerConfig getStatusHandler(int index) {
        if (statusHandlerBuilder_ == null) {
          return statusHandler_.get(index);
        } else {
          return statusHandlerBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Configs for StatusHandlers that will be called after each call to
       * Run() on the graph.  StatusHandlers take zero or more input side
       * packets and the ::util::Status returned by a graph run.  For example,
       * a StatusHandler could store information about graph failures and
       * their causes for later monitoring.  Note that graph failures during
       * initialization may cause required input side packets (created by a
       * PacketFactory or PacketGenerator) to be missing.  In these cases,
       * the handler with missing input side packets will be skipped.
       * </pre>
       *
       * <code>repeated .mediapipe.StatusHandlerConfig status_handler = 9;</code>
       */
      public Builder setStatusHandler(
          int index, mediapipe.StatusHandler.StatusHandlerConfig value) {
        if (statusHandlerBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureStatusHandlerIsMutable();
          statusHandler_.set(index, value);
          onChanged();
        } else {
          statusHandlerBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Configs for StatusHandlers that will be called after each call to
       * Run() on the graph.  StatusHandlers take zero or more input side
       * packets and the ::util::Status returned by a graph run.  For example,
       * a StatusHandler could store information about graph failures and
       * their causes for later monitoring.  Note that graph failures during
       * initialization may cause required input side packets (created by a
       * PacketFactory or PacketGenerator) to be missing.  In these cases,
       * the handler with missing input side packets will be skipped.
       * </pre>
       *
       * <code>repeated .mediapipe.StatusHandlerConfig status_handler = 9;</code>
       */
      public Builder setStatusHandler(
          int index, mediapipe.StatusHandler.StatusHandlerConfig.Builder builderForValue) {
        if (statusHandlerBuilder_ == null) {
          ensureStatusHandlerIsMutable();
          statusHandler_.set(index, builderForValue.build());
          onChanged();
        } else {
          statusHandlerBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Configs for StatusHandlers that will be called after each call to
       * Run() on the graph.  StatusHandlers take zero or more input side
       * packets and the ::util::Status returned by a graph run.  For example,
       * a StatusHandler could store information about graph failures and
       * their causes for later monitoring.  Note that graph failures during
       * initialization may cause required input side packets (created by a
       * PacketFactory or PacketGenerator) to be missing.  In these cases,
       * the handler with missing input side packets will be skipped.
       * </pre>
       *
       * <code>repeated .mediapipe.StatusHandlerConfig status_handler = 9;</code>
       */
      public Builder addStatusHandler(mediapipe.StatusHandler.StatusHandlerConfig value) {
        if (statusHandlerBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureStatusHandlerIsMutable();
          statusHandler_.add(value);
          onChanged();
        } else {
          statusHandlerBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Configs for StatusHandlers that will be called after each call to
       * Run() on the graph.  StatusHandlers take zero or more input side
       * packets and the ::util::Status returned by a graph run.  For example,
       * a StatusHandler could store information about graph failures and
       * their causes for later monitoring.  Note that graph failures during
       * initialization may cause required input side packets (created by a
       * PacketFactory or PacketGenerator) to be missing.  In these cases,
       * the handler with missing input side packets will be skipped.
       * </pre>
       *
       * <code>repeated .mediapipe.StatusHandlerConfig status_handler = 9;</code>
       */
      public Builder addStatusHandler(
          int index, mediapipe.StatusHandler.StatusHandlerConfig value) {
        if (statusHandlerBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureStatusHandlerIsMutable();
          statusHandler_.add(index, value);
          onChanged();
        } else {
          statusHandlerBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Configs for StatusHandlers that will be called after each call to
       * Run() on the graph.  StatusHandlers take zero or more input side
       * packets and the ::util::Status returned by a graph run.  For example,
       * a StatusHandler could store information about graph failures and
       * their causes for later monitoring.  Note that graph failures during
       * initialization may cause required input side packets (created by a
       * PacketFactory or PacketGenerator) to be missing.  In these cases,
       * the handler with missing input side packets will be skipped.
       * </pre>
       *
       * <code>repeated .mediapipe.StatusHandlerConfig status_handler = 9;</code>
       */
      public Builder addStatusHandler(
          mediapipe.StatusHandler.StatusHandlerConfig.Builder builderForValue) {
        if (statusHandlerBuilder_ == null) {
          ensureStatusHandlerIsMutable();
          statusHandler_.add(builderForValue.build());
          onChanged();
        } else {
          statusHandlerBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Configs for StatusHandlers that will be called after each call to
       * Run() on the graph.  StatusHandlers take zero or more input side
       * packets and the ::util::Status returned by a graph run.  For example,
       * a StatusHandler could store information about graph failures and
       * their causes for later monitoring.  Note that graph failures during
       * initialization may cause required input side packets (created by a
       * PacketFactory or PacketGenerator) to be missing.  In these cases,
       * the handler with missing input side packets will be skipped.
       * </pre>
       *
       * <code>repeated .mediapipe.StatusHandlerConfig status_handler = 9;</code>
       */
      public Builder addStatusHandler(
          int index, mediapipe.StatusHandler.StatusHandlerConfig.Builder builderForValue) {
        if (statusHandlerBuilder_ == null) {
          ensureStatusHandlerIsMutable();
          statusHandler_.add(index, builderForValue.build());
          onChanged();
        } else {
          statusHandlerBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Configs for StatusHandlers that will be called after each call to
       * Run() on the graph.  StatusHandlers take zero or more input side
       * packets and the ::util::Status returned by a graph run.  For example,
       * a StatusHandler could store information about graph failures and
       * their causes for later monitoring.  Note that graph failures during
       * initialization may cause required input side packets (created by a
       * PacketFactory or PacketGenerator) to be missing.  In these cases,
       * the handler with missing input side packets will be skipped.
       * </pre>
       *
       * <code>repeated .mediapipe.StatusHandlerConfig status_handler = 9;</code>
       */
      public Builder addAllStatusHandler(
          java.lang.Iterable<? extends mediapipe.StatusHandler.StatusHandlerConfig> values) {
        if (statusHandlerBuilder_ == null) {
          ensureStatusHandlerIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, statusHandler_);
          onChanged();
        } else {
          statusHandlerBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Configs for StatusHandlers that will be called after each call to
       * Run() on the graph.  StatusHandlers take zero or more input side
       * packets and the ::util::Status returned by a graph run.  For example,
       * a StatusHandler could store information about graph failures and
       * their causes for later monitoring.  Note that graph failures during
       * initialization may cause required input side packets (created by a
       * PacketFactory or PacketGenerator) to be missing.  In these cases,
       * the handler with missing input side packets will be skipped.
       * </pre>
       *
       * <code>repeated .mediapipe.StatusHandlerConfig status_handler = 9;</code>
       */
      public Builder clearStatusHandler() {
        if (statusHandlerBuilder_ == null) {
          statusHandler_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000010);
          onChanged();
        } else {
          statusHandlerBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Configs for StatusHandlers that will be called after each call to
       * Run() on the graph.  StatusHandlers take zero or more input side
       * packets and the ::util::Status returned by a graph run.  For example,
       * a StatusHandler could store information about graph failures and
       * their causes for later monitoring.  Note that graph failures during
       * initialization may cause required input side packets (created by a
       * PacketFactory or PacketGenerator) to be missing.  In these cases,
       * the handler with missing input side packets will be skipped.
       * </pre>
       *
       * <code>repeated .mediapipe.StatusHandlerConfig status_handler = 9;</code>
       */
      public Builder removeStatusHandler(int index) {
        if (statusHandlerBuilder_ == null) {
          ensureStatusHandlerIsMutable();
          statusHandler_.remove(index);
          onChanged();
        } else {
          statusHandlerBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Configs for StatusHandlers that will be called after each call to
       * Run() on the graph.  StatusHandlers take zero or more input side
       * packets and the ::util::Status returned by a graph run.  For example,
       * a StatusHandler could store information about graph failures and
       * their causes for later monitoring.  Note that graph failures during
       * initialization may cause required input side packets (created by a
       * PacketFactory or PacketGenerator) to be missing.  In these cases,
       * the handler with missing input side packets will be skipped.
       * </pre>
       *
       * <code>repeated .mediapipe.StatusHandlerConfig status_handler = 9;</code>
       */
      public mediapipe.StatusHandler.StatusHandlerConfig.Builder getStatusHandlerBuilder(
          int index) {
        return getStatusHandlerFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Configs for StatusHandlers that will be called after each call to
       * Run() on the graph.  StatusHandlers take zero or more input side
       * packets and the ::util::Status returned by a graph run.  For example,
       * a StatusHandler could store information about graph failures and
       * their causes for later monitoring.  Note that graph failures during
       * initialization may cause required input side packets (created by a
       * PacketFactory or PacketGenerator) to be missing.  In these cases,
       * the handler with missing input side packets will be skipped.
       * </pre>
       *
       * <code>repeated .mediapipe.StatusHandlerConfig status_handler = 9;</code>
       */
      public mediapipe.StatusHandler.StatusHandlerConfigOrBuilder getStatusHandlerOrBuilder(
          int index) {
        if (statusHandlerBuilder_ == null) {
          return statusHandler_.get(index);  } else {
          return statusHandlerBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Configs for StatusHandlers that will be called after each call to
       * Run() on the graph.  StatusHandlers take zero or more input side
       * packets and the ::util::Status returned by a graph run.  For example,
       * a StatusHandler could store information about graph failures and
       * their causes for later monitoring.  Note that graph failures during
       * initialization may cause required input side packets (created by a
       * PacketFactory or PacketGenerator) to be missing.  In these cases,
       * the handler with missing input side packets will be skipped.
       * </pre>
       *
       * <code>repeated .mediapipe.StatusHandlerConfig status_handler = 9;</code>
       */
      public java.util.List<? extends mediapipe.StatusHandler.StatusHandlerConfigOrBuilder> 
           getStatusHandlerOrBuilderList() {
        if (statusHandlerBuilder_ != null) {
          return statusHandlerBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(statusHandler_);
        }
      }
      /**
       * <pre>
       * Configs for StatusHandlers that will be called after each call to
       * Run() on the graph.  StatusHandlers take zero or more input side
       * packets and the ::util::Status returned by a graph run.  For example,
       * a StatusHandler could store information about graph failures and
       * their causes for later monitoring.  Note that graph failures during
       * initialization may cause required input side packets (created by a
       * PacketFactory or PacketGenerator) to be missing.  In these cases,
       * the handler with missing input side packets will be skipped.
       * </pre>
       *
       * <code>repeated .mediapipe.StatusHandlerConfig status_handler = 9;</code>
       */
      public mediapipe.StatusHandler.StatusHandlerConfig.Builder addStatusHandlerBuilder() {
        return getStatusHandlerFieldBuilder().addBuilder(
            mediapipe.StatusHandler.StatusHandlerConfig.getDefaultInstance());
      }
      /**
       * <pre>
       * Configs for StatusHandlers that will be called after each call to
       * Run() on the graph.  StatusHandlers take zero or more input side
       * packets and the ::util::Status returned by a graph run.  For example,
       * a StatusHandler could store information about graph failures and
       * their causes for later monitoring.  Note that graph failures during
       * initialization may cause required input side packets (created by a
       * PacketFactory or PacketGenerator) to be missing.  In these cases,
       * the handler with missing input side packets will be skipped.
       * </pre>
       *
       * <code>repeated .mediapipe.StatusHandlerConfig status_handler = 9;</code>
       */
      public mediapipe.StatusHandler.StatusHandlerConfig.Builder addStatusHandlerBuilder(
          int index) {
        return getStatusHandlerFieldBuilder().addBuilder(
            index, mediapipe.StatusHandler.StatusHandlerConfig.getDefaultInstance());
      }
      /**
       * <pre>
       * Configs for StatusHandlers that will be called after each call to
       * Run() on the graph.  StatusHandlers take zero or more input side
       * packets and the ::util::Status returned by a graph run.  For example,
       * a StatusHandler could store information about graph failures and
       * their causes for later monitoring.  Note that graph failures during
       * initialization may cause required input side packets (created by a
       * PacketFactory or PacketGenerator) to be missing.  In these cases,
       * the handler with missing input side packets will be skipped.
       * </pre>
       *
       * <code>repeated .mediapipe.StatusHandlerConfig status_handler = 9;</code>
       */
      public java.util.List<mediapipe.StatusHandler.StatusHandlerConfig.Builder> 
           getStatusHandlerBuilderList() {
        return getStatusHandlerFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          mediapipe.StatusHandler.StatusHandlerConfig, mediapipe.StatusHandler.StatusHandlerConfig.Builder, mediapipe.StatusHandler.StatusHandlerConfigOrBuilder> 
          getStatusHandlerFieldBuilder() {
        if (statusHandlerBuilder_ == null) {
          statusHandlerBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              mediapipe.StatusHandler.StatusHandlerConfig, mediapipe.StatusHandler.StatusHandlerConfig.Builder, mediapipe.StatusHandler.StatusHandlerConfigOrBuilder>(
                  statusHandler_,
                  ((bitField0_ & 0x00000010) == 0x00000010),
                  getParentForChildren(),
                  isClean());
          statusHandler_ = null;
        }
        return statusHandlerBuilder_;
      }

      private com.google.protobuf.LazyStringList inputStream_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      private void ensureInputStreamIsMutable() {
        if (!((bitField0_ & 0x00000020) == 0x00000020)) {
          inputStream_ = new com.google.protobuf.LazyStringArrayList(inputStream_);
          bitField0_ |= 0x00000020;
         }
      }
      /**
       * <pre>
       * Specify input streams to the entire graph.  Streams specified here may have
       * packets added to them using CalculatorGraph::AddPacketToInputStream.  This
       * works much like a source calculator, except that the source is outside of
       * the mediapipe graph.
       * </pre>
       *
       * <code>repeated string input_stream = 10;</code>
       */
      public com.google.protobuf.ProtocolStringList
          getInputStreamList() {
        return inputStream_.getUnmodifiableView();
      }
      /**
       * <pre>
       * Specify input streams to the entire graph.  Streams specified here may have
       * packets added to them using CalculatorGraph::AddPacketToInputStream.  This
       * works much like a source calculator, except that the source is outside of
       * the mediapipe graph.
       * </pre>
       *
       * <code>repeated string input_stream = 10;</code>
       */
      public int getInputStreamCount() {
        return inputStream_.size();
      }
      /**
       * <pre>
       * Specify input streams to the entire graph.  Streams specified here may have
       * packets added to them using CalculatorGraph::AddPacketToInputStream.  This
       * works much like a source calculator, except that the source is outside of
       * the mediapipe graph.
       * </pre>
       *
       * <code>repeated string input_stream = 10;</code>
       */
      public java.lang.String getInputStream(int index) {
        return inputStream_.get(index);
      }
      /**
       * <pre>
       * Specify input streams to the entire graph.  Streams specified here may have
       * packets added to them using CalculatorGraph::AddPacketToInputStream.  This
       * works much like a source calculator, except that the source is outside of
       * the mediapipe graph.
       * </pre>
       *
       * <code>repeated string input_stream = 10;</code>
       */
      public com.google.protobuf.ByteString
          getInputStreamBytes(int index) {
        return inputStream_.getByteString(index);
      }
      /**
       * <pre>
       * Specify input streams to the entire graph.  Streams specified here may have
       * packets added to them using CalculatorGraph::AddPacketToInputStream.  This
       * works much like a source calculator, except that the source is outside of
       * the mediapipe graph.
       * </pre>
       *
       * <code>repeated string input_stream = 10;</code>
       */
      public Builder setInputStream(
          int index, java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureInputStreamIsMutable();
        inputStream_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Specify input streams to the entire graph.  Streams specified here may have
       * packets added to them using CalculatorGraph::AddPacketToInputStream.  This
       * works much like a source calculator, except that the source is outside of
       * the mediapipe graph.
       * </pre>
       *
       * <code>repeated string input_stream = 10;</code>
       */
      public Builder addInputStream(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureInputStreamIsMutable();
        inputStream_.add(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Specify input streams to the entire graph.  Streams specified here may have
       * packets added to them using CalculatorGraph::AddPacketToInputStream.  This
       * works much like a source calculator, except that the source is outside of
       * the mediapipe graph.
       * </pre>
       *
       * <code>repeated string input_stream = 10;</code>
       */
      public Builder addAllInputStream(
          java.lang.Iterable<java.lang.String> values) {
        ensureInputStreamIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, inputStream_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Specify input streams to the entire graph.  Streams specified here may have
       * packets added to them using CalculatorGraph::AddPacketToInputStream.  This
       * works much like a source calculator, except that the source is outside of
       * the mediapipe graph.
       * </pre>
       *
       * <code>repeated string input_stream = 10;</code>
       */
      public Builder clearInputStream() {
        inputStream_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000020);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Specify input streams to the entire graph.  Streams specified here may have
       * packets added to them using CalculatorGraph::AddPacketToInputStream.  This
       * works much like a source calculator, except that the source is outside of
       * the mediapipe graph.
       * </pre>
       *
       * <code>repeated string input_stream = 10;</code>
       */
      public Builder addInputStreamBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        ensureInputStreamIsMutable();
        inputStream_.add(value);
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringList outputStream_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      private void ensureOutputStreamIsMutable() {
        if (!((bitField0_ & 0x00000040) == 0x00000040)) {
          outputStream_ = new com.google.protobuf.LazyStringArrayList(outputStream_);
          bitField0_ |= 0x00000040;
         }
      }
      /**
       * <pre>
       * Output streams for the graph when used as a subgraph.
       * </pre>
       *
       * <code>repeated string output_stream = 15;</code>
       */
      public com.google.protobuf.ProtocolStringList
          getOutputStreamList() {
        return outputStream_.getUnmodifiableView();
      }
      /**
       * <pre>
       * Output streams for the graph when used as a subgraph.
       * </pre>
       *
       * <code>repeated string output_stream = 15;</code>
       */
      public int getOutputStreamCount() {
        return outputStream_.size();
      }
      /**
       * <pre>
       * Output streams for the graph when used as a subgraph.
       * </pre>
       *
       * <code>repeated string output_stream = 15;</code>
       */
      public java.lang.String getOutputStream(int index) {
        return outputStream_.get(index);
      }
      /**
       * <pre>
       * Output streams for the graph when used as a subgraph.
       * </pre>
       *
       * <code>repeated string output_stream = 15;</code>
       */
      public com.google.protobuf.ByteString
          getOutputStreamBytes(int index) {
        return outputStream_.getByteString(index);
      }
      /**
       * <pre>
       * Output streams for the graph when used as a subgraph.
       * </pre>
       *
       * <code>repeated string output_stream = 15;</code>
       */
      public Builder setOutputStream(
          int index, java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureOutputStreamIsMutable();
        outputStream_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Output streams for the graph when used as a subgraph.
       * </pre>
       *
       * <code>repeated string output_stream = 15;</code>
       */
      public Builder addOutputStream(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureOutputStreamIsMutable();
        outputStream_.add(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Output streams for the graph when used as a subgraph.
       * </pre>
       *
       * <code>repeated string output_stream = 15;</code>
       */
      public Builder addAllOutputStream(
          java.lang.Iterable<java.lang.String> values) {
        ensureOutputStreamIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, outputStream_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Output streams for the graph when used as a subgraph.
       * </pre>
       *
       * <code>repeated string output_stream = 15;</code>
       */
      public Builder clearOutputStream() {
        outputStream_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000040);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Output streams for the graph when used as a subgraph.
       * </pre>
       *
       * <code>repeated string output_stream = 15;</code>
       */
      public Builder addOutputStreamBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        ensureOutputStreamIsMutable();
        outputStream_.add(value);
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringList inputSidePacket_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      private void ensureInputSidePacketIsMutable() {
        if (!((bitField0_ & 0x00000080) == 0x00000080)) {
          inputSidePacket_ = new com.google.protobuf.LazyStringArrayList(inputSidePacket_);
          bitField0_ |= 0x00000080;
         }
      }
      /**
       * <pre>
       * Input side packets for the graph when used as a subgraph.
       * </pre>
       *
       * <code>repeated string input_side_packet = 16;</code>
       */
      public com.google.protobuf.ProtocolStringList
          getInputSidePacketList() {
        return inputSidePacket_.getUnmodifiableView();
      }
      /**
       * <pre>
       * Input side packets for the graph when used as a subgraph.
       * </pre>
       *
       * <code>repeated string input_side_packet = 16;</code>
       */
      public int getInputSidePacketCount() {
        return inputSidePacket_.size();
      }
      /**
       * <pre>
       * Input side packets for the graph when used as a subgraph.
       * </pre>
       *
       * <code>repeated string input_side_packet = 16;</code>
       */
      public java.lang.String getInputSidePacket(int index) {
        return inputSidePacket_.get(index);
      }
      /**
       * <pre>
       * Input side packets for the graph when used as a subgraph.
       * </pre>
       *
       * <code>repeated string input_side_packet = 16;</code>
       */
      public com.google.protobuf.ByteString
          getInputSidePacketBytes(int index) {
        return inputSidePacket_.getByteString(index);
      }
      /**
       * <pre>
       * Input side packets for the graph when used as a subgraph.
       * </pre>
       *
       * <code>repeated string input_side_packet = 16;</code>
       */
      public Builder setInputSidePacket(
          int index, java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureInputSidePacketIsMutable();
        inputSidePacket_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Input side packets for the graph when used as a subgraph.
       * </pre>
       *
       * <code>repeated string input_side_packet = 16;</code>
       */
      public Builder addInputSidePacket(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureInputSidePacketIsMutable();
        inputSidePacket_.add(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Input side packets for the graph when used as a subgraph.
       * </pre>
       *
       * <code>repeated string input_side_packet = 16;</code>
       */
      public Builder addAllInputSidePacket(
          java.lang.Iterable<java.lang.String> values) {
        ensureInputSidePacketIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, inputSidePacket_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Input side packets for the graph when used as a subgraph.
       * </pre>
       *
       * <code>repeated string input_side_packet = 16;</code>
       */
      public Builder clearInputSidePacket() {
        inputSidePacket_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000080);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Input side packets for the graph when used as a subgraph.
       * </pre>
       *
       * <code>repeated string input_side_packet = 16;</code>
       */
      public Builder addInputSidePacketBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        ensureInputSidePacketIsMutable();
        inputSidePacket_.add(value);
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringList outputSidePacket_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      private void ensureOutputSidePacketIsMutable() {
        if (!((bitField0_ & 0x00000100) == 0x00000100)) {
          outputSidePacket_ = new com.google.protobuf.LazyStringArrayList(outputSidePacket_);
          bitField0_ |= 0x00000100;
         }
      }
      /**
       * <pre>
       * Output side packets for the graph when used as a subgraph.
       * </pre>
       *
       * <code>repeated string output_side_packet = 17;</code>
       */
      public com.google.protobuf.ProtocolStringList
          getOutputSidePacketList() {
        return outputSidePacket_.getUnmodifiableView();
      }
      /**
       * <pre>
       * Output side packets for the graph when used as a subgraph.
       * </pre>
       *
       * <code>repeated string output_side_packet = 17;</code>
       */
      public int getOutputSidePacketCount() {
        return outputSidePacket_.size();
      }
      /**
       * <pre>
       * Output side packets for the graph when used as a subgraph.
       * </pre>
       *
       * <code>repeated string output_side_packet = 17;</code>
       */
      public java.lang.String getOutputSidePacket(int index) {
        return outputSidePacket_.get(index);
      }
      /**
       * <pre>
       * Output side packets for the graph when used as a subgraph.
       * </pre>
       *
       * <code>repeated string output_side_packet = 17;</code>
       */
      public com.google.protobuf.ByteString
          getOutputSidePacketBytes(int index) {
        return outputSidePacket_.getByteString(index);
      }
      /**
       * <pre>
       * Output side packets for the graph when used as a subgraph.
       * </pre>
       *
       * <code>repeated string output_side_packet = 17;</code>
       */
      public Builder setOutputSidePacket(
          int index, java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureOutputSidePacketIsMutable();
        outputSidePacket_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Output side packets for the graph when used as a subgraph.
       * </pre>
       *
       * <code>repeated string output_side_packet = 17;</code>
       */
      public Builder addOutputSidePacket(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureOutputSidePacketIsMutable();
        outputSidePacket_.add(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Output side packets for the graph when used as a subgraph.
       * </pre>
       *
       * <code>repeated string output_side_packet = 17;</code>
       */
      public Builder addAllOutputSidePacket(
          java.lang.Iterable<java.lang.String> values) {
        ensureOutputSidePacketIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, outputSidePacket_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Output side packets for the graph when used as a subgraph.
       * </pre>
       *
       * <code>repeated string output_side_packet = 17;</code>
       */
      public Builder clearOutputSidePacket() {
        outputSidePacket_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000100);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Output side packets for the graph when used as a subgraph.
       * </pre>
       *
       * <code>repeated string output_side_packet = 17;</code>
       */
      public Builder addOutputSidePacketBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        ensureOutputSidePacketIsMutable();
        outputSidePacket_.add(value);
        onChanged();
        return this;
      }

      private int maxQueueSize_ ;
      /**
       * <pre>
       * Maximum queue size of any input stream in the graph. This can be used to
       * control the memory usage of a MediaPipe graph by preventing fast sources
       * from flooding the graph with packets. Any source that is connected to an
       * input stream that has hit its maximum capacity will not be scheduled until
       * the queue size falls under the specified limits, or if the scheduler queue
       * is empty and no other nodes are running (to prevent possible deadlocks due
       * to a incorrectly specified value). This global parameter is set to 100
       * packets by default to enable pipelining. If any node indicates that it
       * buffers packets before emitting them, then the max(node_buffer_size,
       * max_queue_size) is used. Set this parameter to -1 to disable throttling
       * (i.e. the graph will use as much memory as it requires). If not specified,
       * the limit is 100 packets.
       * </pre>
       *
       * <code>optional int32 max_queue_size = 11;</code>
       */
      public int getMaxQueueSize() {
        return maxQueueSize_;
      }
      /**
       * <pre>
       * Maximum queue size of any input stream in the graph. This can be used to
       * control the memory usage of a MediaPipe graph by preventing fast sources
       * from flooding the graph with packets. Any source that is connected to an
       * input stream that has hit its maximum capacity will not be scheduled until
       * the queue size falls under the specified limits, or if the scheduler queue
       * is empty and no other nodes are running (to prevent possible deadlocks due
       * to a incorrectly specified value). This global parameter is set to 100
       * packets by default to enable pipelining. If any node indicates that it
       * buffers packets before emitting them, then the max(node_buffer_size,
       * max_queue_size) is used. Set this parameter to -1 to disable throttling
       * (i.e. the graph will use as much memory as it requires). If not specified,
       * the limit is 100 packets.
       * </pre>
       *
       * <code>optional int32 max_queue_size = 11;</code>
       */
      public Builder setMaxQueueSize(int value) {
        
        maxQueueSize_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Maximum queue size of any input stream in the graph. This can be used to
       * control the memory usage of a MediaPipe graph by preventing fast sources
       * from flooding the graph with packets. Any source that is connected to an
       * input stream that has hit its maximum capacity will not be scheduled until
       * the queue size falls under the specified limits, or if the scheduler queue
       * is empty and no other nodes are running (to prevent possible deadlocks due
       * to a incorrectly specified value). This global parameter is set to 100
       * packets by default to enable pipelining. If any node indicates that it
       * buffers packets before emitting them, then the max(node_buffer_size,
       * max_queue_size) is used. Set this parameter to -1 to disable throttling
       * (i.e. the graph will use as much memory as it requires). If not specified,
       * the limit is 100 packets.
       * </pre>
       *
       * <code>optional int32 max_queue_size = 11;</code>
       */
      public Builder clearMaxQueueSize() {
        
        maxQueueSize_ = 0;
        onChanged();
        return this;
      }

      private boolean reportDeadlock_ ;
      /**
       * <pre>
       * If true, the graph run fails with an error when throttling prevents all
       * calculators from running.  If false, max_queue_size for an input stream
       * is adjusted when throttling prevents all calculators from running.
       * </pre>
       *
       * <code>optional bool report_deadlock = 21;</code>
       */
      public boolean getReportDeadlock() {
        return reportDeadlock_;
      }
      /**
       * <pre>
       * If true, the graph run fails with an error when throttling prevents all
       * calculators from running.  If false, max_queue_size for an input stream
       * is adjusted when throttling prevents all calculators from running.
       * </pre>
       *
       * <code>optional bool report_deadlock = 21;</code>
       */
      public Builder setReportDeadlock(boolean value) {
        
        reportDeadlock_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If true, the graph run fails with an error when throttling prevents all
       * calculators from running.  If false, max_queue_size for an input stream
       * is adjusted when throttling prevents all calculators from running.
       * </pre>
       *
       * <code>optional bool report_deadlock = 21;</code>
       */
      public Builder clearReportDeadlock() {
        
        reportDeadlock_ = false;
        onChanged();
        return this;
      }

      private mediapipe.StreamHandler.InputStreamHandlerConfig inputStreamHandler_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          mediapipe.StreamHandler.InputStreamHandlerConfig, mediapipe.StreamHandler.InputStreamHandlerConfig.Builder, mediapipe.StreamHandler.InputStreamHandlerConfigOrBuilder> inputStreamHandlerBuilder_;
      /**
       * <pre>
       * Config for this graph's InputStreamHandler.
       * If unspecified, the framework will automatically install the default
       * handler, which works as follows.
       * The calculator's Process() method is called for timestamp t when:
       * - at least one stream has a packet available at t; and,
       * - all other streams either have packets at t, or it is known that they will
       * not have packets at t (i.e. their next timestamp bound is greater than t).
       * The handler then provides all available packets with timestamp t, with no
       * preprocessing.
       * </pre>
       *
       * <code>optional .mediapipe.InputStreamHandlerConfig input_stream_handler = 12;</code>
       */
      public boolean hasInputStreamHandler() {
        return inputStreamHandlerBuilder_ != null || inputStreamHandler_ != null;
      }
      /**
       * <pre>
       * Config for this graph's InputStreamHandler.
       * If unspecified, the framework will automatically install the default
       * handler, which works as follows.
       * The calculator's Process() method is called for timestamp t when:
       * - at least one stream has a packet available at t; and,
       * - all other streams either have packets at t, or it is known that they will
       * not have packets at t (i.e. their next timestamp bound is greater than t).
       * The handler then provides all available packets with timestamp t, with no
       * preprocessing.
       * </pre>
       *
       * <code>optional .mediapipe.InputStreamHandlerConfig input_stream_handler = 12;</code>
       */
      public mediapipe.StreamHandler.InputStreamHandlerConfig getInputStreamHandler() {
        if (inputStreamHandlerBuilder_ == null) {
          return inputStreamHandler_ == null ? mediapipe.StreamHandler.InputStreamHandlerConfig.getDefaultInstance() : inputStreamHandler_;
        } else {
          return inputStreamHandlerBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Config for this graph's InputStreamHandler.
       * If unspecified, the framework will automatically install the default
       * handler, which works as follows.
       * The calculator's Process() method is called for timestamp t when:
       * - at least one stream has a packet available at t; and,
       * - all other streams either have packets at t, or it is known that they will
       * not have packets at t (i.e. their next timestamp bound is greater than t).
       * The handler then provides all available packets with timestamp t, with no
       * preprocessing.
       * </pre>
       *
       * <code>optional .mediapipe.InputStreamHandlerConfig input_stream_handler = 12;</code>
       */
      public Builder setInputStreamHandler(mediapipe.StreamHandler.InputStreamHandlerConfig value) {
        if (inputStreamHandlerBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          inputStreamHandler_ = value;
          onChanged();
        } else {
          inputStreamHandlerBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Config for this graph's InputStreamHandler.
       * If unspecified, the framework will automatically install the default
       * handler, which works as follows.
       * The calculator's Process() method is called for timestamp t when:
       * - at least one stream has a packet available at t; and,
       * - all other streams either have packets at t, or it is known that they will
       * not have packets at t (i.e. their next timestamp bound is greater than t).
       * The handler then provides all available packets with timestamp t, with no
       * preprocessing.
       * </pre>
       *
       * <code>optional .mediapipe.InputStreamHandlerConfig input_stream_handler = 12;</code>
       */
      public Builder setInputStreamHandler(
          mediapipe.StreamHandler.InputStreamHandlerConfig.Builder builderForValue) {
        if (inputStreamHandlerBuilder_ == null) {
          inputStreamHandler_ = builderForValue.build();
          onChanged();
        } else {
          inputStreamHandlerBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Config for this graph's InputStreamHandler.
       * If unspecified, the framework will automatically install the default
       * handler, which works as follows.
       * The calculator's Process() method is called for timestamp t when:
       * - at least one stream has a packet available at t; and,
       * - all other streams either have packets at t, or it is known that they will
       * not have packets at t (i.e. their next timestamp bound is greater than t).
       * The handler then provides all available packets with timestamp t, with no
       * preprocessing.
       * </pre>
       *
       * <code>optional .mediapipe.InputStreamHandlerConfig input_stream_handler = 12;</code>
       */
      public Builder mergeInputStreamHandler(mediapipe.StreamHandler.InputStreamHandlerConfig value) {
        if (inputStreamHandlerBuilder_ == null) {
          if (inputStreamHandler_ != null) {
            inputStreamHandler_ =
              mediapipe.StreamHandler.InputStreamHandlerConfig.newBuilder(inputStreamHandler_).mergeFrom(value).buildPartial();
          } else {
            inputStreamHandler_ = value;
          }
          onChanged();
        } else {
          inputStreamHandlerBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Config for this graph's InputStreamHandler.
       * If unspecified, the framework will automatically install the default
       * handler, which works as follows.
       * The calculator's Process() method is called for timestamp t when:
       * - at least one stream has a packet available at t; and,
       * - all other streams either have packets at t, or it is known that they will
       * not have packets at t (i.e. their next timestamp bound is greater than t).
       * The handler then provides all available packets with timestamp t, with no
       * preprocessing.
       * </pre>
       *
       * <code>optional .mediapipe.InputStreamHandlerConfig input_stream_handler = 12;</code>
       */
      public Builder clearInputStreamHandler() {
        if (inputStreamHandlerBuilder_ == null) {
          inputStreamHandler_ = null;
          onChanged();
        } else {
          inputStreamHandler_ = null;
          inputStreamHandlerBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Config for this graph's InputStreamHandler.
       * If unspecified, the framework will automatically install the default
       * handler, which works as follows.
       * The calculator's Process() method is called for timestamp t when:
       * - at least one stream has a packet available at t; and,
       * - all other streams either have packets at t, or it is known that they will
       * not have packets at t (i.e. their next timestamp bound is greater than t).
       * The handler then provides all available packets with timestamp t, with no
       * preprocessing.
       * </pre>
       *
       * <code>optional .mediapipe.InputStreamHandlerConfig input_stream_handler = 12;</code>
       */
      public mediapipe.StreamHandler.InputStreamHandlerConfig.Builder getInputStreamHandlerBuilder() {
        
        onChanged();
        return getInputStreamHandlerFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Config for this graph's InputStreamHandler.
       * If unspecified, the framework will automatically install the default
       * handler, which works as follows.
       * The calculator's Process() method is called for timestamp t when:
       * - at least one stream has a packet available at t; and,
       * - all other streams either have packets at t, or it is known that they will
       * not have packets at t (i.e. their next timestamp bound is greater than t).
       * The handler then provides all available packets with timestamp t, with no
       * preprocessing.
       * </pre>
       *
       * <code>optional .mediapipe.InputStreamHandlerConfig input_stream_handler = 12;</code>
       */
      public mediapipe.StreamHandler.InputStreamHandlerConfigOrBuilder getInputStreamHandlerOrBuilder() {
        if (inputStreamHandlerBuilder_ != null) {
          return inputStreamHandlerBuilder_.getMessageOrBuilder();
        } else {
          return inputStreamHandler_ == null ?
              mediapipe.StreamHandler.InputStreamHandlerConfig.getDefaultInstance() : inputStreamHandler_;
        }
      }
      /**
       * <pre>
       * Config for this graph's InputStreamHandler.
       * If unspecified, the framework will automatically install the default
       * handler, which works as follows.
       * The calculator's Process() method is called for timestamp t when:
       * - at least one stream has a packet available at t; and,
       * - all other streams either have packets at t, or it is known that they will
       * not have packets at t (i.e. their next timestamp bound is greater than t).
       * The handler then provides all available packets with timestamp t, with no
       * preprocessing.
       * </pre>
       *
       * <code>optional .mediapipe.InputStreamHandlerConfig input_stream_handler = 12;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          mediapipe.StreamHandler.InputStreamHandlerConfig, mediapipe.StreamHandler.InputStreamHandlerConfig.Builder, mediapipe.StreamHandler.InputStreamHandlerConfigOrBuilder> 
          getInputStreamHandlerFieldBuilder() {
        if (inputStreamHandlerBuilder_ == null) {
          inputStreamHandlerBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              mediapipe.StreamHandler.InputStreamHandlerConfig, mediapipe.StreamHandler.InputStreamHandlerConfig.Builder, mediapipe.StreamHandler.InputStreamHandlerConfigOrBuilder>(
                  getInputStreamHandler(),
                  getParentForChildren(),
                  isClean());
          inputStreamHandler_ = null;
        }
        return inputStreamHandlerBuilder_;
      }

      private mediapipe.StreamHandler.OutputStreamHandlerConfig outputStreamHandler_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          mediapipe.StreamHandler.OutputStreamHandlerConfig, mediapipe.StreamHandler.OutputStreamHandlerConfig.Builder, mediapipe.StreamHandler.OutputStreamHandlerConfigOrBuilder> outputStreamHandlerBuilder_;
      /**
       * <pre>
       * Config for this graph's OutputStreamHandler.
       * If unspecified, the default output stream handler will be automatically
       * installed by the framework which does not modify any outgoing packets.
       * </pre>
       *
       * <code>optional .mediapipe.OutputStreamHandlerConfig output_stream_handler = 13;</code>
       */
      public boolean hasOutputStreamHandler() {
        return outputStreamHandlerBuilder_ != null || outputStreamHandler_ != null;
      }
      /**
       * <pre>
       * Config for this graph's OutputStreamHandler.
       * If unspecified, the default output stream handler will be automatically
       * installed by the framework which does not modify any outgoing packets.
       * </pre>
       *
       * <code>optional .mediapipe.OutputStreamHandlerConfig output_stream_handler = 13;</code>
       */
      public mediapipe.StreamHandler.OutputStreamHandlerConfig getOutputStreamHandler() {
        if (outputStreamHandlerBuilder_ == null) {
          return outputStreamHandler_ == null ? mediapipe.StreamHandler.OutputStreamHandlerConfig.getDefaultInstance() : outputStreamHandler_;
        } else {
          return outputStreamHandlerBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Config for this graph's OutputStreamHandler.
       * If unspecified, the default output stream handler will be automatically
       * installed by the framework which does not modify any outgoing packets.
       * </pre>
       *
       * <code>optional .mediapipe.OutputStreamHandlerConfig output_stream_handler = 13;</code>
       */
      public Builder setOutputStreamHandler(mediapipe.StreamHandler.OutputStreamHandlerConfig value) {
        if (outputStreamHandlerBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          outputStreamHandler_ = value;
          onChanged();
        } else {
          outputStreamHandlerBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Config for this graph's OutputStreamHandler.
       * If unspecified, the default output stream handler will be automatically
       * installed by the framework which does not modify any outgoing packets.
       * </pre>
       *
       * <code>optional .mediapipe.OutputStreamHandlerConfig output_stream_handler = 13;</code>
       */
      public Builder setOutputStreamHandler(
          mediapipe.StreamHandler.OutputStreamHandlerConfig.Builder builderForValue) {
        if (outputStreamHandlerBuilder_ == null) {
          outputStreamHandler_ = builderForValue.build();
          onChanged();
        } else {
          outputStreamHandlerBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Config for this graph's OutputStreamHandler.
       * If unspecified, the default output stream handler will be automatically
       * installed by the framework which does not modify any outgoing packets.
       * </pre>
       *
       * <code>optional .mediapipe.OutputStreamHandlerConfig output_stream_handler = 13;</code>
       */
      public Builder mergeOutputStreamHandler(mediapipe.StreamHandler.OutputStreamHandlerConfig value) {
        if (outputStreamHandlerBuilder_ == null) {
          if (outputStreamHandler_ != null) {
            outputStreamHandler_ =
              mediapipe.StreamHandler.OutputStreamHandlerConfig.newBuilder(outputStreamHandler_).mergeFrom(value).buildPartial();
          } else {
            outputStreamHandler_ = value;
          }
          onChanged();
        } else {
          outputStreamHandlerBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Config for this graph's OutputStreamHandler.
       * If unspecified, the default output stream handler will be automatically
       * installed by the framework which does not modify any outgoing packets.
       * </pre>
       *
       * <code>optional .mediapipe.OutputStreamHandlerConfig output_stream_handler = 13;</code>
       */
      public Builder clearOutputStreamHandler() {
        if (outputStreamHandlerBuilder_ == null) {
          outputStreamHandler_ = null;
          onChanged();
        } else {
          outputStreamHandler_ = null;
          outputStreamHandlerBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Config for this graph's OutputStreamHandler.
       * If unspecified, the default output stream handler will be automatically
       * installed by the framework which does not modify any outgoing packets.
       * </pre>
       *
       * <code>optional .mediapipe.OutputStreamHandlerConfig output_stream_handler = 13;</code>
       */
      public mediapipe.StreamHandler.OutputStreamHandlerConfig.Builder getOutputStreamHandlerBuilder() {
        
        onChanged();
        return getOutputStreamHandlerFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Config for this graph's OutputStreamHandler.
       * If unspecified, the default output stream handler will be automatically
       * installed by the framework which does not modify any outgoing packets.
       * </pre>
       *
       * <code>optional .mediapipe.OutputStreamHandlerConfig output_stream_handler = 13;</code>
       */
      public mediapipe.StreamHandler.OutputStreamHandlerConfigOrBuilder getOutputStreamHandlerOrBuilder() {
        if (outputStreamHandlerBuilder_ != null) {
          return outputStreamHandlerBuilder_.getMessageOrBuilder();
        } else {
          return outputStreamHandler_ == null ?
              mediapipe.StreamHandler.OutputStreamHandlerConfig.getDefaultInstance() : outputStreamHandler_;
        }
      }
      /**
       * <pre>
       * Config for this graph's OutputStreamHandler.
       * If unspecified, the default output stream handler will be automatically
       * installed by the framework which does not modify any outgoing packets.
       * </pre>
       *
       * <code>optional .mediapipe.OutputStreamHandlerConfig output_stream_handler = 13;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          mediapipe.StreamHandler.OutputStreamHandlerConfig, mediapipe.StreamHandler.OutputStreamHandlerConfig.Builder, mediapipe.StreamHandler.OutputStreamHandlerConfigOrBuilder> 
          getOutputStreamHandlerFieldBuilder() {
        if (outputStreamHandlerBuilder_ == null) {
          outputStreamHandlerBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              mediapipe.StreamHandler.OutputStreamHandlerConfig, mediapipe.StreamHandler.OutputStreamHandlerConfig.Builder, mediapipe.StreamHandler.OutputStreamHandlerConfigOrBuilder>(
                  getOutputStreamHandler(),
                  getParentForChildren(),
                  isClean());
          outputStreamHandler_ = null;
        }
        return outputStreamHandlerBuilder_;
      }

      private java.util.List<com.google.mediapipe.proto.CalculatorProto.ExecutorConfig> executor_ =
        java.util.Collections.emptyList();
      private void ensureExecutorIsMutable() {
        if (!((bitField0_ & 0x00002000) == 0x00002000)) {
          executor_ = new java.util.ArrayList<com.google.mediapipe.proto.CalculatorProto.ExecutorConfig>(executor_);
          bitField0_ |= 0x00002000;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          com.google.mediapipe.proto.CalculatorProto.ExecutorConfig, com.google.mediapipe.proto.CalculatorProto.ExecutorConfig.Builder, com.google.mediapipe.proto.CalculatorProto.ExecutorConfigOrBuilder> executorBuilder_;

      /**
       * <pre>
       * Configs for Executors.
       * The names of the executors must be distinct. The default executor, whose
       * name is the empty string, is predefined. The num_threads field of the
       * CalculatorGraphConfig specifies the number of threads in the default
       * executor. If the config for the default executor is specified, the
       * CalculatorGraphConfig must not have the num_threads field.
       * </pre>
       *
       * <code>repeated .mediapipe.ExecutorConfig executor = 14;</code>
       */
      public java.util.List<com.google.mediapipe.proto.CalculatorProto.ExecutorConfig> getExecutorList() {
        if (executorBuilder_ == null) {
          return java.util.Collections.unmodifiableList(executor_);
        } else {
          return executorBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Configs for Executors.
       * The names of the executors must be distinct. The default executor, whose
       * name is the empty string, is predefined. The num_threads field of the
       * CalculatorGraphConfig specifies the number of threads in the default
       * executor. If the config for the default executor is specified, the
       * CalculatorGraphConfig must not have the num_threads field.
       * </pre>
       *
       * <code>repeated .mediapipe.ExecutorConfig executor = 14;</code>
       */
      public int getExecutorCount() {
        if (executorBuilder_ == null) {
          return executor_.size();
        } else {
          return executorBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Configs for Executors.
       * The names of the executors must be distinct. The default executor, whose
       * name is the empty string, is predefined. The num_threads field of the
       * CalculatorGraphConfig specifies the number of threads in the default
       * executor. If the config for the default executor is specified, the
       * CalculatorGraphConfig must not have the num_threads field.
       * </pre>
       *
       * <code>repeated .mediapipe.ExecutorConfig executor = 14;</code>
       */
      public com.google.mediapipe.proto.CalculatorProto.ExecutorConfig getExecutor(int index) {
        if (executorBuilder_ == null) {
          return executor_.get(index);
        } else {
          return executorBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Configs for Executors.
       * The names of the executors must be distinct. The default executor, whose
       * name is the empty string, is predefined. The num_threads field of the
       * CalculatorGraphConfig specifies the number of threads in the default
       * executor. If the config for the default executor is specified, the
       * CalculatorGraphConfig must not have the num_threads field.
       * </pre>
       *
       * <code>repeated .mediapipe.ExecutorConfig executor = 14;</code>
       */
      public Builder setExecutor(
          int index, com.google.mediapipe.proto.CalculatorProto.ExecutorConfig value) {
        if (executorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureExecutorIsMutable();
          executor_.set(index, value);
          onChanged();
        } else {
          executorBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Configs for Executors.
       * The names of the executors must be distinct. The default executor, whose
       * name is the empty string, is predefined. The num_threads field of the
       * CalculatorGraphConfig specifies the number of threads in the default
       * executor. If the config for the default executor is specified, the
       * CalculatorGraphConfig must not have the num_threads field.
       * </pre>
       *
       * <code>repeated .mediapipe.ExecutorConfig executor = 14;</code>
       */
      public Builder setExecutor(
          int index, com.google.mediapipe.proto.CalculatorProto.ExecutorConfig.Builder builderForValue) {
        if (executorBuilder_ == null) {
          ensureExecutorIsMutable();
          executor_.set(index, builderForValue.build());
          onChanged();
        } else {
          executorBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Configs for Executors.
       * The names of the executors must be distinct. The default executor, whose
       * name is the empty string, is predefined. The num_threads field of the
       * CalculatorGraphConfig specifies the number of threads in the default
       * executor. If the config for the default executor is specified, the
       * CalculatorGraphConfig must not have the num_threads field.
       * </pre>
       *
       * <code>repeated .mediapipe.ExecutorConfig executor = 14;</code>
       */
      public Builder addExecutor(com.google.mediapipe.proto.CalculatorProto.ExecutorConfig value) {
        if (executorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureExecutorIsMutable();
          executor_.add(value);
          onChanged();
        } else {
          executorBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Configs for Executors.
       * The names of the executors must be distinct. The default executor, whose
       * name is the empty string, is predefined. The num_threads field of the
       * CalculatorGraphConfig specifies the number of threads in the default
       * executor. If the config for the default executor is specified, the
       * CalculatorGraphConfig must not have the num_threads field.
       * </pre>
       *
       * <code>repeated .mediapipe.ExecutorConfig executor = 14;</code>
       */
      public Builder addExecutor(
          int index, com.google.mediapipe.proto.CalculatorProto.ExecutorConfig value) {
        if (executorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureExecutorIsMutable();
          executor_.add(index, value);
          onChanged();
        } else {
          executorBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Configs for Executors.
       * The names of the executors must be distinct. The default executor, whose
       * name is the empty string, is predefined. The num_threads field of the
       * CalculatorGraphConfig specifies the number of threads in the default
       * executor. If the config for the default executor is specified, the
       * CalculatorGraphConfig must not have the num_threads field.
       * </pre>
       *
       * <code>repeated .mediapipe.ExecutorConfig executor = 14;</code>
       */
      public Builder addExecutor(
          com.google.mediapipe.proto.CalculatorProto.ExecutorConfig.Builder builderForValue) {
        if (executorBuilder_ == null) {
          ensureExecutorIsMutable();
          executor_.add(builderForValue.build());
          onChanged();
        } else {
          executorBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Configs for Executors.
       * The names of the executors must be distinct. The default executor, whose
       * name is the empty string, is predefined. The num_threads field of the
       * CalculatorGraphConfig specifies the number of threads in the default
       * executor. If the config for the default executor is specified, the
       * CalculatorGraphConfig must not have the num_threads field.
       * </pre>
       *
       * <code>repeated .mediapipe.ExecutorConfig executor = 14;</code>
       */
      public Builder addExecutor(
          int index, com.google.mediapipe.proto.CalculatorProto.ExecutorConfig.Builder builderForValue) {
        if (executorBuilder_ == null) {
          ensureExecutorIsMutable();
          executor_.add(index, builderForValue.build());
          onChanged();
        } else {
          executorBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Configs for Executors.
       * The names of the executors must be distinct. The default executor, whose
       * name is the empty string, is predefined. The num_threads field of the
       * CalculatorGraphConfig specifies the number of threads in the default
       * executor. If the config for the default executor is specified, the
       * CalculatorGraphConfig must not have the num_threads field.
       * </pre>
       *
       * <code>repeated .mediapipe.ExecutorConfig executor = 14;</code>
       */
      public Builder addAllExecutor(
          java.lang.Iterable<? extends com.google.mediapipe.proto.CalculatorProto.ExecutorConfig> values) {
        if (executorBuilder_ == null) {
          ensureExecutorIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, executor_);
          onChanged();
        } else {
          executorBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Configs for Executors.
       * The names of the executors must be distinct. The default executor, whose
       * name is the empty string, is predefined. The num_threads field of the
       * CalculatorGraphConfig specifies the number of threads in the default
       * executor. If the config for the default executor is specified, the
       * CalculatorGraphConfig must not have the num_threads field.
       * </pre>
       *
       * <code>repeated .mediapipe.ExecutorConfig executor = 14;</code>
       */
      public Builder clearExecutor() {
        if (executorBuilder_ == null) {
          executor_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00002000);
          onChanged();
        } else {
          executorBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Configs for Executors.
       * The names of the executors must be distinct. The default executor, whose
       * name is the empty string, is predefined. The num_threads field of the
       * CalculatorGraphConfig specifies the number of threads in the default
       * executor. If the config for the default executor is specified, the
       * CalculatorGraphConfig must not have the num_threads field.
       * </pre>
       *
       * <code>repeated .mediapipe.ExecutorConfig executor = 14;</code>
       */
      public Builder removeExecutor(int index) {
        if (executorBuilder_ == null) {
          ensureExecutorIsMutable();
          executor_.remove(index);
          onChanged();
        } else {
          executorBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Configs for Executors.
       * The names of the executors must be distinct. The default executor, whose
       * name is the empty string, is predefined. The num_threads field of the
       * CalculatorGraphConfig specifies the number of threads in the default
       * executor. If the config for the default executor is specified, the
       * CalculatorGraphConfig must not have the num_threads field.
       * </pre>
       *
       * <code>repeated .mediapipe.ExecutorConfig executor = 14;</code>
       */
      public com.google.mediapipe.proto.CalculatorProto.ExecutorConfig.Builder getExecutorBuilder(
          int index) {
        return getExecutorFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Configs for Executors.
       * The names of the executors must be distinct. The default executor, whose
       * name is the empty string, is predefined. The num_threads field of the
       * CalculatorGraphConfig specifies the number of threads in the default
       * executor. If the config for the default executor is specified, the
       * CalculatorGraphConfig must not have the num_threads field.
       * </pre>
       *
       * <code>repeated .mediapipe.ExecutorConfig executor = 14;</code>
       */
      public com.google.mediapipe.proto.CalculatorProto.ExecutorConfigOrBuilder getExecutorOrBuilder(
          int index) {
        if (executorBuilder_ == null) {
          return executor_.get(index);  } else {
          return executorBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Configs for Executors.
       * The names of the executors must be distinct. The default executor, whose
       * name is the empty string, is predefined. The num_threads field of the
       * CalculatorGraphConfig specifies the number of threads in the default
       * executor. If the config for the default executor is specified, the
       * CalculatorGraphConfig must not have the num_threads field.
       * </pre>
       *
       * <code>repeated .mediapipe.ExecutorConfig executor = 14;</code>
       */
      public java.util.List<? extends com.google.mediapipe.proto.CalculatorProto.ExecutorConfigOrBuilder> 
           getExecutorOrBuilderList() {
        if (executorBuilder_ != null) {
          return executorBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(executor_);
        }
      }
      /**
       * <pre>
       * Configs for Executors.
       * The names of the executors must be distinct. The default executor, whose
       * name is the empty string, is predefined. The num_threads field of the
       * CalculatorGraphConfig specifies the number of threads in the default
       * executor. If the config for the default executor is specified, the
       * CalculatorGraphConfig must not have the num_threads field.
       * </pre>
       *
       * <code>repeated .mediapipe.ExecutorConfig executor = 14;</code>
       */
      public com.google.mediapipe.proto.CalculatorProto.ExecutorConfig.Builder addExecutorBuilder() {
        return getExecutorFieldBuilder().addBuilder(
            com.google.mediapipe.proto.CalculatorProto.ExecutorConfig.getDefaultInstance());
      }
      /**
       * <pre>
       * Configs for Executors.
       * The names of the executors must be distinct. The default executor, whose
       * name is the empty string, is predefined. The num_threads field of the
       * CalculatorGraphConfig specifies the number of threads in the default
       * executor. If the config for the default executor is specified, the
       * CalculatorGraphConfig must not have the num_threads field.
       * </pre>
       *
       * <code>repeated .mediapipe.ExecutorConfig executor = 14;</code>
       */
      public com.google.mediapipe.proto.CalculatorProto.ExecutorConfig.Builder addExecutorBuilder(
          int index) {
        return getExecutorFieldBuilder().addBuilder(
            index, com.google.mediapipe.proto.CalculatorProto.ExecutorConfig.getDefaultInstance());
      }
      /**
       * <pre>
       * Configs for Executors.
       * The names of the executors must be distinct. The default executor, whose
       * name is the empty string, is predefined. The num_threads field of the
       * CalculatorGraphConfig specifies the number of threads in the default
       * executor. If the config for the default executor is specified, the
       * CalculatorGraphConfig must not have the num_threads field.
       * </pre>
       *
       * <code>repeated .mediapipe.ExecutorConfig executor = 14;</code>
       */
      public java.util.List<com.google.mediapipe.proto.CalculatorProto.ExecutorConfig.Builder> 
           getExecutorBuilderList() {
        return getExecutorFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          com.google.mediapipe.proto.CalculatorProto.ExecutorConfig, com.google.mediapipe.proto.CalculatorProto.ExecutorConfig.Builder, com.google.mediapipe.proto.CalculatorProto.ExecutorConfigOrBuilder> 
          getExecutorFieldBuilder() {
        if (executorBuilder_ == null) {
          executorBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              com.google.mediapipe.proto.CalculatorProto.ExecutorConfig, com.google.mediapipe.proto.CalculatorProto.ExecutorConfig.Builder, com.google.mediapipe.proto.CalculatorProto.ExecutorConfigOrBuilder>(
                  executor_,
                  ((bitField0_ & 0x00002000) == 0x00002000),
                  getParentForChildren(),
                  isClean());
          executor_ = null;
        }
        return executorBuilder_;
      }

      private com.google.mediapipe.proto.CalculatorProto.ProfilerConfig profilerConfig_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.mediapipe.proto.CalculatorProto.ProfilerConfig, com.google.mediapipe.proto.CalculatorProto.ProfilerConfig.Builder, com.google.mediapipe.proto.CalculatorProto.ProfilerConfigOrBuilder> profilerConfigBuilder_;
      /**
       * <pre>
       * The default profiler-config for all calculators.  If set, this defines the
       * profiling settings such as num_histogram_intervals for every calculator in
       * the graph.  Each of these settings can be overridden by the
       * |profiler_config| specified for a node.
       * </pre>
       *
       * <code>optional .mediapipe.ProfilerConfig profiler_config = 18;</code>
       */
      public boolean hasProfilerConfig() {
        return profilerConfigBuilder_ != null || profilerConfig_ != null;
      }
      /**
       * <pre>
       * The default profiler-config for all calculators.  If set, this defines the
       * profiling settings such as num_histogram_intervals for every calculator in
       * the graph.  Each of these settings can be overridden by the
       * |profiler_config| specified for a node.
       * </pre>
       *
       * <code>optional .mediapipe.ProfilerConfig profiler_config = 18;</code>
       */
      public com.google.mediapipe.proto.CalculatorProto.ProfilerConfig getProfilerConfig() {
        if (profilerConfigBuilder_ == null) {
          return profilerConfig_ == null ? com.google.mediapipe.proto.CalculatorProto.ProfilerConfig.getDefaultInstance() : profilerConfig_;
        } else {
          return profilerConfigBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The default profiler-config for all calculators.  If set, this defines the
       * profiling settings such as num_histogram_intervals for every calculator in
       * the graph.  Each of these settings can be overridden by the
       * |profiler_config| specified for a node.
       * </pre>
       *
       * <code>optional .mediapipe.ProfilerConfig profiler_config = 18;</code>
       */
      public Builder setProfilerConfig(com.google.mediapipe.proto.CalculatorProto.ProfilerConfig value) {
        if (profilerConfigBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          profilerConfig_ = value;
          onChanged();
        } else {
          profilerConfigBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * The default profiler-config for all calculators.  If set, this defines the
       * profiling settings such as num_histogram_intervals for every calculator in
       * the graph.  Each of these settings can be overridden by the
       * |profiler_config| specified for a node.
       * </pre>
       *
       * <code>optional .mediapipe.ProfilerConfig profiler_config = 18;</code>
       */
      public Builder setProfilerConfig(
          com.google.mediapipe.proto.CalculatorProto.ProfilerConfig.Builder builderForValue) {
        if (profilerConfigBuilder_ == null) {
          profilerConfig_ = builderForValue.build();
          onChanged();
        } else {
          profilerConfigBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * The default profiler-config for all calculators.  If set, this defines the
       * profiling settings such as num_histogram_intervals for every calculator in
       * the graph.  Each of these settings can be overridden by the
       * |profiler_config| specified for a node.
       * </pre>
       *
       * <code>optional .mediapipe.ProfilerConfig profiler_config = 18;</code>
       */
      public Builder mergeProfilerConfig(com.google.mediapipe.proto.CalculatorProto.ProfilerConfig value) {
        if (profilerConfigBuilder_ == null) {
          if (profilerConfig_ != null) {
            profilerConfig_ =
              com.google.mediapipe.proto.CalculatorProto.ProfilerConfig.newBuilder(profilerConfig_).mergeFrom(value).buildPartial();
          } else {
            profilerConfig_ = value;
          }
          onChanged();
        } else {
          profilerConfigBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * The default profiler-config for all calculators.  If set, this defines the
       * profiling settings such as num_histogram_intervals for every calculator in
       * the graph.  Each of these settings can be overridden by the
       * |profiler_config| specified for a node.
       * </pre>
       *
       * <code>optional .mediapipe.ProfilerConfig profiler_config = 18;</code>
       */
      public Builder clearProfilerConfig() {
        if (profilerConfigBuilder_ == null) {
          profilerConfig_ = null;
          onChanged();
        } else {
          profilerConfig_ = null;
          profilerConfigBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * The default profiler-config for all calculators.  If set, this defines the
       * profiling settings such as num_histogram_intervals for every calculator in
       * the graph.  Each of these settings can be overridden by the
       * |profiler_config| specified for a node.
       * </pre>
       *
       * <code>optional .mediapipe.ProfilerConfig profiler_config = 18;</code>
       */
      public com.google.mediapipe.proto.CalculatorProto.ProfilerConfig.Builder getProfilerConfigBuilder() {
        
        onChanged();
        return getProfilerConfigFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The default profiler-config for all calculators.  If set, this defines the
       * profiling settings such as num_histogram_intervals for every calculator in
       * the graph.  Each of these settings can be overridden by the
       * |profiler_config| specified for a node.
       * </pre>
       *
       * <code>optional .mediapipe.ProfilerConfig profiler_config = 18;</code>
       */
      public com.google.mediapipe.proto.CalculatorProto.ProfilerConfigOrBuilder getProfilerConfigOrBuilder() {
        if (profilerConfigBuilder_ != null) {
          return profilerConfigBuilder_.getMessageOrBuilder();
        } else {
          return profilerConfig_ == null ?
              com.google.mediapipe.proto.CalculatorProto.ProfilerConfig.getDefaultInstance() : profilerConfig_;
        }
      }
      /**
       * <pre>
       * The default profiler-config for all calculators.  If set, this defines the
       * profiling settings such as num_histogram_intervals for every calculator in
       * the graph.  Each of these settings can be overridden by the
       * |profiler_config| specified for a node.
       * </pre>
       *
       * <code>optional .mediapipe.ProfilerConfig profiler_config = 18;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.mediapipe.proto.CalculatorProto.ProfilerConfig, com.google.mediapipe.proto.CalculatorProto.ProfilerConfig.Builder, com.google.mediapipe.proto.CalculatorProto.ProfilerConfigOrBuilder> 
          getProfilerConfigFieldBuilder() {
        if (profilerConfigBuilder_ == null) {
          profilerConfigBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.google.mediapipe.proto.CalculatorProto.ProfilerConfig, com.google.mediapipe.proto.CalculatorProto.ProfilerConfig.Builder, com.google.mediapipe.proto.CalculatorProto.ProfilerConfigOrBuilder>(
                  getProfilerConfig(),
                  getParentForChildren(),
                  isClean());
          profilerConfig_ = null;
        }
        return profilerConfigBuilder_;
      }

      private java.lang.Object package_ = "";
      /**
       * <pre>
       * The namespace used for class name lookup within this graph.
       * An unqualified or partially qualified class name is looked up in
       * this namespace first and then in enclosing namespaces.
       * </pre>
       *
       * <code>optional string package = 19;</code>
       */
      public java.lang.String getPackage() {
        java.lang.Object ref = package_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          package_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The namespace used for class name lookup within this graph.
       * An unqualified or partially qualified class name is looked up in
       * this namespace first and then in enclosing namespaces.
       * </pre>
       *
       * <code>optional string package = 19;</code>
       */
      public com.google.protobuf.ByteString
          getPackageBytes() {
        java.lang.Object ref = package_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          package_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The namespace used for class name lookup within this graph.
       * An unqualified or partially qualified class name is looked up in
       * this namespace first and then in enclosing namespaces.
       * </pre>
       *
       * <code>optional string package = 19;</code>
       */
      public Builder setPackage(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        package_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The namespace used for class name lookup within this graph.
       * An unqualified or partially qualified class name is looked up in
       * this namespace first and then in enclosing namespaces.
       * </pre>
       *
       * <code>optional string package = 19;</code>
       */
      public Builder clearPackage() {
        
        package_ = getDefaultInstance().getPackage();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The namespace used for class name lookup within this graph.
       * An unqualified or partially qualified class name is looked up in
       * this namespace first and then in enclosing namespaces.
       * </pre>
       *
       * <code>optional string package = 19;</code>
       */
      public Builder setPackageBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        package_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object type_ = "";
      /**
       * <pre>
       * The type name for the graph config, used for registering and referencing
       * the graph config.
       * </pre>
       *
       * <code>optional string type = 20;</code>
       */
      public java.lang.String getType() {
        java.lang.Object ref = type_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          type_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The type name for the graph config, used for registering and referencing
       * the graph config.
       * </pre>
       *
       * <code>optional string type = 20;</code>
       */
      public com.google.protobuf.ByteString
          getTypeBytes() {
        java.lang.Object ref = type_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          type_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The type name for the graph config, used for registering and referencing
       * the graph config.
       * </pre>
       *
       * <code>optional string type = 20;</code>
       */
      public Builder setType(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        type_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The type name for the graph config, used for registering and referencing
       * the graph config.
       * </pre>
       *
       * <code>optional string type = 20;</code>
       */
      public Builder clearType() {
        
        type_ = getDefaultInstance().getType();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The type name for the graph config, used for registering and referencing
       * the graph config.
       * </pre>
       *
       * <code>optional string type = 20;</code>
       */
      public Builder setTypeBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        type_ = value;
        onChanged();
        return this;
      }

      private mediapipe.MediapipeOptions.MediaPipeOptions options_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          mediapipe.MediapipeOptions.MediaPipeOptions, mediapipe.MediapipeOptions.MediaPipeOptions.Builder, mediapipe.MediapipeOptions.MediaPipeOptionsOrBuilder> optionsBuilder_;
      /**
       * <pre>
       * Can be used for annotating a graph.
       * </pre>
       *
       * <code>optional .mediapipe.MediaPipeOptions options = 1001;</code>
       */
      public boolean hasOptions() {
        return optionsBuilder_ != null || options_ != null;
      }
      /**
       * <pre>
       * Can be used for annotating a graph.
       * </pre>
       *
       * <code>optional .mediapipe.MediaPipeOptions options = 1001;</code>
       */
      public mediapipe.MediapipeOptions.MediaPipeOptions getOptions() {
        if (optionsBuilder_ == null) {
          return options_ == null ? mediapipe.MediapipeOptions.MediaPipeOptions.getDefaultInstance() : options_;
        } else {
          return optionsBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Can be used for annotating a graph.
       * </pre>
       *
       * <code>optional .mediapipe.MediaPipeOptions options = 1001;</code>
       */
      public Builder setOptions(mediapipe.MediapipeOptions.MediaPipeOptions value) {
        if (optionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          options_ = value;
          onChanged();
        } else {
          optionsBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Can be used for annotating a graph.
       * </pre>
       *
       * <code>optional .mediapipe.MediaPipeOptions options = 1001;</code>
       */
      public Builder setOptions(
          mediapipe.MediapipeOptions.MediaPipeOptions.Builder builderForValue) {
        if (optionsBuilder_ == null) {
          options_ = builderForValue.build();
          onChanged();
        } else {
          optionsBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Can be used for annotating a graph.
       * </pre>
       *
       * <code>optional .mediapipe.MediaPipeOptions options = 1001;</code>
       */
      public Builder mergeOptions(mediapipe.MediapipeOptions.MediaPipeOptions value) {
        if (optionsBuilder_ == null) {
          if (options_ != null) {
            options_ =
              mediapipe.MediapipeOptions.MediaPipeOptions.newBuilder(options_).mergeFrom(value).buildPartial();
          } else {
            options_ = value;
          }
          onChanged();
        } else {
          optionsBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Can be used for annotating a graph.
       * </pre>
       *
       * <code>optional .mediapipe.MediaPipeOptions options = 1001;</code>
       */
      public Builder clearOptions() {
        if (optionsBuilder_ == null) {
          options_ = null;
          onChanged();
        } else {
          options_ = null;
          optionsBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Can be used for annotating a graph.
       * </pre>
       *
       * <code>optional .mediapipe.MediaPipeOptions options = 1001;</code>
       */
      public mediapipe.MediapipeOptions.MediaPipeOptions.Builder getOptionsBuilder() {
        
        onChanged();
        return getOptionsFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Can be used for annotating a graph.
       * </pre>
       *
       * <code>optional .mediapipe.MediaPipeOptions options = 1001;</code>
       */
      public mediapipe.MediapipeOptions.MediaPipeOptionsOrBuilder getOptionsOrBuilder() {
        if (optionsBuilder_ != null) {
          return optionsBuilder_.getMessageOrBuilder();
        } else {
          return options_ == null ?
              mediapipe.MediapipeOptions.MediaPipeOptions.getDefaultInstance() : options_;
        }
      }
      /**
       * <pre>
       * Can be used for annotating a graph.
       * </pre>
       *
       * <code>optional .mediapipe.MediaPipeOptions options = 1001;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          mediapipe.MediapipeOptions.MediaPipeOptions, mediapipe.MediapipeOptions.MediaPipeOptions.Builder, mediapipe.MediapipeOptions.MediaPipeOptionsOrBuilder> 
          getOptionsFieldBuilder() {
        if (optionsBuilder_ == null) {
          optionsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              mediapipe.MediapipeOptions.MediaPipeOptions, mediapipe.MediapipeOptions.MediaPipeOptions.Builder, mediapipe.MediapipeOptions.MediaPipeOptionsOrBuilder>(
                  getOptions(),
                  getParentForChildren(),
                  isClean());
          options_ = null;
        }
        return optionsBuilder_;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return this;
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return this;
      }


      // @@protoc_insertion_point(builder_scope:mediapipe.CalculatorGraphConfig)
    }

    // @@protoc_insertion_point(class_scope:mediapipe.CalculatorGraphConfig)
    private static final com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig();
    }

    public static com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<CalculatorGraphConfig>
        PARSER = new com.google.protobuf.AbstractParser<CalculatorGraphConfig>() {
      public CalculatorGraphConfig parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
          return new CalculatorGraphConfig(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<CalculatorGraphConfig> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<CalculatorGraphConfig> getParserForType() {
      return PARSER;
    }

    public com.google.mediapipe.proto.CalculatorProto.CalculatorGraphConfig getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_mediapipe_ExecutorConfig_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_mediapipe_ExecutorConfig_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_mediapipe_InputCollection_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_mediapipe_InputCollection_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_mediapipe_InputCollectionSet_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_mediapipe_InputCollectionSet_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_mediapipe_InputStreamInfo_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_mediapipe_InputStreamInfo_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_mediapipe_ProfilerConfig_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_mediapipe_ProfilerConfig_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_mediapipe_CalculatorGraphConfig_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_mediapipe_CalculatorGraphConfig_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_mediapipe_CalculatorGraphConfig_Node_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_mediapipe_CalculatorGraphConfig_Node_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n$mediapipe/framework/calculator.proto\022\t" +
      "mediapipe\032,mediapipe/framework/calculato" +
      "r_options.proto\032\031google/protobuf/any.pro" +
      "to\032+mediapipe/framework/mediapipe_option" +
      "s.proto\032(mediapipe/framework/packet_fact" +
      "ory.proto\032*mediapipe/framework/packet_ge" +
      "nerator.proto\032(mediapipe/framework/statu" +
      "s_handler.proto\032(mediapipe/framework/str" +
      "eam_handler.proto\"Z\n\016ExecutorConfig\022\014\n\004n" +
      "ame\030\001 \001(\t\022\014\n\004type\030\002 \001(\t\022,\n\007options\030\003 \001(\013",
      "2\033.mediapipe.MediaPipeOptions\"\221\002\n\017InputC" +
      "ollection\022\014\n\004name\030\001 \001(\t\022\030\n\020side_packet_n" +
      "ame\030\002 \003(\t\022\034\n\023external_input_name\030\352\007 \003(\t\022" +
      "8\n\ninput_type\030\003 \001(\0162$.mediapipe.InputCol" +
      "lection.InputType\022\021\n\tfile_name\030\004 \001(\t\"k\n\t" +
      "InputType\022\013\n\007UNKNOWN\020\000\022\014\n\010RECORDIO\020\001\022\024\n\020" +
      "FOREIGN_RECORDIO\020\002\022\024\n\020FOREIGN_CSV_TEXT\020\003" +
      "\022\027\n\023INVALID_UPPER_BOUND\020\004\"J\n\022InputCollec" +
      "tionSet\0224\n\020input_collection\030\001 \003(\0132\032.medi" +
      "apipe.InputCollection\"7\n\017InputStreamInfo",
      "\022\021\n\ttag_index\030\001 \001(\t\022\021\n\tback_edge\030\002 \001(\010\"\220" +
      "\004\n\016ProfilerConfig\022$\n\034histogram_interval_" +
      "size_usec\030\001 \001(\003\022\037\n\027num_histogram_interva" +
      "ls\030\002 \001(\003\022\'\n\033enable_input_output_latency\030" +
      "\003 \001(\010B\002\030\001\022\027\n\017enable_profiler\030\004 \001(\010\022\035\n\025en" +
      "able_stream_latency\030\005 \001(\010\022-\n%use_packet_" +
      "timestamp_for_added_packet\030\006 \001(\010\022\032\n\022trac" +
      "e_log_capacity\030\007 \001(\003\022\"\n\032trace_event_type" +
      "s_disabled\030\010 \003(\005\022\026\n\016trace_log_path\030\t \001(\t" +
      "\022\027\n\017trace_log_count\030\n \001(\005\022\037\n\027trace_log_i",
      "nterval_usec\030\013 \001(\003\022\035\n\025trace_log_margin_u" +
      "sec\030\014 \001(\003\022!\n\031trace_log_duration_events\030\r" +
      " \001(\010\022 \n\030trace_log_interval_count\030\016 \001(\005\022\032" +
      "\n\022trace_log_disabled\030\017 \001(\010\022\025\n\rtrace_enab" +
      "led\030\020 \001(\010\"\254\n\n\025CalculatorGraphConfig\0223\n\004n" +
      "ode\030\001 \003(\0132%.mediapipe.CalculatorGraphCon" +
      "fig.Node\0226\n\016packet_factory\030\006 \003(\0132\036.media" +
      "pipe.PacketFactoryConfig\022:\n\020packet_gener" +
      "ator\030\007 \003(\0132 .mediapipe.PacketGeneratorCo" +
      "nfig\022\023\n\013num_threads\030\010 \001(\005\0226\n\016status_hand",
      "ler\030\t \003(\0132\036.mediapipe.StatusHandlerConfi" +
      "g\022\024\n\014input_stream\030\n \003(\t\022\025\n\routput_stream" +
      "\030\017 \003(\t\022\031\n\021input_side_packet\030\020 \003(\t\022\032\n\022out" +
      "put_side_packet\030\021 \003(\t\022\026\n\016max_queue_size\030" +
      "\013 \001(\005\022\027\n\017report_deadlock\030\025 \001(\010\022A\n\024input_" +
      "stream_handler\030\014 \001(\0132#.mediapipe.InputSt" +
      "reamHandlerConfig\022C\n\025output_stream_handl" +
      "er\030\r \001(\0132$.mediapipe.OutputStreamHandler" +
      "Config\022+\n\010executor\030\016 \003(\0132\031.mediapipe.Exe" +
      "cutorConfig\0222\n\017profiler_config\030\022 \001(\0132\031.m",
      "ediapipe.ProfilerConfig\022\017\n\007package\030\023 \001(\t" +
      "\022\014\n\004type\030\024 \001(\t\022-\n\007options\030\351\007 \001(\0132\033.media" +
      "pipe.MediaPipeOptions\032\320\004\n\004Node\022\014\n\004name\030\001" +
      " \001(\t\022\022\n\ncalculator\030\002 \001(\t\022\024\n\014input_stream" +
      "\030\003 \003(\t\022\025\n\routput_stream\030\004 \003(\t\022\031\n\021input_s" +
      "ide_packet\030\005 \003(\t\022\032\n\022output_side_packet\030\006" +
      " \003(\t\022-\n\007options\030\007 \001(\0132\034.mediapipe.Calcul" +
      "atorOptions\022*\n\014node_options\030\010 \003(\0132\024.goog" +
      "le.protobuf.Any\022\024\n\014source_layer\030\t \001(\005\022\030\n" +
      "\020buffer_size_hint\030\n \001(\005\022A\n\024input_stream_",
      "handler\030\013 \001(\0132#.mediapipe.InputStreamHan" +
      "dlerConfig\022C\n\025output_stream_handler\030\014 \001(" +
      "\0132$.mediapipe.OutputStreamHandlerConfig\022" +
      "5\n\021input_stream_info\030\r \003(\0132\032.mediapipe.I" +
      "nputStreamInfo\022\020\n\010executor\030\016 \001(\t\0226\n\017prof" +
      "iler_config\030\017 \001(\0132\031.mediapipe.ProfilerCo" +
      "nfigB\002\030\001\022\025\n\rmax_in_flight\030\020 \001(\005\022\027\n\016exter" +
      "nal_input\030\355\007 \003(\tB-\n\032com.google.mediapipe" +
      ".protoB\017CalculatorProtoP\000b\006proto3"
    };
    com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =
        new com.google.protobuf.Descriptors.FileDescriptor.    InternalDescriptorAssigner() {
          public com.google.protobuf.ExtensionRegistry assignDescriptors(
              com.google.protobuf.Descriptors.FileDescriptor root) {
            descriptor = root;
            return null;
          }
        };
    com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
          com.google.mediapipe.proto.CalculatorOptionsProto.getDescriptor(),
          com.google.protobuf.AnyProto.getDescriptor(),
          mediapipe.MediapipeOptions.getDescriptor(),
          mediapipe.PacketFactory.getDescriptor(),
          mediapipe.PacketGenerator.getDescriptor(),
          mediapipe.StatusHandler.getDescriptor(),
          mediapipe.StreamHandler.getDescriptor(),
        }, assigner);
    internal_static_mediapipe_ExecutorConfig_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_mediapipe_ExecutorConfig_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_mediapipe_ExecutorConfig_descriptor,
        new java.lang.String[] { "Name", "Type", "Options", });
    internal_static_mediapipe_InputCollection_descriptor =
      getDescriptor().getMessageTypes().get(1);
    internal_static_mediapipe_InputCollection_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_mediapipe_InputCollection_descriptor,
        new java.lang.String[] { "Name", "SidePacketName", "ExternalInputName", "InputType", "FileName", });
    internal_static_mediapipe_InputCollectionSet_descriptor =
      getDescriptor().getMessageTypes().get(2);
    internal_static_mediapipe_InputCollectionSet_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_mediapipe_InputCollectionSet_descriptor,
        new java.lang.String[] { "InputCollection", });
    internal_static_mediapipe_InputStreamInfo_descriptor =
      getDescriptor().getMessageTypes().get(3);
    internal_static_mediapipe_InputStreamInfo_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_mediapipe_InputStreamInfo_descriptor,
        new java.lang.String[] { "TagIndex", "BackEdge", });
    internal_static_mediapipe_ProfilerConfig_descriptor =
      getDescriptor().getMessageTypes().get(4);
    internal_static_mediapipe_ProfilerConfig_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_mediapipe_ProfilerConfig_descriptor,
        new java.lang.String[] { "HistogramIntervalSizeUsec", "NumHistogramIntervals", "EnableInputOutputLatency", "EnableProfiler", "EnableStreamLatency", "UsePacketTimestampForAddedPacket", "TraceLogCapacity", "TraceEventTypesDisabled", "TraceLogPath", "TraceLogCount", "TraceLogIntervalUsec", "TraceLogMarginUsec", "TraceLogDurationEvents", "TraceLogIntervalCount", "TraceLogDisabled", "TraceEnabled", });
    internal_static_mediapipe_CalculatorGraphConfig_descriptor =
      getDescriptor().getMessageTypes().get(5);
    internal_static_mediapipe_CalculatorGraphConfig_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_mediapipe_CalculatorGraphConfig_descriptor,
        new java.lang.String[] { "Node", "PacketFactory", "PacketGenerator", "NumThreads", "StatusHandler", "InputStream", "OutputStream", "InputSidePacket", "OutputSidePacket", "MaxQueueSize", "ReportDeadlock", "InputStreamHandler", "OutputStreamHandler", "Executor", "ProfilerConfig", "Package", "Type", "Options", });
    internal_static_mediapipe_CalculatorGraphConfig_Node_descriptor =
      internal_static_mediapipe_CalculatorGraphConfig_descriptor.getNestedTypes().get(0);
    internal_static_mediapipe_CalculatorGraphConfig_Node_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_mediapipe_CalculatorGraphConfig_Node_descriptor,
        new java.lang.String[] { "Name", "Calculator", "InputStream", "OutputStream", "InputSidePacket", "OutputSidePacket", "Options", "NodeOptions", "SourceLayer", "BufferSizeHint", "InputStreamHandler", "OutputStreamHandler", "InputStreamInfo", "Executor", "ProfilerConfig", "MaxInFlight", "ExternalInput", });
    com.google.mediapipe.proto.CalculatorOptionsProto.getDescriptor();
    com.google.protobuf.AnyProto.getDescriptor();
    mediapipe.MediapipeOptions.getDescriptor();
    mediapipe.PacketFactory.getDescriptor();
    mediapipe.PacketGenerator.getDescriptor();
    mediapipe.StatusHandler.getDescriptor();
    mediapipe.StreamHandler.getDescriptor();
  }

  // @@protoc_insertion_point(outer_class_scope)
}
